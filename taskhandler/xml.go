package taskhandler

import (
	"cvevulner/models"
	"encoding/xml"
	"fmt"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

type Updates struct {
	XMLName xml.Name `xml:"updates,omitempty"`
	Updatex []Update `xml:"update,omitempty"`
}

type Update struct {
	XMLName     xml.Name    `xml:"update,omitempty"`
	From        string      `xml:"from,attr"`
	Type        string      `xml:"type,attr"`
	Status      string      `xml:"status,attr"`
	Id          string      `xml:"id"`
	Title       string      `xml:"title"`
	Severity    string      `xml:"severity"`
	Release     string      `xml:"release"`
	Issued      *Issued     `xml:"issued,omitempty"`
	References  *References `xml:"references,omitempty"`
	Description string      `xml:"description"`
	Pkglist     *Pkglist    `xml:"pkglist,omitempty"`
}

type Issued struct {
	XMLName xml.Name `xml:"issued,omitempty"`
	Date    string   `xml:"date,attr"`
}

type References struct {
	XMLName   xml.Name    `xml:"references,omitempty"`
	Reference []Reference `xml:"reference,omitempty"`
}

type Reference struct {
	XMLName xml.Name `xml:"reference,omitempty"`
	Href    string   `xml:"href,attr"`
	Id      string   `xml:"id,attr"`
	Title   string   `xml:"title,attr"`
	Type    string   `xml:"type,attr"`
}

type Pkglist struct {
	XMLName    xml.Name    `xml:"pkglist,omitempty"`
	Collection *Collection `xml:"collection,omitempty"`
}

type Collection struct {
	XMLName xml.Name  `xml:"collection,omitempty"`
	Name    string    `xml:"name"`
	Package []Package `xml:"package,omitempty"`
}

type Package struct {
	XMLName  xml.Name `xml:"package,omitempty"`
	Arch     string   `xml:"arch,attr"`
	Name     string   `xml:"name,attr"`
	Release  string   `xml:"release,attr"`
	Version  string   `xml:"version,attr"`
	Filename string   `xml:"filename"`
}

// Intermediate information
type SecurityNoticeXml struct {
	CveNum        string
	Title         string
	Type          string
	ReferenceLink string
	Description   string
}

type PackRpm struct {
	PackName string
}

type CveXml struct {
	PublicDate     string
	OpenEulerSANum string
	Introduction   string
	CveLevel       string
	OwnedComponent string
	SecurityNotice map[string][]SecurityNoticeXml
	PackRpmx       map[string][]PackRpm
}

func ReadXml(filePath string, dpdates *Updates) error {
	if filePath == "" || len(filePath) == 0 {
		filePath = "download/updateinfo.xml"
	}
	fd, err := os.Open(filePath)
	if err != nil {
		logs.Error("open file err : ", err, ",filePath: ", filePath)
		return err
	}
	defer fd.Close()
	fileContent, err := ioutil.ReadAll(fd)
	if err != nil {
		logs.Error("read file err : ", err, ", filePath: ", filePath)
		return err
	}
	err = xml.Unmarshal(fileContent, dpdates)
	if err != nil {
		logs.Error("unmarshal err : ", err, ", fileContent: ", fileContent)
		return err
	}
	return nil
}

func WriteXml(filePath string, cveXmlList []CveXml, dpdates *Updates,
	securityNotice map[string][]SecurityNoticeXml, packRpmx map[string][]PackRpm) {
	for _, cveXml := range cveXmlList {
		upDatex := Update{From: "openeuler.org", Type: "security", Status: "stable", Id: cveXml.OpenEulerSANum,
			Title: cveXml.Introduction, Severity: cveXml.CveLevel, Release: "openEuler"}
		var pubDate Issued
		pubDate.Date = cveXml.PublicDate
		upDatex.Issued = &pubDate
		var rfs References
		if sn, ok := securityNotice[cveXml.OwnedComponent]; ok {
			if len(sn) > 0 {
				descriptionsList := []string{}
				for _, sec := range sn {
					var rf Reference
					rf.Id = sec.CveNum
					rf.Title = sec.CveNum
					rf.Href = sec.ReferenceLink
					rf.Type = "cve"
					descriptionsList = append(descriptionsList, sec.Description)
					rfs.Reference = append(rfs.Reference, rf)
				}
				upDatex.Description = strings.Join(descriptionsList, " ")
			}
		}
		upDatex.References = &rfs
		var pl Pkglist
		var ct Collection
		ct.Name = "openEuler"
		if prx, ok := packRpmx[cveXml.OwnedComponent]; ok{
			if len(prx) > 0 {
				for _, pr := range prx {
					var pe Package
					pe.Filename = pr.PackName
					//pe.Name = cveXml.OwnedComponent
					if len(pr.PackName) > len(cveXml.OwnedComponent) {
						//packVersion := pr.PackName[len(cveXml.OwnedComponent) + 1: len(pr.PackName) - 4]
						packVersionList := strings.Split(pr.PackName, "-")
						if len(packVersionList) >= 3 {
							pe.Version = packVersionList[len(packVersionList) - 2]
							rpmName := packVersionList[len(packVersionList) - 1][:len(packVersionList[len(packVersionList) - 1]) - 4]
							lastIndex := strings.LastIndexAny(rpmName, ".")
							if lastIndex != -1 {
								pe.Release = rpmName[:lastIndex]
								pe.Arch = rpmName[lastIndex + 1:]
							}
							pe.Name = strings.Join(packVersionList[0:len(packVersionList) - 2], "-")
						}
					}
					ct.Package = append(ct.Package, pe)
				}
			}
		}
		pl.Collection = &ct
		upDatex.Pkglist = &pl
		dpdates.Updatex = append(dpdates.Updatex, upDatex)
	}
	xmlOutPut, outPutErr := xml.MarshalIndent(dpdates, "", "")
	if outPutErr == nil {
		//加入XML头
		headerBytes := []byte(xml.Header)
		//拼接XML头和实际XML内容
		xmlOutPutData := append(headerBytes, xmlOutPut...)
		//写入文件
		ioutil.WriteFile(filePath, xmlOutPutData, os.ModeAppend)
	} else {
		fmt.Println(outPutErr)
	}
}

func BuildXml(cveXml *[]CveXml, v *models.ExcelExport,
	securityNotice map[string][]SecurityNoticeXml, packRpmx map[string][]PackRpm) {
	pkg, pkgErr := models.GetCvePackageList(v.SecID)
	if pkgErr != nil {
		logs.Error(pkgErr)
		return
	}
	//cvex.SecurityNotice = make(map[string][]SecurityNoticeXml)
	sn := SecurityNoticeXml{CveNum: v.CveNum, Title: v.CveNum, Type: "cve", ReferenceLink: v.ReferenceLink,
		Description: deleteTailBlank(v.CveBrief) + "(" + v.CveNum + ")"}
	if vx, ok := securityNotice[v.OwnedComponent]; !ok {
		snArry := []SecurityNoticeXml{}
		snArry = append(snArry, sn)
		securityNotice[v.OwnedComponent] = snArry
		var cvex CveXml
		if v.PublicDate == "" {
			v.PublicDate = time.Now().Format("2006-01-02")
		}
		cvex.OpenEulerSANum = v.OpenEulerSANum
		cvex.PublicDate = v.PublicDate
		if strings.ToLower(v.CveLevel) == "low" {
			cvex.CveLevel = "Low"
		} else if strings.ToLower(v.CveLevel) == "medium" {
			cvex.CveLevel = "Moderate"
		} else if strings.ToLower(v.CveLevel) == "high" {
			cvex.CveLevel = "Important"
		} else {
			cvex.CveLevel = "Critical"
		}
		cvex.Introduction = v.Introduction
		cvex.OwnedComponent = v.OwnedComponent
		*cveXml = append(*cveXml, cvex)
	} else {
		vx = append(vx, sn)
		securityNotice[v.OwnedComponent] = vx
	}
	//cvex.PackRpmx = make(map[string][]PackRpm)
	if px, ok := packRpmx[v.OwnedComponent]; !ok {
		prArry := []PackRpm{}
		for _, v := range pkg {
			pr := PackRpm{PackName: v.PackName}
			prArry = append(prArry, pr)
		}
		packRpmx[v.OwnedComponent] = prArry
	} else {
		for _, v := range pkg {
			pnFlag := false
			for _, p := range px {
				if p.PackName == v.PackName {
					pnFlag = true
					break
				}
			}
			if !pnFlag {
				pr := PackRpm{PackName: v.PackName}
				px = append(px, pr)
			}
		}
		packRpmx[v.OwnedComponent] = px
	}
	return
}
