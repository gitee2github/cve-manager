package models

import (
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/orm"
)

func GetIpWhite(ip string, iw *IpWhite) (err error) {
	o := orm.NewOrm()
	err = o.Raw("select * FROM cve_ip_white WHERE machine_ip=?", ip).QueryRow(iw)
	if err == nil {
		logs.Info("GetIpWhite, ip:", ip, " ,In the whitelist")
	} else {
		// Do not process blacklist
		//logs.Error("ip:", ip, " Restricted access")
	}
	return nil
}

func GetPackageInfo(packageName, version string, gi *GitPackageInfo) (err error) {
	o := orm.NewOrm()
	err = o.Raw("select * FROM cve_git_package_info WHERE package_name=? and version=? and status=?",
		packageName, version, 0).QueryRow(gi)
	if err == nil {
		logs.Info("GetPackageInfo, cve_git_package_info, "+
			"packageName: ", packageName, ", search successful")
		return nil
	} else {
		logs.Error("GetPackageInfo, cve_git_package_info, "+
			"packageName: ", packageName, ", Data does not exist, err: ", err)
	}
	return err
}

func GetSubPackage(packageInfoId int64) (gg []GitSubPack, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPack
	num, err = o.Raw("select sub_id,ids,sub_pack_name "+
		"FROM cve_git_sub_pack WHERE detail_id=?",
		packageInfoId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackage, cve_git_sub_pack, "+
			"packageInfoId: ", packageInfoId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackage, cve_git_sub_pack, "+
			"packageInfoId: ", packageInfoId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackProvide(subId int64) (gg []GitSubPackProvides, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackProvides
	num, err = o.Raw("select provide_id,ids,provide_name, requiredb "+
		"FROM cve_git_sub_pack_provides WHERE sub_id=?",
		subId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackProvide, cve_git_sub_pack_provides, "+
			"subId: ", subId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackProvide, cve_git_sub_pack_provides, "+
			"subId: ", subId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackrequiredby(provideId int64) (gg []GitSubPackRequiredby, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackRequiredby
	num, err = o.Raw("select id,requiredb FROM cve_git_sub_pack_requiredby WHERE provide_id=?",
		provideId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackrequiredby, cve_git_sub_pack_requiredby, "+
			"provideId: ", provideId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackrequiredby, cve_git_sub_pack_requiredby, "+
			"provideId: ", provideId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetSubPackRequire(subId int64) (gg []GitSubPackRequire, num int64, err error) {
	o := orm.NewOrm()
	var gs []GitSubPackRequire
	num, err = o.Raw("select require_id,ids,require_name, providedb "+
		"FROM cve_git_sub_pack_require WHERE sub_id=?",
		subId).QueryRows(&gs)
	if num > 0 && err == nil {
		logs.Info("GetSubPackRequire, cve_git_sub_pack_require, "+
			"subId: ", subId, " , search successful")
		return gs, num, nil
	} else {
		logs.Error("GetSubPackRequire, cve_git_sub_pack_require, "+
			"subId: ", subId, " , Data does not exist, err: ", err)
	}
	return gs, 0, err
}

func GetPackageList(pagesize int64, pagenum int64, QueryPkgName string) (ge []GitOpenEuler, num int64, err error) {
	o := orm.NewOrm()
	qs := o.QueryTable("cve_git_open_euler")
	var us []GitOpenEuler
	if QueryPkgName != "" {
		cnt, err := qs.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).Limit(pagesize, (pagenum-1)*pagesize).All(&us)
		if err == nil {
			logs.Info("GetPackageList, cve_git_open_euler, count: ", cnt, ",pagesize ",
				pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
		} else {
			logs.Error("GetPackageList, cve_git_open_euler, err: ", err, ",pagesize ",
				pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
		}
		return us, cnt, err
	} else {
		cnt, err := qs.Filter("status", 1).Limit(pagesize, (pagenum-1)*pagesize).All(&us)
		if err == nil {
			logs.Info("GetPackageList, cve_git_open_euler, count: ", cnt, ",pagesize ",
				pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
		} else {
			logs.Error("GetPackageList, cve_git_open_euler, err: ", err, ",pagesize ",
				pagesize, ",pagenum ", pagenum, ", QueryPkgName ", QueryPkgName)
		}
		return us, cnt, err
	}
}

func GetPackageNum(QueryPkgName string) int64 {
	o := orm.NewOrm()
	cg := o.QueryTable("cve_git_open_euler")
	var ge []GitOpenEuler
	if QueryPkgName != "" {
		num, err := cg.Filter("package_name__icontains", QueryPkgName).Filter("status", 1).All(&ge)
		if err == nil {
			return num
		} else {
			return 0
		}
	} else {
		num, err := cg.Filter("git_id__gt", 0).Filter("status", 1).All(&ge)
		if err == nil {
			return num
		} else {
			return 0
		}
	}
}
