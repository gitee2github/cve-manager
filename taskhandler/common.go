package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"fmt"
	"strconv"
)

type GiteeToken struct {
	GrantType string
	UserName string
	Password string
	ClientId string
	ClientSecret string
	Scope string
}

func GitOpenEulerData(values map[string]interface{}, ge *models.GitOpenEuler, tb models.GitPackageTable) {
	defer common.Catchs()
	ge.TableName = tb.TableName
	ge.TableId = tb.TableId
	ge.Status = 0
	if values["feature"] == nil {
		ge.Feature = ""
	} else {
		switch values["feature"].(type) {
		case string:
			ge.Feature = values["feature"].(string)
		case int:
			ge.Feature = strconv.Itoa(values["feature"].(int))
		case int64:
			ge.Feature = strconv.FormatInt(values["feature"].(int64),10)
		case float64:
			ge.Feature = strconv.FormatInt(int64(values["feature"].(float64)),10)
		default:
			ge.Feature = ""
		}
	}
	if values["url"] == nil {
		ge.OriginUrl = ""
	} else {
		ge.OriginUrl = values["url"].(string)
	}
	switch values["id"].(type) {
	case string:
		ge.PackageId, _ = strconv.ParseInt(values["id"].(string), 10, 64)
	case int:
		ge.PackageId = values["id"].(int64)
	case int64:
		ge.PackageId = values["id"].(int64)
	case float64:
		ge.PackageId = int64(values["id"].(float64))
	default:
		ge.PackageId = 0
	}
	if values["name"] == nil {
		ge.PackageName = ""
	} else {
		packName := values["name"].(string)
		if packName != "" {
			packName = common.DeletePreAndSufSpace(packName)
		}
		ge.PackageName = packName
	}
	if values["version"] == nil {
		ge.Version = ""
	} else {
		version := values["version"].(string)
		if version != "" {
			version = common.DeletePreAndSufSpace(version)
		}
		ge.Version = version
	}
	if values["release"] == nil {
		ge.Release = ""
	} else {
		release := values["release"].(string)
		if release != "" {
			release = common.DeletePreAndSufSpace(release)
		}
		ge.Release = release
	}
	if values["rpm_license"] == nil {
		ge.License = ""
	} else {
		ge.License = values["rpm_license"].(string)
	}
	if values["maintainer"] == nil {
		ge.MainTainer = ""
	} else {
		ge.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		ge.MainTainLevel = 0
	} else {
		ge.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["release_time"] == nil {
		ge.ReleaseTime = ""
	} else {
		ge.ReleaseTime = values["release_time"].(string)
	}
	switch values["used_time"].(type) {
	case string:
		ge.UsedTime = values["used_time"].(string)
	case int:
		ge.UsedTime = strconv.Itoa(values["used_time"].(int))
	case int64:
		ge.UsedTime = strconv.FormatInt(values["used_time"].(int64),10)
	case float64:
		ge.UsedTime = strconv.FormatInt(int64(values["used_time"].(float64)),10)
	default:
		ge.UsedTime = ""
	}
	if values["latest_version"] == nil {
		ge.LatestVersion = ""
	} else {
		ge.LatestVersion = values["latest_version"].(string)
	}
	if values["latest_version_time"] == nil {
		ge.LatestVersionTime = ""
	} else {
		ge.LatestVersionTime = values["latest_version_time"].(string)
	}
	switch values["issue"].(type) {
	case string:
		ge.IssueCount, _ = strconv.ParseInt(values["issue"].(string), 10, 64)
	case int:
		ge.IssueCount = values["issue"].(int64)
	case int64:
		ge.IssueCount = values["issue"].(int64)
	case float64:
		ge.IssueCount = int64(values["issue"].(float64))
	default:
		ge.IssueCount = 0
	}
}


func GitOpenEulerInfoData(values map[string]interface{}, gp *models.GitPackageInfo, ge models.GitOpenEuler) {
	defer common.Catchs()
	gp.GitId = ge.GitId
	gp.Ids = 0
	if values["pkg_name"] == nil {
		gp.PackageName = ""
	}else {
		PackageName := values["pkg_name"].(string)
		if PackageName != "" {
			PackageName = common.DeletePreAndSufSpace(PackageName)
		}
		gp.PackageName = PackageName
	}
	if values["version"] == nil {
		gp.Version = ""
	} else {
		Version := values["version"].(string)
		if Version != "" {
			Version = common.DeletePreAndSufSpace(Version)
		}
		gp.Version = Version
	}
	if values["release"] == nil {
		gp.Release = ""
	} else {
		Release := values["release"].(string)
		if Release != "" {
			Release = common.DeletePreAndSufSpace(Release)
		}
		gp.Release = Release
	}
	if values["url"] == nil {
		gp.OriginUrl = ""
	}else {
		gp.OriginUrl = values["url"].(string)
	}
	if values["license"] == nil {
		gp.License = ""
	} else {
		gp.License = values["license"].(string)
	}
	switch values["feature"].(type) {
	case string:
		gp.Feature = values["feature"].(string)
	case int:
		gp.Feature = strconv.Itoa(values["feature"].(int))
	case int64:
		gp.Feature = strconv.FormatInt(values["feature"].(int64),10)
	case float64:
		gp.Feature = strconv.FormatInt(int64(values["feature"].(float64)),10)
	default:
		gp.Feature = ""
	}
	if values["maintainer"] == nil {
		gp.MainTainer = ""
	} else {
		gp.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		gp.MainTainLevel = 0
	} else {
		gp.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["gitee_url"] == nil {
		gp.GitUrl = ""
	} else {
		gp.GitUrl = values["gitee_url"].(string)
	}
	if values["summary"] == nil {
		gp.Summary = ""
	} else {
		gp.Summary = values["summary"].(string)
	}
	if values["description"] == nil {
		gp.Decription = ""
	} else {
		gp.Decription = values["description"].(string)
	}
	BuildRequired := ""
	if values["buildrequired"].([]interface{}) != nil && len(values["buildrequired"].([]interface{})) > 0{
		for _, vx := range values["buildrequired"].([]interface{}) {
			BuildRequired = BuildRequired + vx.(string) + ","
		}
		gp.BuildRequired = BuildRequired[:len(BuildRequired) - 1]
	} else {
		gp.BuildRequired = BuildRequired
	}
	gp.Status = 0
}


type GitTablePackCount struct {
	Page int
	Size int
	TableName string
	Count int64
}

func CreateIssueBody(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score, OpenEulerScore, score, labels string,
	its models.IssueTemplate, flag int, issueType, pkgLink string) string{
	requestBody := ""
	if flag == 1 {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/"+ cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>"+ path +"</br>"+
			"<br>漏洞归属的版本: </br>" + "<br>" +cve.CveVersion +"</br>" + "<br>CVSS V3.0分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: " + sc.NvectorVule + "</br>" + "<br>漏洞描述: </br>" +
			"<br>" + cve.Description +"</br>" + "<br>影响性分析说明: </br>" +
			"<br>"+its.CveAnalysis +" </br>" + "<br>原理分析: </br>" + "<br>" + its.PrincipleAnalysis+"</br>" +
			"<br>openEuler评分: </br>" + "<br> "+ OpenEulerScore + "</br>" +
			"<br>Vector: </br>" + "<br> " +its.OpenEulerVector + "</br>" +
			"<br>受影响版本: </br>" + "<br> "+its.AffectedVersion+"</br>" +
			"<br>规避方案或消减措施: </br><br> "+ its.Solution +"</br>" +
			"<br>受影响的包: </br><br> "+ " " +"</br><br> </br>" + "@" + assignee + "<br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, its.StatusName, body, assignee, labels)
	} else if flag == 2 {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/"+ cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>"+ path +"</br>"+
			"<br>漏洞归属的版本: </br>" + "<br>" +cve.CveVersion +"</br>" + "<br>CVSS V3.0分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: " + sc.NvectorVule + "</br>" + "<br>漏洞描述: </br>" +
			"<br>" + cve.Description +"</br>" + "<br>影响性分析说明: </br>" +
			"<br> </br>" + "<br>原理分析: </br>" + "<br> </br>" + "<br>openEuler评分: </br>" + "<br> </br>" +
			"<br>Vector: </br>" + "<br> </br>" + "<br>受影响版本: </br>" + "<br> </br>" +
			"<br>规避方案或消减措施: </br><br> </br>" + "<br>受影响的包: </br><br> " + " " +"</br><br> </br>" + "@" + assignee + "<br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"issue_type": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, issueType, body, assignee, labels)
	} else {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/"+ cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>"+ path +"</br>"+
			"<br>漏洞归属的版本: </br>" + "<br>" +cve.CveVersion +"</br>" + "<br>CVSS V3.0分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: " + its.NVDVector + "</br>" + "<br>漏洞描述: </br>" +
			"<br>" + cve.Description +"</br>" + "<br>影响性分析说明: </br>" +
			"<br>"+its.CveAnalysis +" </br>" + "<br>原理分析: </br>" + "<br>" + its.PrincipleAnalysis+"</br>" +
			"<br>openEuler评分: </br>" + "<br> "+ OpenEulerScore + "</br>" +
			"<br>Vector: </br>" + "<br> " +its.OpenEulerVector + "</br>" +
			"<br>受影响版本: </br>" + "<br> "+its.AffectedVersion+"</br>" +
			"<br>规避方案或消减措施: </br><br> "+ its.Solution +"</br>" + "<br>受影响的包: </br><br> "+
			pkgLink +"</br><br> </br>" + "@" + its.Assignee + "<br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, its.StatusName, body, its.Assignee, labels)
	}
	return requestBody
}