package models

import (
	"cvevulner/util"
	"errors"
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/orm"
	"strings"
)

//Loophole issue body model
type Loophole struct {
	Number            string //编号
	Components        string // 漏洞归属的组件
	Version           string // 漏洞归属的版本
	CvsScore          string //cvss 评分
	CvsVector         string //cvs向量
	BriefIntroduction string //漏洞简述
	Influences        string //漏洞造成的影响
	Principle         string //漏洞原理
	OpScore           string //openEuler 评分
	OpVector          string //openEuler 向量
	InfVersion        string //受影响的组件版本
	AvoidScheme       string //规避方案
	InfPackage        string //受影响的软件包
	InfProduct        string //受影响的产品
	Repo              string //漏洞所属仓库
	RepoDesc          string //组件描述
	ScoreType         string //评分类型 v2 v3
}

//VectorValue cvss V3.0 vector  model
type VectorValue struct {
	AttackVector       string //AV
	AttackComplexity   string //AC
	PrivilegesRequired string //PR
	UserInteraction    string //UI
	Scope              string //S
	Confidentiality    string //C
	Integrity          string //I
	Availability       string //A
}

//VectorValueV2 cvss v2 vector  model
type VectorValueV2 struct {
	AccessVector     string //AV
	AccessComplexity string //AC
	Authentication   string //Au
	Confidentiality  string //C
	IntegrityImpact  string //I
	Availability     string //A
}

func (g *GiteOriginIssue) Insert() error {
	o := orm.NewOrm()
	_, err := o.Insert(g)
	return err
}

func (g GiteOriginIssue) Update() error {
	o := orm.NewOrm()
	_, err := o.Update(g)
	return err
}

func (g *GiteOriginIssue) InsertOrUpdate() error {
	if g.Number == "" {
		return errors.New("issue number can not be null")
	}
	o := orm.NewOrm()
	ex := GiteOriginIssue{Number: g.Number}
	err := o.Read(&ex, "number")
	if err == nil {
		g.Id = ex.Id
	}
	_, err = o.InsertOrUpdate(g)
	return err
}

func GetGiteOriginIssue(cveNum string) (oi GiteOriginIssue, err error) {
	o := orm.NewOrm()
	oi.CveNumber = cveNum
	err = o.Read(&oi, "cve_number")
	return
}

func (g *GiteOriginIssue) ParseToLoophole() (hole Loophole, err error) {
	lp := Loophole{}
	if g.Body == "" {
		return lp, errors.New("can not parse a null body")
	}
	lp.InfProduct = g.InfProduct
	lp.Repo = g.RepoPath
	lp.RepoDesc = g.RepoDesc
	scoreType, err := judgeScoreType(g.Body)
	if err != nil {
		logs.Error(err, "judgeScoreType, body: ", g.Body)
		return lp, err
	}
	lp.ScoreType = scoreType
	if isNewTpl(g.Body) {
		parseNewTplToLoopHole(&lp, g.Body)
	} else {
		parseOldTplToLoopHole(&lp, g.Body)
	}
	return lp, nil
}

func (v *VectorValue) VctToVectorValue(vector string) bool {
	if util.TrimString(vector) == "" {
		return false
	}
	m, ok := util.VctToMap(vector)
	if !ok {
		return false
	}
	v.AttackVector = util.ReadVMValue(m["AV"])
	v.AttackComplexity = util.ReadVMValue(m["AC"])
	v.Availability = util.ReadVMValue(m["A"])
	v.Confidentiality = util.ReadVMValue(m["C"])
	v.Integrity = util.ReadVMValue(m["I"])
	v.PrivilegesRequired = util.ReadVMValue(m["PR"])
	v.UserInteraction = util.ReadVMValue(m["UI"])
	v.Scope = util.ReadVMValue(m["S"])
	return true
}

func (v *VectorValueV2) VctToVectorValue(vector string) bool {
	if util.TrimString(vector) == "" {
		return false
	}
	m, ok := util.VctToMap(vector)
	if !ok {
		return false
	}
	v.AccessVector = util.ReadVMValueV2(m["AV"])
	v.AccessComplexity = util.ReadVMValueV2(m["AC"])
	v.Availability = util.ReadVMValueV2(m["A"])
	v.Confidentiality = util.ReadVMValueV2(m["C"])
	v.IntegrityImpact = util.ReadVMValueV2(m["I"])
	v.Authentication = util.ReadVMValueV2(m["Au"])
	return true
}

func judgeScoreType(body string) (st string, err error) {
	if body == "" {
		return "", errors.New("can not judge score type by nil body")
	}
	body = strings.ReplaceAll(body, " ", "")
	tb := []byte(body)
	vs := util.RegexpScoreTypeV2.Find(tb)
	if len(vs) > 0 {
		return util.CvsScoreV2, nil
	}
	vs = util.RegexpScoreTypeV3.Find(tb)
	if len(vs) > 0 {
		return util.CvsScoreV3, nil
	}
	return "", errors.New("can not judge score type")
}

func isNewTpl(body string) bool {
	tb := []byte(body)
	v1 := util.RegexpIsNewTpl.Find(tb)
	v2 := util.RegexpIsNewTpl2.Find(tb)
	if len(v1) > 0 || len(v2) > 0 {
		return false
	} else {
		return true
	}
}

func parseOldTplToLoopHole(lp *Loophole, body string) {
	sm := util.RegexpCveNumber.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		val := sm[0][1]
		lp.Number = util.GetCveNumber(util.TrimString(val))
	}
	sm = util.RegexpCveComponents.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 1 {
		for _, v := range sm[0][1:] {
			if v != "" {
				lp.Components = strings.ToLower(util.TrimString(v))
				break
			}
		}
	}
	sm = util.RegexpCveVersion.FindAllStringSubmatch(body, 1)
	if len(sm) > 0 && len(sm[0]) > 1 {
		for _, v := range sm[0][1:] {
			if v != "" {
				lp.Version = util.TrimString(v)
				break
			}
		}
	}
	sm = util.RegexpCveScore.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		vs := util.TrimString(sm[0][1])
		if cs := util.ExtractDigital(vs); cs != "" {
			lp.CvsScore = cs
		}
		if v := util.ExtractVector(vs, lp.ScoreType); v != "" {
			lp.CvsVector = v
		}
	}
	sm = util.RegexpCveBriefDesc.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.BriefIntroduction = sm[0][1]
	}
	sm = util.RegexpCveInfluencesDesc.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Influences = sm[0][1]
	}
	sm = util.RegexpCvePrincipleDesc.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Principle = sm[0][1]
	}
	sm = util.RegexpCveOpScore.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 {
		vp := util.TrimString(sm[0][1])
		if cs := util.ExtractDigital(vp); cs != "" {
			lp.OpScore = cs
		}
		if v := util.ExtractVector(vp, lp.ScoreType); v != "" {
			lp.OpVector = v
		}
	}
	sm = util.RegexpCveInfluencesVersion.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.InfVersion = util.TrimString(sm[0][1])
	}
	sm = util.RegexpCvePlannedMeasures.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 {
		if len(sm[0]) > 0 {
			lp.AvoidScheme = sm[0][1]
		}

	} else {
		sm = util.RegexpCvePlannedMeasures1.FindAllStringSubmatch(body, -1)
		if len(sm) > 0 && len(sm[0]) > 0 {
			lp.AvoidScheme = sm[0][1]
		}
	}
	sm = util.RegexpCveInfluencesPkg.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 {
		lp.InfPackage = util.TrimString(sm[0][1])
	}
	if lp.OpVector == "" {
		if lp.OpScore == "" {
			lp.OpScore = lp.CvsScore
			lp.OpVector = lp.CvsVector
		}else {
			if lp.OpScore == lp.CvsScore {
				lp.OpVector = lp.CvsVector
			}
		}
	}
}

func parseNewTplToLoopHole(lp *Loophole, body string) {
	sm := util.RegexpCveNumber.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		val := sm[0][1]
		lp.Number = util.GetCveNumber(util.TrimString(val))
	}

	sm = util.RegexpCveComponents.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 1 {
		for _, v := range sm[0][1:] {
			if v != "" {
				lp.Components = strings.ToLower(util.TrimString(v))
				break
			}
		}
	}

	sm = util.RegexpCveVersion.FindAllStringSubmatch(body, 1)
	if len(sm) > 0 && len(sm[0]) > 1 {
		for _, v := range sm[0][1:] {
			if v != "" {
				lp.Version = util.TrimString(v)
				break
			}
		}

	}
	sm = util.RegexpCveScore.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		vs := util.TrimString(sm[0][1])
		if cs := util.ExtractDigital(vs); cs != "" {
			lp.CvsScore = cs
		}
		if v := util.ExtractVector(vs, lp.ScoreType); v != "" {
			lp.CvsVector = v
		}
	}
	sm = util.RegexpCveBriefDescNew.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.BriefIntroduction = strings.Replace(sm[0][1], "二、漏洞分析结构反馈", "", -1)
	}
	sm = util.RegexpCveInfluencesDescNew.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Influences = sm[0][1]
	}
	sm = util.RegexpCveOpScoreNew.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 {
		vp := util.TrimString(sm[0][1])
		if cs := util.ExtractDigital(vp); cs != "" {
			lp.OpScore = cs
		}
		if v := util.ExtractVector(vp, lp.ScoreType); v != "" {
			lp.OpVector = v
		}
	}
	sm = util.RegexpCveInfluencesVersionNew.FindAllStringSubmatch(body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		value := util.ExtractCommentEffectVersion(sm[0][1])
		lp.InfVersion = util.TrimString(value)
	}
	if lp.OpVector == "" {
		if lp.OpScore == "" {
			lp.OpScore = lp.CvsScore
			lp.OpVector = lp.CvsVector
		}else {
			if lp.OpScore == lp.CvsScore {
				lp.OpVector = lp.CvsVector
			}
		}
	}
}
