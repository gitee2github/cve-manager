package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"github.com/astaxie/beego/logs"
	"strconv"
	"sync"
)

func GetYamlTables(url string) (string, error){
	compUrl := url + "/lifeCycle/tables"
	body, err:= util.HttpGetCom(compUrl)
	if err == nil && body != nil {
		var respBody map[string]interface{}
		err =json.Unmarshal(body, &respBody)
		if err != nil {
			logs.Error(err)
			return "", err
		}
		logs.Info(respBody)
		if respBody["code"].(string) == "2001"{
			for i, values := range respBody["data"].([]interface{}) {
				var gt models.GitPackageTable
				gt.TableName = values.(string)
				table_id, err := models.CreateYamlTable(&gt)
				if table_id > 0 {
					logs.Info("第 ", i, "条数据, table: ", values, "插入成功, table_id: ", table_id)
				} else {
					logs.Error("第 ", i, "条数据, table: ", values, "插入失败, err: ", err)
					return "", err
				}
			}
		} else {
			return "", errors.New("数据格式错误")
		}
	}
	return "", nil
}

var lock sync.Mutex
//var wg sync.WaitGroup

func GetYamlByGit(url string) (string, error) {
	defer common.Catchs()
	var gt []models.GitPackageTable
	page := 1
	size := 20
	num, err := models.GetYamlTable(&gt)
	if err != nil {
		logs.Error("查询表失败,无法获取yaml, err: ", err)
		return "", err
	}
	logs.Info("总共有: ", num, "表的数据需要获取, ", gt)
	compUrl1 := url + "/packages"
	var ch = make(chan int, len(gt))
	for i, tableValue := range gt {
		logs.Info("查询第 ", i, "tableName: ", tableValue.TableName, "开始...")
		//wg.Add(1)
		go func() {
			ok, err := GetYaml(url, compUrl1, page, size, tableValue, &ch)
			if err == nil {
				logs.Info("当前数据处理成功,i: ", i)
			} else {
				logs.Error("当前数据处理失败, ok: ", ok, ",i: ", i, ", err: ", err)
			}
		}()
		//<- ch
	}
	for i:=0; i< len(gt); i++ {
		<-ch
	}
	close(ch)
	//wg.Wait()
	return "", nil
}

func GetYaml(url, compUrl1 string, page, size int, tableValue models.GitPackageTable, ch *chan int) (string, error){
	//defer wg.Done()
	defer common.Catchs()
	var tc GitTablePackCount
	tc.TableName = tableValue.TableName
	tc.Page = 0
	tc.Size = 0
	tc.Page = page
	tc.Size = size
	compUrl2 := compUrl1 + "?table_name=" + tableValue.TableName
	for ;; {
		compUrl := compUrl2 +
			"&page_num=" + strconv.Itoa(tc.Page) + "&page_size=" + strconv.Itoa(size)
		body, err:= util.HttpGetCom(compUrl)
		var respBody map[string]interface{}
		if err == nil && body != nil {
			err =json.Unmarshal(body, &respBody)
			if err != nil {
				logs.Error(err)
				return "", err
			}
		} else {
			logs.Error( "http 请求失败， url: ", compUrl)
			return "", err
		}
		logs.Info("start: ", tc)
		if respBody["code"].(string) == "2001"{
			//chx := make(chan int)
			cur_count := 0
			if respBody == nil || respBody["data"] == nil || len(respBody["data"].([]interface{})) == 0{
				logs.Error("数据为空， url: ", compUrl)
				return "", err
			}
			for i, values := range respBody["data"].([]interface{}) {
				tc.Count = tc.Count + 1
				logs.Info("第：",tc.Page,"页, 到： ", tc.Size, "条, tableName: ",tc.TableName,
					",已处理到第count： ", tc.Count, "条, yaml values: ", values)
				if values == nil || values == "" || len(values.(map[string]interface{})) == 0{
					logs.Error("第：",tc.Page,"页, 到： ", tc.Size, "条, tableName: ",tc.TableName,
						",已处理到第count： ", tc.Count, "条, yaml values: ", values, ", 处理失败")
					cur_count = cur_count + 1
					continue
				}
				valuesx := values.(map[string]interface{})
				ok, err := ProcPackDetail(url, valuesx, tableValue, i)
				logs.Info("ok: ", ok, ", err: ", err)
				//<- chx
				cur_count = cur_count + 1
			}
			//close(chx)
			totalPage := 0
			switch respBody["total_page"].(type) {
			case string:
				totalPage, _ = strconv.Atoi(respBody["total_page"].(string))
			case int:
				totalPage = respBody["total_page"].(int)
			case int64:
				totalPage = int(respBody["total_page"].(int64))
			case float64:
				totalPage = int(int64(respBody["total_page"].(float64)))
			default:
				totalPage = 1
			}
			totalCount := 0
			switch respBody["total_count"].(type) {
			case string:
				totalCount, _ = strconv.Atoi(respBody["total_count"].(string))
			case int:
				totalCount = respBody["total_count"].(int)
			case int64:
				totalCount = int(respBody["total_count"].(int64))
			case float64:
				totalCount = int(int64(respBody["total_count"].(float64)))
			default:
				totalCount = 1
			}
			if tc.Page > totalPage || tc.Size >= totalCount{
				logs.Info("已处理完成：tableName: ", tc.TableName, "数据获取完成， " +
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compUrl)
				break
			} else {
				logs.Info("当前： tableName: ", tc.TableName, "数据获取完成， " +
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compUrl)
				lock.Lock()
				tc.Page = tc.Page + page
				tc.Size = tc.Size + cur_count
				lock.Unlock()
				logs.Info("增加后： tableName: ", tc.TableName, "数据获取完成， " +
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compUrl)
			}
			logs.Info("start: ", tc)
		} else {
			logs.Error("网络请求失败，url:", compUrl)
			continue
		}
	}
	*ch <- 1
	return "", nil
}


func ProcPackDetail(url string, values map[string]interface{}, tableValue models.GitPackageTable, i int) (string, error){
	var ge models.GitOpenEuler
	GitOpenEulerData(values, &ge, tableValue)
	ok, _ := models.GetSingleYaml(&ge)
	if ok {
		logs.Info("第 ", i, "条数据, PackageName: ", ge.PackageName, "已经存在,不需要再次插入")
		return ge.PackageName, nil
	}
	git_id, typex, err := models.CreateYaml(&ge)
	if git_id > 0 && err == nil {
		logs.Info("第 ", i, "条数据, PackageName: ", ge.PackageName, typex, "成功, git_id: ", git_id)
	} else {
		logs.Error("第 ", i, "条数据, PackageName: ", ge.PackageName, typex, "失败, err: ", err)
		return "", err
	}
	if typex == "insert" && git_id > 0 {
		subcompUrl := url + "/packages/packageInfo" + "?table_name=" + tableValue.TableName + "&pkg_name=" + ge.PackageName
		body, err:= util.HttpGetCom(subcompUrl)
		var respBody map[string]interface{}
		if err == nil && body != nil {
			err =json.Unmarshal(body, &respBody)
			if err != nil {
				logs.Error(err)
				return "", err
			}
		} else {
			logs.Error( "http 请求失败， subcompUrl: ", subcompUrl)
			return "", err
		}
		logs.Info(respBody)
		if respBody["code"].(string) == "2001"{
			if respBody["data"] == nil || respBody["data"] == "" {
				logs.Error("获取包详情失败, subcompUrl: ", subcompUrl)
				return "", errors.New("数据错误")
			}
			var gp models.GitPackageInfo
			GitOpenEulerInfoData(respBody["data"].(map[string]interface{}), &gp, ge)
			detailid, typex, err := models.CreateYamlDetail(&gp, ge)
			if detailid >0 && typex == "insert" && err == nil {
				subdata := respBody["data"].(map[string]interface{})
				if subdata["subpack"] == nil {
					return "", err
				}
				if subdata == nil || subdata["subpack"] == nil || len(subdata["subpack"].([]interface{})) == 0 {
					return "", errors.New("数据错误")
				}
				subpack := subdata["subpack"].([]interface{})
				for _, packValuex := range subpack {
					logs.Info("yaml packValuex: ", packValuex)
					if packValuex == nil || packValuex == "" || len(packValuex.(map[string]interface{})) == 0 {
						continue
					}
					packValue := packValuex.(map[string]interface{})
					var gb models.GitSubPack
					gb.DetailId = gp.DetailId
					switch packValue["id"].(type) {
					case string:
						gb.Ids, _ = strconv.ParseInt(packValue["id"].(string), 10, 64)
					case int:
						gb.Ids = packValue["id"].(int64)
					case int64:
						gb.Ids = packValue["id"].(int64)
					case float64:
						gb.Ids = int64(packValue["id"].(float64))
					default:
						gb.Ids = 0
					}
					if packValue["name"] == nil {
						gb.SubPackName = ""
					} else {
						gb.SubPackName = packValue["name"].(string)
					}
					SubId, typex, err := models.CreateYamlSubPack(&gb)
					if SubId > 0 && typex == "insert" && err == nil {
						if packValue["provides"] != nil && len(packValue["provides"].([]interface{})) > 0{
							provides := packValue["provides"].([]interface{})
							for _, provValuex := range provides {
								logs.Info("yaml provValuex: ", provValuex)
								if provValuex == nil || provValuex == "" || len(provValuex.(map[string]interface{})) == 0 {
									continue
								}
								provValue := provValuex.(map[string]interface{})
								var gs models.GitSubPackProvides
								gs.SubId = SubId
								switch provValue["id"].(type) {
								case string:
									gs.Ids, _ = strconv.ParseInt(provValue["id"].(string), 10, 64)
								case int:
									gs.Ids = provValue["id"].(int64)
								case int64:
									gs.Ids = provValue["id"].(int64)
								case float64:
									gs.Ids = int64(provValue["id"].(float64))
								default:
									gs.Ids = 0
								}
								if provValue["name"] == nil {
									gs.ProvideName = ""
								} else {
									gs.ProvideName = provValue["name"].(string)
								}

								gs.Requiredby = ""
								ProvideId, typexx, err := models.CreateYamlSubPackProvides(&gs)
								if ProvideId > 0 && typexx == "insert" && err == nil {
									if provValue["requiredby"] != nil && len(provValue["requiredby"].([]interface{})) > 0{
										requiredby := provValue["requiredby"].([]interface{})
										for _, reqValue := range requiredby {
											if reqValue != nil && reqValue.(string) != "" {
												var gr models.GitSubPackRequiredby
												gr.ProvideId = gs.ProvideId
												gr.Requiredby = reqValue.(string)
												Id, typexy, err := models.CreateYamlSubPackRequiredb(&gr)
												logs.Info("CreateYamlSubPackRequiredb", Id, typexy, err)
											}
										}
									}
								}
							}
						}
						if packValue["requires"] != nil && len(packValue["requires"].([]interface{})) > 0{
							requires := packValue["requires"].([]interface{})
							for _, reqValuexx := range requires {
								logs.Info("reqValuexx: ", reqValuexx)
								if reqValuexx == nil || reqValuexx == "" || len(reqValuexx.(map[string]interface{})) == 0 {
									continue
								}
 								reqValuex := reqValuexx.(map[string]interface{})
								reqStr := ""
								if reqValuex["providedby"] != nil && len(reqValuex["providedby"].([]interface{})) > 0{
									providedby := reqValuex["providedby"].([]interface{})
									for _, reqValue := range providedby {
										if reqValue != nil && reqValue.(string) != "" {
											reqStr = reqStr + reqValue.(string) + ","
										}
									}
								}
								if reqStr != "" {
									reqStr = reqStr[:len(reqStr) -1]
								}
								var gs models.GitSubPackRequire
								gs.SubId = SubId
								switch reqValuex["id"].(type) {
								case string:
									gs.Ids, _ = strconv.ParseInt(reqValuex["id"].(string), 10, 64)
								case int:
									gs.Ids = reqValuex["id"].(int64)
								case int64:
									gs.Ids = reqValuex["id"].(int64)
								case float64:
									gs.Ids = int64(reqValuex["id"].(float64))
								default:
									gs.Ids = 0
								}
								if reqValuex["name"] == nil {
									gs.RequireName = ""
								} else {
									gs.RequireName = reqValuex["name"].(string)
								}
								gs.Providedby = reqStr
								RequireId, typexx, err := models.CreateYamlSubPackRequires(&gs)
								logs.Info("CreateYamlSubPackRequires", RequireId, typexx, err)
							}
						}
					}
				}
			}
		}
	}
	return "", nil
}