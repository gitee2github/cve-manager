package taskhandler

import (
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
)

const (
	//GiteOrgInfoURL get gitee org info url
	GiteOrgInfoURL = `https://gitee.com/api/v5/orgs/%v?access_token=%v`
	//GiteOrgReposURL get all repository url
	GiteOrgReposURL = `https://gitee.com/api/v5/orgs/%v/repos?access_token=%v&type=all&page=%v&per_page=%v`
	//GiteRepoIssuesURL get issue list url
	GiteRepoIssuesURL = `https://gitee.com/api/v5/repos/%v/%v/issues?access_token=%v&state=%v&sort=created&direction=desc&page=%v&per_page=%v`
	//GiteRepoBranch get repo branch url
	GiteRepoBranch = `https://gitee.com/api/v5/repos/%v/%v/branches?access_token=%v`
	//RepoInfoURL get repo info url
	RepoInfoURL = "https://api.openeuler.org/pkgmanage/packages/packageInfo?table_name=openEuler_LTS_20.03&pkg_name=%s"
	perPage     = 50
	//IssueType Types of issues crawled
	IssueType = "CVE和安全问题"
)

var wg sync.WaitGroup

//OrgInfo
type OrgInfo struct {
	ID           int32  `json:"id,omitempty"`
	Login        string `json:"login,omitempty"`
	URL          string `json:"url,omitempty"`
	AvatarURL    string `json:"avatar_url,omitempty"`
	ReposURL     string `json:"repos_url,omitempty"`
	EventsURL    string `json:"events_url,omitempty"`
	MembersURL   string `json:"members_url,omitempty"`
	Description  string `json:"description,omitempty"`
	Name         string `json:"name,omitempty"`
	Enterprise   string `json:"enterprise,omitempty"`
	Members      int64  `json:"members,omitempty"`
	PublicRepos  int64  `json:"public_repos,omitempty"`
	PrivateRepos int64  `json:"private_repos,omitempty"`
}

//Branch Get all branches
type Branch struct {
	Name          string `json:"name,omitempty"`
	Protected     bool   `json:"protected,omitempty"`
	ProtectionURL string `json:"protection_url,omitempty"`
}

//PackageInfo package info model
type PackageInfo struct {
	Code string
	Msg  string
	Data Info
}

//Info cve info
type Info struct {
	Description string
}

//GrabIssueByOrg grab issue by org name
func GrabIssueByOrg(accToken, org string) error {
	logs.Info("Synchronize gitee's issue start......")
	orgInfo, err := GetOrgInfo(accToken, org)
	if err != nil {
		logs.Error("GetOrgInfo, org: ", org, ",err: ", err)
		return err
	}
	reposNum := orgInfo.PublicRepos + orgInfo.PrivateRepos
	if reposNum <= 0 {
		logs.Info(fmt.Sprintf("%v cantain %v repository,grab issue finish!", org, reposNum))
		return errors.New(fmt.Sprintf("%v cantain %v repository,grab issue finish!", org, reposNum))
	}
	pageSize := reposNum / int64(perPage)
	if reposNum%int64(perPage) > 0 {
		pageSize = pageSize + 1
	}
	var i int64
	for i = 1; i <= pageSize; i++ {
		go GetOrgRepos(accToken, org, i)
	}
	wg.Wait()
	logs.Info("Synchronize gitee's issue  finish...")
	return nil
}

//GrabIssueByRepo grab issue by repository
func GrabIssueByRepo(accToken, owner, repo, state string) {
	page := 1
	product, err := getInfProduct(accToken, owner, repo)
	if err != nil {
		logs.Error("getInfProduct, err: ", err)
	}
	desc := GetRepoDescription(repo)
	for {
		list, err := GetIssueList(accToken, owner, repo, state, page)
		if err != nil {
			logs.Error("GetIssueList, repo: ", repo, ",err: ", err)
			break
		}
		handleIssueList(list, product, desc)
		if len(list) < perPage {
			break
		}
		page++
	}
}

func getInfProduct(token string, owner string, repo string) (infPro string, err error) {
	resp, err := http.Get(fmt.Sprintf(GiteRepoBranch, owner, repo, token))
	if err != nil {
		logs.Error("url: ", GiteRepoBranch, ",repo:", repo, ",err: ", err)
		return "", err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("ReadAll: ", GiteRepoBranch, ",repo:", repo, ",err: ", err)
		return "", err
	}
	var branchList []Branch
	err = json.Unmarshal(body, &branchList)
	if err != nil {
		logs.Error("Unmarshal: ", GiteRepoBranch, ",repo:", repo, ",err: ", err)
		return "", err
	}
	affectBranchsxList := []string{}
	affectedBranchs := beego.AppConfig.String("cve::affected_branchs")
	if affectedBranchs != "" && len(affectedBranchs) > 0 {
		affectBranchsxList = strings.Split(affectedBranchs, ",")
	}
	tempBrandList := []string{}
	for _, v := range branchList {
		if affectBranchsxList != nil && len(affectBranchsxList) > 0 {
			for _, affectBrand := range affectBranchsxList {
				if strings.HasSuffix(v.Name, affectBrand) {
					tempBrandList = append(tempBrandList, v.Name)
					break
				}
			}
		}
	}
	if tempBrandList != nil && len(tempBrandList) > 0 {
		infPro = strings.Join(tempBrandList, "/")
	}
	return
}

func handleIssueList(list []models.HookIssue, product, desc string) {
	if len(list) == 0 {
		return
	}
	//var gil []models.GiteOriginIssue
	for _, v := range list {
		if v.IssueType == IssueType {
			item := models.GiteOriginIssue{IssueId: v.Id, Url: v.HtmlUrl,
				Number: v.Number, State: v.State, Title: v.Title,
				IssueType: v.IssueType, SecurityHole: v.SecurityHole,
				IssueCreateAt: v.CreateAt, IssueUpdateAt: v.UpdateAt,
				IssueFinishAt: v.FinishedAt, IssueCreate: v.User.Login,
				IssueAssignee: v.Assignee.Login, RepoPath: v.Repository.Path,
				RepoUrl: v.Repository.Url, InfProduct: product, RepoDesc: desc}
			vt := util.TrimString(v.Title)
			if strings.HasPrefix(vt, "CVE") {
				item.CveNumber = vt
			} else if v.Body != "" {
				//通过正则表达式去body中截取 稍后完善
				sm := util.RegexpCveNumber.FindAllStringSubmatch(v.Body, -1)
				if len(sm) > 0 && len(sm[0]) > 0 {
					item.CveNumber = util.TrimString(sm[0][1])
				}
			}
			//vb := util.TrimString(v.Body)
			vb := strings.ReplaceAll(v.Body, "：", ":")
			item.Body = vb
			item.IssueExistTpl = models.IssueExistByNumber(v.Number)
			err := item.InsertOrUpdate()
			if err != nil {
				logs.Error("insert or update issue fail:", err)
			}
		}
	}
}

//GetOrgInfo get  organization information
func GetOrgInfo(accToken, org string) (OrgInfo, error) {
	oi := OrgInfo{}
	resp, err := http.Get(fmt.Sprintf(GiteOrgInfoURL, org, accToken))
	if err != nil {
		return oi, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return oi, err
	}
	err = json.Unmarshal(body, &oi)
	return oi, err
}

//GetOrgRepos get organization repository
func GetOrgRepos(accToken, org string, page int64) {
	wg.Add(1)
	defer wg.Done()
	resp, err := http.Get(fmt.Sprintf(GiteOrgReposURL, org, accToken, page, perPage))
	if err != nil {
		logs.Error("Get, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	defer resp.Body.Close()
	var reps []models.HookRepository
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("ReadAll, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	err = json.Unmarshal(body, &reps)
	if err != nil {
		logs.Error("Unmarshal, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	for _, v := range reps {
		GrabIssueByRepo(accToken, org, v.Name, "all")
	}
}

//GetIssueList get the repository issue list
func GetIssueList(accToken, owner, repo, state string, page int) (issueList []models.HookIssue, err error) {
	resp, err := http.Get(fmt.Sprintf(GiteRepoIssuesURL, owner, repo,accToken, state, page, perPage))
	if err != nil {
		logs.Error("Get, GiteRepoIssuesURL: ", GiteRepoIssuesURL, ", repo: ", repo, ", err: ", err)
		return issueList, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("ReadAll, GiteRepoIssuesURL: ", GiteRepoIssuesURL, ", repo: ", repo, ", err: ", err)
		return issueList, err
	}
	//
	//logs.Error(string(body))
	err = json.Unmarshal(body, &issueList)
	if err != nil {
		logs.Error("Unmarshal, GiteRepoIssuesURL: ", GiteRepoIssuesURL, ", repo: ", repo, ", err: ", err)
	}
	return
}

//GetRepoDescription get repository description
func GetRepoDescription(repo string) (desc string) {
	if repo == "" {
		return ""
	}
	url := fmt.Sprintf(RepoInfoURL, repo)
	resp, err := http.Get(url)
	if err != nil {
		logs.Error("Get, RepoInfoURL: ", RepoInfoURL, ",err: ", err)
		return ""
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("ReadAll, RepoInfoURL: ", RepoInfoURL, ",err: ", err)
		return ""
	}
	var pkg PackageInfo
	err = json.Unmarshal(body, &pkg)
	if err != nil {
		logs.Error("Unmarshal, RepoInfoURL: ", RepoInfoURL, ",err: ", err)
		return ""
	}
	if pkg.Code == "2001" {
		return pkg.Data.Description
	}
	return ""
}
