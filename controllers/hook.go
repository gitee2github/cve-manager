package controllers

import (
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
	"strings"
)

var (
	GiteeUserAgent  = "git-oschina-hook"          //gitee hook request flag
	XGiteeToken     = "X-Gitee-Token"             // password or sign
	XGIteeEventType = "X-Gitee-Event"             //webhook event type
	NoteHookType    = "Note Hook"                 // type of comment
	PullReqHookType = "merge_request_hooks"       // type of pull request
	PushTagHookType = "push_hooks/tag_push_hooks" // type of push or tag
	IssueHookType   = "Issue Hook"                //type of issue
)

const (
	CommentAnalysisCplTpl   = "@%v %v"
	ReviewPrivateLettersTpl = `%s(%s)analysis is over,CVEScore:%v;OpenEulerScore:%v。Please review!`
	ReviewRejectScore       = `@%v you submit issue score audit failed(reject by %v)，Please re-analyze and submit!`
	ReviewApproveScore      = `@%v you submit issue score audit success(approved by %v)，You can proceed to the next step!`
	CommentReviewTpl        = `%v The CVE score needs to be reviewed (the review instruction /approve&/reject means agreement and rejection)。`
	IssueRejectState        = "rejected"
	IssueCloseState         = "closed"
	IssueProgressState      = "progressing"
	IssueOpenState          = "open"
	AnalysisComplete        = "@%v 经过 CVE-Manager 解析， 您分析的内容如下表所示:\n"
)

type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

// @router / [get]
func (c *HookEventControllers) Get() {
	if ok := c.isLegitimateHookEvent(); !ok {
		logs.Info("hah:", "giteeUseAgent")
		return
	}

}

// isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	logs.Info(xToken)
	return
}

func (c *HookEventControllers) handleNoteDate() {
	//logs.Info(string(c.Ctx.Input.RequestBody))
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" {
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {
	logs.Info(string(c.Ctx.Input.RequestBody))
	issueHook := models.IssuePayload{}
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &issueHook)
	if err != nil {
		logs.Error(err)
		return
	}
	if issueHook.Action == "assign" {
		//更新issue 模板负责人
		issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
		}
		issueTmp.Assignee = issueHook.Assignee.Login
		err = models.UpdateIssueTemplate(&issueTmp, "issue_assignee")
		if err != nil {
			logs.Error(err)
		}
	}
	if issueHook.Action == "state_change" {
		//handle issue state change
		err = handleIssueStateChange(&issueHook)
		if err != nil {
			logs.Error(err)
		}
	}

}

func handleIssueStateChange(issueHook *models.IssuePayload) error {
	issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		return err
	}
	cveCenter := models.VulnCenter{CveId: issueTmp.CveId}
	err = models.GetVulnCenterByCid(&cveCenter, "cve_id")
	if err != nil {
		return err
	}
	switch issueHook.State {
	case IssueOpenState:
		issueTmp.Status = 1
		cveCenter.IsExport = 0
	case IssueProgressState:
		issueTmp.Status = 2
		cveCenter.IsExport = 0
	case IssueCloseState:
		issueTmp.Status = 3
		if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
			issueTmp.IssueStatus = 2
			cveCenter.IsExport = 3
		} else {
			issueTmp.IssueStatus = 6
			cveCenter.IsExport = 2
		}
	case IssueRejectState:
		issueTmp.Status = 4
		issueTmp.IssueStatus = 6
		cveCenter.IsExport = 2
		/*if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
			issueTmp.IssueStatus = 2
		} else {
			issueTmp.IssueStatus = 6
		}*/
	}
	issueTmp.StatusName = issueHook.Issue.StateName
	err = models.UpdateIssueTemplate(&issueTmp, "status", "issue_status", "status_name")
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if err != nil {
		return err
	}
	if update != true {
		return errors.New("update vulnCenter fail ")
	}
	return nil
}

func isNormalCloseIssue(cveId int64, issueState int8) bool {
	if issueState == 1 {
		return false
	}
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		logs.Error(err)
		return false
	}
	if score.Ostatus != 3 {
		return false
	}
	return true
}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	issueNum := payload.Issue.Number           //issue 编号
	cBody := payload.Comment.Body              //评论主体
	cuAccount := payload.Comment.User.UserName //gitee 域地址
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		return
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//审核拒绝 添加评论 @分析人
		if !isReviewer(cuAccount) {
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 2)
		if err != nil {
			logs.Error(err)
		}
		accessToken := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		//path := beego.AppConfig.String("gitee::path")
		path := issueTmp.Repo
		taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewRejectScore, issueTmp.Assignee, cuAccount), issueTmp.IssueNum, owner, path, accessToken)
	} else if strings.HasPrefix(cBody, cmdApe) {
		//审核通过 修改评分状态
		if !isReviewer(cuAccount) {
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 3)
		if err != nil {
			logs.Error(err)
		} else {
			accessToken := os.Getenv("GITEE_TOKEN")
			owner := beego.AppConfig.String("gitee::owner")
			//path := beego.AppConfig.String("gitee::path")
			path := issueTmp.Repo
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewApproveScore, issueTmp.Assignee, cuAccount), issueTmp.IssueNum, owner, path, accessToken)
		}

	} else {
		cBody = strings.ReplaceAll(cBody, "：", ":")
		analysisComment(issueNum, cuAccount, cBody, &payload)
	}

}

func isReviewer(path string) bool {
	sr := models.SecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func analysisComment(issueNum string, cuAccount string, cBody string, payload *models.CommentPayload) {
	//cmdAys := beego.AppConfig.DefaultString("analysisCmd", "//不需要分析指令
	//cmdEnd := beego.AppConfig.DefaultString("endCmd", "/done") //不需要结束指令
	issueTmp := models.IssueTemplate{IssueNum: issueNum}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		logs.Error(err)
		return
	}
	canVerfy := false
	//if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdAys) {
	if cuAccount == issueTmp.Assignee {
		//is Analyst comment and content start with '/analysis'
		vMap := util.ExtractCommentAnalysisAllValue(cBody)
		if len(vMap) > 0 {
			canVerfy = true
			cols := make([]string, 0)
			for k, v := range vMap {
				switch k {
				case "cve_analysis":
					issueTmp.CveAnalysis = v
					cols = append(cols, k)
				case "principle_analysis":
					issueTmp.PrincipleAnalysis = v
					cols = append(cols, k)
				case "openeuler_score":
					fv, err := strconv.ParseFloat(v, 64)
					if err == nil {
						issueTmp.OpenEulerScore = fv
						cols = append(cols, k)
					}
				case "openeuler_vector":
					issueTmp.OpenEulerVector = v
					cols = append(cols, k)
				case "affected_version":
					issueTmp.AffectedVersion = v
					cols = append(cols, k)
				case "solution":
					issueTmp.Solution = v
					cols = append(cols, k)
				}
			}
			if len(cols) > 0 {
				err := models.UpdateIssueTemplate(&issueTmp, cols...)
				if err != nil {
					logs.Error(err)
				} else {
					if _, ok := vMap["openeuler_vector"]; ok {
						err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						}
					}
					if _, ok := vMap["openeuler_score"]; ok {
						//更新分数到 score
						score, err := models.QueryIssueScore(issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						} else {
							score.OpenEulerScore = issueTmp.OpenEulerScore
							score.Ostatus = 1
							err := models.UpdateScore(&score, "openeuler_score", "o_score_status")
							if err != nil {
								logs.Error(err)
							}
						}
					}
				}
			}
			if _, ok := vMap["issue_package"]; ok {
				// handle comment package
				err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
				if err != nil {
					logs.Error(err)
				}
			}
			// update gitee issue
			commentUpdateIssue(issueTmp)
		}

	}
	//if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdEnd) {
	if cuAccount == issueTmp.Assignee && canVerfy {
		//Check whether the data is legal
		accessToken := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		//path := beego.AppConfig.String("gitee::path")
		path := issueTmp.Repo
		if msg, tb, ok := checkIssueAnalysisComplete(&issueTmp); !ok {
			//send comment to issue
			issueTmp.IssueStatus = 1
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			msg = fmt.Sprintf(CommentAnalysisCplTpl, issueTmp.Assignee, msg)
			taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)
		} else {
			//1. change issue status
			issueTmp.IssueStatus = 3
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			//2. Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
			var na string
			if issueTmp.OpenEulerScore != issueTmp.NVDScore {
				na = "\n**因OpenEulerScore与NvdScore不一致，分析内容需审核，请等待审核！**"
				//Notify the responsible person for review
				notifyAuditorReview(payload, issueTmp)
			} else {
				na = "\n**请确认分析内容的准确性，确认无误后，您可以进行后续步骤，否则您可以继续分析。**"
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			}
			cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
		}
	}
}

func notifyAuditorReview(payload *models.CommentPayload, issueTmp models.IssueTemplate) {
	//Notify the responsible person for review
	list, err := models.GetSecurityReviewerList()
	if err != nil {
		logs.Error(err)
		return
	}
	if len(list) == 0 {
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	content := fmt.Sprintf(ReviewPrivateLettersTpl,
		payload.Issue.Title, payload.Issue.HtmlUrl, issueTmp.NVDScore, issueTmp.OpenEulerScore)
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	ns := make([]string, len(list))
	for k, v := range list {
		ns[k] = "@" + v.NameSpace+" "
		taskhandler.SendPrivateLetters(accessToken, content, v.NameSpace)
		//add @comment
	}
	msg := fmt.Sprintf(CommentReviewTpl, strings.Join(ns, ","))
	taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)

}

func changeOpenEulerScoreStatus(cveId int64, status int8) error {
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		return err
	}
	score.Ostatus = status
	err = models.UpdateScore(&score, "o_score_status")
	return err
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析             | 内容      |
|-----|-----------------|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`

	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if i.OpenEulerScore == 0.0 {
		msg = fmt.Sprintf("openEulerScore没有填写:%v", i.OpenEulerScore)
		ok = false
		return
	} else {
		tbContent[0] = "已分析"
		tbContent[1] = "openEulerScore"
		tbContent[2] = i.OpenEulerScore
	}
	if i.CveAnalysis == "" {
		msg = fmt.Sprintf("影响性分析说明没有填写:%v", i.CveAnalysis)
		ok = false
		return
	} else {
		tbContent[3] = "已分析"
		tbContent[4] = "影响性分析说明"
		tbContent[5] = util.TrimStringNR(i.CveAnalysis)
	}
	//新模板没有该值
	/*if i.PrincipleAnalysis == "" {
		msg = fmt.Sprintf("原理分析:%v",i.PrincipleAnalysis)
		ok = false
		return
	}*/
	if i.OpenEulerVector == "" {
		msg = fmt.Sprintf("OpenEulerVector没有填写:%v", i.OpenEulerVector)
		ok = false
		return
	} else {
		tbContent[6] = "已分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	}
	if i.AffectedVersion != "" {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = util.TrimStringNR(i.AffectedVersion)
	} else {
		tbContent[9] = "待分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	//非必填字段
	/*if i.AffectedVersion == "" {
		msg = fmt.Sprintf("受影响的包:%v",i.OpenEulerVector)
		ok = false
		return
	}*/
	//新模板没有该值
	/*if i.Solution == ""{
		msg = fmt.Sprintf("规避方案或消减措施:%v",i.OpenEulerVector)
		ok = false
		return
	}
	pkg, err := models.QueryPackageByCveId(i.CveId)
	if err != nil {
		return "受影响的包：",false
	}
	if len(pkg) == 0 {
		return "受影响的包",false
	}*/
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveId int64) error {
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	if util.RegexpVectorV2.Match([]byte(vct)) {
		//update v2 vector
		avv := util.ReadVmValueV2(vMap["AV"])
		if avv != "" {
			score.OaccessVector = avv
			upFields = append(upFields, "o_access_vector")
		}
		acv := util.ReadVmValueV2(vMap["AC"])
		if acv != "" {
			score.OaccessComplexity = acv
			upFields = append(upFields, "o_access_complexity")
		}
		au := util.ReadVmValueV2(vMap["Au"])
		if au != "" {
			score.Oauthentication = au
			upFields = append(upFields, "o_authentication")
		}
		cv := util.ReadVmValueV2(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVmValueV2(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVmValueV2(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	} else {
		//update v3 vector
		avv := util.ReadVmValue(vMap["AV"])
		if avv != "" {
			score.OattackVector = avv
			upFields = append(upFields, "o_attack_vector")
		}
		acv := util.ReadVmValue(vMap["AC"])
		if acv != "" {
			score.OattackComplexity = acv
			upFields = append(upFields, "o_attack_complexity")
		}
		prv := util.ReadVmValue(vMap["PR"])
		if prv != "" {
			score.OprivilegeRequired = prv
			upFields = append(upFields, "o_privilege_required")
		}
		uiv := util.ReadVmValue(vMap["UI"])
		if uiv != "" {
			score.OuserInteraction = uiv
			upFields = append(upFields, "o_user_interaction")
		}
		sv := util.ReadVmValue(vMap["S"])
		if sv != "" {
			score.Oscope = sv
			upFields = append(upFields, "o_scope")
		}
		cv := util.ReadVmValue(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVmValue(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVmValue(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	}
	if len(upFields) > 0 {
		//执行更新
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveId int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveId)
	if err != nil {
		return err
	}
	return nil
}
