package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"fmt"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"reflect"
	"strconv"
	"strings"
)

type GiteeToken struct {
	GrantType    string
	UserName     string
	Password     string
	ClientID     string
	ClientSecret string
	Scope        string
}

const bodyTpl = `一、漏洞信息
 漏洞编号：%v
 漏洞归属组件：%v
 漏洞归属的版本：%v
 CVSS V%v分值：
  BaseScore：%v
  Vector：CVSS：%v
 漏洞简述：
  %v
 漏洞公开时间：%v
 漏洞信息修改时间：%v
 漏洞详情参考链接：
  %v
 漏洞分析指导链接：
  %v
二、漏洞分析结构反馈
 影响性分析说明：
  %v
 openEuler评分：
  %v
 受影响版本排查(受影响/不受影响)：
  %v
`

const bodyUpTpl = `一、漏洞信息
 漏洞编号：%v
 漏洞归属组件：%v
 漏洞归属的版本：%v
 CVSS V%v分值：
  BaseScore：%v
  Vector：CVSS：%v
 漏洞简述：
  %v
 漏洞公开时间：%v
 漏洞信息修改时间：%v
 漏洞详情参考链接：
  %v
 漏洞分析指导链接：
  %v
二、漏洞分析结构反馈
 影响性分析说明：
  %v
 openEuler评分：
  %v
 Vector：CVSS：%v
 受影响版本排查(受影响/不受影响)：
  %v
`

func CommentTemplate(assignee, commentCmd, affectedVersion string) string {
	commentTemplate := "Hey @" + assignee + "\n" +
		"以下内容需要您填写, 请复制到评论区回复喔" + "\n" +
		"影响性分析说明: \n\n" + "openEuler评分: (评分和向量)\n\n" +
		"受影响版本排查(受影响/不受影响): \n" + affectedVersion +
		"\n也可以参考: " + commentCmd + "\n"
	return commentTemplate
}

func GitOpenEulerData(values map[string]interface{}, ge *models.GitOpenEuler, tb models.GitPackageTable) {
	defer common.Catchs()
	ge.TableName = tb.TableName
	ge.TableId = tb.TableId
	ge.Status = 0
	if values["feature"] == nil {
		ge.Feature = ""
	} else {
		switch values["feature"].(type) {
		case string:
			ge.Feature = values["feature"].(string)
		case int:
			ge.Feature = strconv.Itoa(values["feature"].(int))
		case int64:
			ge.Feature = strconv.FormatInt(values["feature"].(int64), 10)
		case float64:
			ge.Feature = strconv.FormatInt(int64(values["feature"].(float64)), 10)
		default:
			ge.Feature = ""
		}
	}
	if values["url"] == nil {
		ge.OriginUrl = ""
	} else {
		ge.OriginUrl = values["url"].(string)
	}
	switch values["id"].(type) {
	case string:
		ge.PackageId, _ = strconv.ParseInt(values["id"].(string), 10, 64)
	case int:
		ge.PackageId = values["id"].(int64)
	case int64:
		ge.PackageId = values["id"].(int64)
	case float64:
		ge.PackageId = int64(values["id"].(float64))
	default:
		ge.PackageId = 0
	}
	if values["name"] == nil {
		ge.PackageName = ""
	} else {
		packName := values["name"].(string)
		if packName != "" {
			packName = common.DeletePreAndSufSpace(packName)
		}
		ge.PackageName = packName
	}
	if values["version"] == nil {
		ge.Version = ""
	} else {
		version := values["version"].(string)
		if version != "" {
			version = common.DeletePreAndSufSpace(version)
		}
		ge.Version = version
	}
	if values["release"] == nil {
		ge.Release = ""
	} else {
		release := values["release"].(string)
		if release != "" {
			release = common.DeletePreAndSufSpace(release)
		}
		ge.Release = release
	}
	if values["rpm_license"] == nil {
		ge.License = ""
	} else {
		ge.License = values["rpm_license"].(string)
	}
	if values["maintainer"] == nil {
		ge.MainTainer = ""
	} else {
		ge.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		ge.MainTainLevel = 0
	} else {
		ge.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["release_time"] == nil {
		ge.ReleaseTime = ""
	} else {
		ge.ReleaseTime = values["release_time"].(string)
	}
	switch values["used_time"].(type) {
	case string:
		ge.UsedTime = values["used_time"].(string)
	case int:
		ge.UsedTime = strconv.Itoa(values["used_time"].(int))
	case int64:
		ge.UsedTime = strconv.FormatInt(values["used_time"].(int64), 10)
	case float64:
		ge.UsedTime = strconv.FormatInt(int64(values["used_time"].(float64)), 10)
	default:
		ge.UsedTime = ""
	}
	if values["latest_version"] == nil {
		ge.LatestVersion = ""
	} else {
		ge.LatestVersion = values["latest_version"].(string)
	}
	if values["latest_version_time"] == nil {
		ge.LatestVersionTime = ""
	} else {
		ge.LatestVersionTime = values["latest_version_time"].(string)
	}
	switch values["issue"].(type) {
	case string:
		ge.IssueCount, _ = strconv.ParseInt(values["issue"].(string), 10, 64)
	case int:
		ge.IssueCount = values["issue"].(int64)
	case int64:
		ge.IssueCount = values["issue"].(int64)
	case float64:
		ge.IssueCount = int64(values["issue"].(float64))
	default:
		ge.IssueCount = 0
	}
}

func GitOpenEulerInfoData(values map[string]interface{}, gp *models.GitPackageInfo, ge models.GitOpenEuler) {
	defer common.Catchs()
	gp.GitId = ge.GitId
	gp.Ids = 0
	if values["pkg_name"] == nil {
		gp.PackageName = ""
	} else {
		PackageName := values["pkg_name"].(string)
		if PackageName != "" {
			PackageName = common.DeletePreAndSufSpace(PackageName)
		}
		gp.PackageName = PackageName
	}
	if values["version"] == nil {
		gp.Version = ""
	} else {
		Version := values["version"].(string)
		if Version != "" {
			Version = common.DeletePreAndSufSpace(Version)
		}
		gp.Version = Version
	}
	if values["release"] == nil {
		gp.Release = ""
	} else {
		Release := values["release"].(string)
		if Release != "" {
			Release = common.DeletePreAndSufSpace(Release)
		}
		gp.Release = Release
	}
	if values["url"] == nil {
		gp.OriginUrl = ""
	} else {
		gp.OriginUrl = values["url"].(string)
	}
	if values["license"] == nil {
		gp.License = ""
	} else {
		gp.License = values["license"].(string)
	}
	switch values["feature"].(type) {
	case string:
		gp.Feature = values["feature"].(string)
	case int:
		gp.Feature = strconv.Itoa(values["feature"].(int))
	case int64:
		gp.Feature = strconv.FormatInt(values["feature"].(int64), 10)
	case float64:
		gp.Feature = strconv.FormatInt(int64(values["feature"].(float64)), 10)
	default:
		gp.Feature = ""
	}
	if values["maintainer"] == nil {
		gp.MainTainer = ""
	} else {
		gp.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		gp.MainTainLevel = 0
	} else {
		gp.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["gitee_url"] == nil {
		gp.GitUrl = ""
	} else {
		gp.GitUrl = values["gitee_url"].(string)
	}
	if values["summary"] == nil {
		gp.Summary = ""
	} else {
		gp.Summary = values["summary"].(string)
	}
	if values["description"] == nil {
		gp.Decription = ""
	} else {
		gp.Decription = values["description"].(string)
	}
	BuildRequired := ""
	if values["buildrequired"].([]interface{}) != nil && len(values["buildrequired"].([]interface{})) > 0 {
		for _, vx := range values["buildrequired"].([]interface{}) {
			BuildRequired = BuildRequired + vx.(string) + ","
		}
		gp.BuildRequired = BuildRequired[:len(BuildRequired)-1]
	} else {
		gp.BuildRequired = BuildRequired
	}
	gp.Status = 0
}

type GitTablePackCount struct {
	Page      int
	Size      int
	TableName string
	Count     int64
}

func CreateIssueBody(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score, openEulerScore, score, labels string,
	its models.IssueTemplate, flag int, issueType, pkgLink string, brandArray []string) string {
	requestBody := ""
	scoreType := ""
	affectedVersion := ""
	if sc.ScoreType == "v2" {
		scoreType = "2.0"
	} else {
		scoreType = "3.0"
	}
	cve.Description = strings.ReplaceAll(cve.Description, "\"", "")
	cve.Description = strings.ReplaceAll(cve.Description, "'", "")
	cve.Description = strings.ReplaceAll(cve.Description, "\\", "")
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return ""
	}
	commentCmd := BConfig.String("reflink::comment_cmd")
	floatOpenEulerScore, err := strconv.ParseFloat(openEulerScore, 64)
	if err != nil {
		floatOpenEulerScore = 0.0
	}
	cveAnalysis := ""
	if its.CveAnalysis != "" && len(its.CveAnalysis) > 1 {
		cveAnalysis = strings.Replace(its.CveAnalysis, "\n", "", -1)
	}
	updateTime := cve.UpdateTime.String()
	if updateTime != "" && len(updateTime) > 19 {
		updateTime = updateTime[:19]
	}
	StatusName := ""
	if its.StatusName != "" && len(its.StatusName) > 1 {
		if its.StatusName == "待办的" {
			StatusName = "open"
		} else if its.StatusName == "进行中" || strings.ToLower(its.StatusName) == "started" {
			StatusName = "progressing"
		} else if its.StatusName == "已完成" || its.StatusName == "已拒绝"{
			StatusName = "closed"
		} else {
			StatusName = its.StatusName
		}
	}
	if flag == 1 {
		if len(brandArray) > 0 {
			for i, brand := range brandArray {
				if brand == "" || len(brand) < 2 {
					continue
				}
				affectedVersion = affectedVersion + strconv.Itoa(i+1) + "." + brand + ":\n"
			}
		} else {
			affectedVersion = "\n"
		}
		if floatOpenEulerScore > 0.0 || (its.OpenEulerVector != "" && len(its.OpenEulerVector) > 1) {
			cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
			nveScore := score + " " + cve.CveLevel
			nveVector := scoreType + "/" + sc.NvectorVule
			oVector := scoreType + "/" + its.OpenEulerVector
			body := fmt.Sprintf(bodyUpTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
				cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
				cveAnalysis, openEulerScore, oVector, affectedVersion)
			requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, assignee, labels)
		} else {
			cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
			nveScore := score + " " + cve.CveLevel
			nveVector := scoreType + "/" + sc.NvectorVule
			openEulerScore = " "
			body := fmt.Sprintf(bodyTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
				cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
				cveAnalysis, openEulerScore, affectedVersion)
			requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, assignee, labels)
		}

	} else if flag == 2 {
		if len(brandArray) > 0 {
			for i, brand := range brandArray {
				if brand == "" || len(brand) < 2 {
					continue
				}
				affectedVersion = affectedVersion + strconv.Itoa(i+1) + "." + brand + ":\n"
			}
		} else {
			affectedVersion = "\n"
		}
		cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
		nveScore := score + " " + cve.CveLevel
		nveVector := scoreType + "/" + sc.NvectorVule
		openEulerScore = " "
		body := fmt.Sprintf(bodyTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
			cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
			cveAnalysis, openEulerScore, affectedVersion)
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"issue_type": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, issueType, body, assignee, labels)
	} else {
		if its.AffectedVersion != "" && len(its.AffectedVersion) > 0 {
			brandsGroup := strings.Split(its.AffectedVersion, ",")
			if len(brandsGroup) > 0 {
				for i, brand := range brandsGroup {
					if brand == "" || len(brand) < 2 {
						continue
					}
					affectedVersion = affectedVersion + strconv.Itoa(i+1) + "." + brand + "\n"
				}
			}
		} else {
			affectedVersion = "\n"
		}
		if floatOpenEulerScore > 0.0 || (its.OpenEulerVector != "" && len(its.OpenEulerVector) > 1) {
			if len(cveAnalysis) > 1 {
				cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
				nveScore := score + " " + cve.CveLevel
				nveVector := scoreType + "/" + its.NVDVector
				oVector := scoreType + "/" + its.OpenEulerVector
				body := fmt.Sprintf(bodyUpTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
					cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
					cveAnalysis, openEulerScore, oVector, affectedVersion)
				requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, its.Assignee, labels)
			} else {
				cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
				nveScore := score + " " + cve.CveLevel

				nveVector := scoreType + "/" + its.NVDVector
				oVector := scoreType + "/" + its.OpenEulerVector
				body := fmt.Sprintf(bodyUpTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
					cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
					cveAnalysis, openEulerScore, oVector, affectedVersion)
				requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, its.Assignee, labels)
			}
		} else {
			openEulerScore = " "
			if len(cveAnalysis) > 1 {
				cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
				nveScore := score + " " + cve.CveLevel
				nveVector := scoreType + "/" + sc.NvectorVule
				body := fmt.Sprintf(bodyTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
					cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
					cveAnalysis, openEulerScore, affectedVersion)
				requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, its.Assignee, labels)
			} else {
				cveNumber := "[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")"
				nveScore := score + " " + cve.CveLevel

				nveVector := scoreType + "/" + sc.NvectorVule
				body := fmt.Sprintf(bodyTpl, cveNumber, path, cve.CveVersion, scoreType, nveScore, nveVector,
					cve.Description, cve.RepairTime, updateTime, cve.CveDetailUrl, commentCmd,
					cveAnalysis, openEulerScore, affectedVersion)
				requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, StatusName, body, its.Assignee, labels)
			}
		}
	}
	return requestBody
}

func Duplicate(a interface{}) (ret []interface{}) {
	va := reflect.ValueOf(a)
	for i := 0; i < va.Len(); i++ {
		if i > 0 && reflect.DeepEqual(va.Index(i-1).Interface(), va.Index(i).Interface()) {
			continue
		}
		ret = append(ret, va.Index(i).Interface())
	}
	return ret
}

func RemoveSubstring(s string, subList []string) string {
	newStr := s
	if len(subList) > 0 {
		for _, sub := range subList {
			if strings.Contains(newStr, sub) {
				newStr = strings.ReplaceAll(newStr, sub, "")
			}
		}
	}
	logs.Info("s: ",s, ",newstr: ", newStr)
	return newStr
}
