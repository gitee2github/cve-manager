package controllers

import (
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
	"strings"
)

var (
	GiteeUserAgent  = "git-oschina-hook"          //gitee hook request flag
	XGiteeToken     = "X-Gitee-Token"             // password or sign
	XGIteeEventType = "X-Gitee-Event"             //webhook event type
	NoteHookType    = "Note Hook"                 // type of comment
	PullReqHookType = "merge_request_hooks"       // type of pull request
	PushTagHookType = "push_hooks/tag_push_hooks" // type of push or tag
	IssueHookType   = "issue_hooks"               //type of issue
)

type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

// @router / [get]
func (c *HookEventControllers) Get() {
	if ok := c.isLegitimateHookEvent(); !ok {
		logs.Info("hah:", "giteeUseAgent")
		return
	}

}

// isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	logs.Info(xToken)
	return
}

func (c *HookEventControllers) handleNoteDate() {
	//logs.Info(string(c.Ctx.Input.RequestBody))
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" {
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {

}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	issueNum := payload.Issue.Number           //issue 编号
	cBody := payload.Comment.Body              //评论主体
	cuAccount := payload.Comment.User.UserName //gitee 域地址
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		return
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//审核拒绝
	} else if strings.HasPrefix(cBody, cmdApe) {
		//审核通过
	} else {
		analysisComment(issueNum, cuAccount, cBody,&payload)
	}

}

func analysisComment(issueNum string, cuAccount string, cBody string,payload *models.CommentPayload) {
	cmdAys := beego.AppConfig.DefaultString("analysisCmd", "/analysis")
	cmdEnd := beego.AppConfig.DefaultString("endCmd", "/done")
	issueTmp := models.IssueTemplate{IssueNum: issueNum}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		logs.Error(err)
		return
	}
	if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdAys) {
		//is Analyst comment and content start with '/analysis'
		vMap := util.ParseCommentWithAllLabel(cBody)
		if len(vMap) > 0 {
			cols := make([]string, 0)
			for k, v := range vMap {
				switch k {
				case "cve_analysis":
					issueTmp.CveAnalysis = v
					cols = append(cols, k)
				case "principle_analysis":
					issueTmp.PrincipleAnalysis = v
					cols = append(cols, k)
				case "openeuler_score":
					fv, err := strconv.ParseFloat(v, 64)
					if err == nil {
						issueTmp.OpenEulerScore = fv
						cols = append(cols, k)
					}
				case "openeuler_vector":
					issueTmp.OpenEulerVector = v
					cols = append(cols, k)
				case "affected_version":
					issueTmp.AffectedVersion = v
					cols = append(cols, k)
				case "solution":
					issueTmp.Solution = v
					cols = append(cols, k)
				}
			}
			if len(cols) > 0 {
				err := models.UpdateIssueTemplate(&issueTmp, cols...)
				if err != nil {
					logs.Error(err)
				} else {
					if _, ok := vMap["openeuler_vector"]; ok {
						err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						}
					}
					if _, ok := vMap["openeuler_score"]; ok {
						//更新分数到 score
						score, err := models.QueryIssueScore(issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						} else {
							score.OpenEulerScore = issueTmp.OpenEulerScore
							err := models.UpdateScore(&score, "openeuler_score")
							if err != nil {
								logs.Error(err)
							}
						}
					}
				}
			}
			if _, ok := vMap["issue_package"]; ok {
				// handle comment package
				err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
				if err != nil {
					logs.Error(err)
				}
			}
		}
		// update gitee issue
		commentUpdateIssue(issueTmp)
	}
	if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdEnd) {
		//Check whether the data is legal
        if msg,ok :=checkIssueAnalysisComplete(&issueTmp);!ok{
        	//send comment to issue
        	msg = fmt.Sprintf(`@%v  %v`,issueTmp.Assignee,msg)
			accessToken := os.Getenv("issueaccesstoken")
			owner := beego.AppConfig.String("gitee::owner")
			path := beego.AppConfig.String("gitee::path")
			taskhandler.AddCommentToIssue(msg,issueTmp.IssueNum,owner,path,accessToken)
		}else {
			//Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
            if issueTmp.OpenEulerScore != issueTmp.NVDScore {
            	//Notify the responsible person for review
				accessToken := os.Getenv("issueaccesstoken")
            	content := fmt.Sprintf(`%s已分析完结,CVEScore:%v,OpenEulerScore:%v。请审核[地址](%s)`,
            		payload.Issue.Title,issueTmp.NVDScore,issueTmp.OpenEulerScore,payload.Issue.HtmlUrl)
            	taskhandler.SendPrivateLetters(accessToken,content,"zhangjianjun_code")
			}
		}
	}
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg string,ok bool) {
	if i == nil {
		logs.Error("issue template is nil")
		return msg,false
	}
	ok = true
	if i.OpenEulerScore == 0.0 {
		msg = fmt.Sprintf("openEulerScore:%v",i.OpenEulerScore)
		ok = false
		return
	}
	if i.CveAnalysis == "" {
		msg = fmt.Sprintf("影响性分析说明:%v",i.CveAnalysis)
		ok = false
		return
	}
	if i.PrincipleAnalysis == "" {
		msg = fmt.Sprintf("原理分析:%v",i.PrincipleAnalysis)
		ok = false
		return
	}
	if i.OpenEulerVector == "" {
		msg = fmt.Sprintf("OpenEulerVector:%v",i.OpenEulerVector)
		ok = false
		return
	}
	if i.AffectedVersion == "" {
		msg = fmt.Sprintf("受影响的包:%v",i.OpenEulerVector)
		ok = false
		return
	}
	if i.Solution == ""{
		msg = fmt.Sprintf("规避方案或消减措施:%v",i.OpenEulerVector)
		ok = false
		return
	}
	pkg, err := models.QueryPackageByCveId(i.CveId)
	if err != nil {
		return "受影响的包：",false
	}
	if len(pkg) == 0 {
		return "受影响的包",false
	}
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate) {
	accessToken := os.Getenv("issueaccesstoken")
	owner := beego.AppConfig.String("gitee::owner")
	path := beego.AppConfig.String("gitee::path")
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveId int64) error {
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	avv := util.ReadVmValue(vMap["AV"])
	if avv != "" {
		score.OattackVector = avv
		upFields = append(upFields, "o_attack_vector")
	}
	acv := util.ReadVmValue(vMap["AC"])
	if acv != "" {
		score.OattackComplexity = acv
		upFields = append(upFields, "o_attack_complexity")
	}
	prv := util.ReadVmValue(vMap["PR"])
	if prv != "" {
		score.OprivilegeRequired = prv
		upFields = append(upFields, "o_privilege_required")
	}
	uiv := util.ReadVmValue(vMap["UI"])
	if uiv != "" {
		score.OuserInteraction = uiv
		upFields = append(upFields, "o_user_interaction")
	}
	sv := util.ReadVmValue(vMap["S"])
	if sv != "" {
		score.Oscope = sv
		upFields = append(upFields, "o_scope")
	}
	cv := util.ReadVmValue(vMap["C"])
	if cv != "" {
		score.Oconfidentiality = cv
		upFields = append(upFields, "o_confidentiality")
	}
	iv := util.ReadVmValue(vMap["I"])
	if iv != "" {
		score.Ointegrity = iv
		upFields = append(upFields, "o_integrity")
	}
	av := util.ReadVmValue(vMap["A"])
	if av != "" {
		score.Oavailability = av
		upFields = append(upFields, "o_availability")
	}
	if len(upFields) > 0 {
		//执行更新
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveId int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveId)
	if err != nil {
		return err
	}
	return nil
}
