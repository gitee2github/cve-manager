#!/usr/bin/python3
import os
import re
import hashlib
import shutil
import ast
import pprint
from .logger import logger
from .settings import DEFAULT_SAVE_PATH, RECORD_FILE

URL_REGEX = re.compile(
    r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+"
)


class FileHandle:
    """
    File handle
    """

    def __init__(
        self, folder, branch=None, cve=None, pkg=None, csv_file=None, read_csv=None
    ) -> None:
        if read_csv and not callable(read_csv):
            raise ValueError(
                "The read_csv parameter is a function that can be called to read CSV files"
            )
        self.read_csv = read_csv or self._read_csv
        self.folder = folder
        self.cve = cve
        self.pkg = pkg
        self.cve_file = csv_file
        self.branches = branch
        self._apply = "All branch apply failed"

    def _read_csv(self, **kwargs):
        raise NotImplementedError

    @staticmethod
    def copy(source_path, target_path):
        """
        Copy the files in the directory to each version folder
        Args:
            source_path: source path
            target_path: target path
        Returns:
            folder: folder path

        """
        os.makedirs(target_path, exist_ok=True)
        files_num = sum([os.path.isfile(listx) for listx in os.listdir(target_path)])
        files = os.listdir(source_path)
        for index, file in enumerate(files, start=1):
            try:
                mv_file_name = file.split("_")[0] + "_{num}.patch".format(
                    num=files_num + index
                )
                shutil.copyfile(
                    os.path.join(source_path, file),
                    os.path.join(target_path, mv_file_name),
                )
            except shutil.Error:
                logger.warning(
                    "The file '%s' of the same name exists in the folder : %s"
                    % (file, os.path.join(target_path, mv_file_name))
                )

    def _parse_text(self, path):
        """
        parse text content
        Args:
            root: root
            cve_folder: cve_folder

        Returns:
            repair_content: repair_content
        """
        with open(path, "r", encoding="utf-8") as file:
            suspected_spatch = []
            not_found_patch = []
            download_failed = []
            finds = []
            find_path = {}
            for line in file.readlines():
                if "cve information" in line.lower():
                    cve_info = line.replace("CVE Information : ", "")
                    cve_dict = ast.literal_eval(cve_info)
                if "Uncertain" in line:
                    suspected_spatch.append(line.split("：")[1].split("\n")[0])
                if "no patch information" in line:
                    not_found_patch.append(line.split(" result:")[0])
                if "File download failed" in line:
                    download_failed.append(line.split("failed:")[1].split("\n")[0])
                if "find patch information" in line:
                    find = line.split("：")[1].split("\n")[0]
                    if find not in finds:
                        finds.append(find)
                    find_path[line.split("in ")[1].split("：")[0]] = finds
            repair_content = {
                "pkg_name": cve_dict.get("pkg"),
                "cve": cve_dict.get("cve"),
                "versions": cve_dict.get("versions"),
                "Not found patch": ["Platform", list(set(not_found_patch))],
                "Seen patch files": ["Platform Patchs", find_path],
                "Download failed": ["Download Patchs URl", list(set(download_failed))],
                "Suspected Patchs URL": [
                    "Suspected Patchs URL",
                    list(set(suspected_spatch)),
                ],
            }
            return repair_content

    def _write_text_body(self, heard, patch_content, file):
        """
        write_text_body
        Args:
            heard: heard
            patch_content: patch_content
            file: file
        """
        file.write("=" * 20 + heard + "=" * 20 + "\n")
        if not patch_content[1]:
            file.write("There is no information" + "\n\n")
            return
        if isinstance(patch_content[1], dict):
            for platform, patchs in patch_content[1].items():
                seen_patch = patch_content[0].split(" ")
                for patch in patchs:
                    file.write(
                        seen_patch[0]
                        + " "
                        + platform
                        + " "
                        + seen_patch[1]
                        + ": "
                        + patch
                        + "\n\n"
                    )
        else:
            for val in patch_content[1]:
                file.write(patch_content[0] + ": " + val + "\n\n")

    def _wirte_text_format(self, repair_content, path, apply_result, pkg):
        """
        wirte text format
        Args:
            repair_content: repair_content
            root: root
            cve_folder: cve_folder
        """

        pkg_name = repair_content.get("pkg_name")
        cve = repair_content.get("cve")
        versions = repair_content.get("versions")

        with open(path, "w", encoding="utf-8") as file:
            file.write(
                f"package name: {pkg_name}\n\nCVE number: {cve}\n\nversions: {pprint.pformat(versions)}\n\n"
            )
            for heard, patch_content in repair_content.items():
                if heard not in ["pkg_name", "cve", "versions"]:
                    self._write_text_body(heard, patch_content, file)

            # apply results of patch
            if apply_result:
                for apply_info in self._write_apply_result(pkg, apply_result):
                    file.write(apply_info)

    def _write_apply_result(self, pkg_name, apply_result):

        add_content = list("=" * 20 + "Apply Result" + "=" * 20 + "\n")
        if apply_result == self._apply:
            add_content.append(apply_result)
        else:
            for branch in self.branches:
                for result in apply_result.split("\n"):
                    if re.match(
                        f"^\[INFO\] {pkg_name}.*{branch}.*successfully$", result
                    ):
                        add_content.append(f"Apply result: {branch} : apply success")
                    if re.match(f"^\[ERROR\] {pkg_name}.*{branch}.*failed", result):
                        add_content.append(f"Apply result: {branch} : apply failed")

        return add_content

    def _overwrite_text(self, folder, pkg_name, cve_num, apply_result):
        """
        write content
        Args:
            args: parameter
            pkg_name: pkg_name
            cve_num: cve_num
            apply_result: apply patch result
        """
        file_path = os.path.join(folder, pkg_name + "-" + cve_num, RECORD_FILE)
        if not os.path.exists(file_path):
            logger.error("The specified file does not exist : %s" % file_path)
            return
        try:

            format_text = self._parse_text(file_path)
            self._wirte_text_format(format_text, file_path, apply_result, pkg_name)
        except IOError as error:
            logger.error(error)

    def format_text(self, apply_result=None):
        """
        Format the contents recorded in the file to present the process in a uniform format
        Args:
            args : parameter
        """
        cve_infos = []
        if self.cve_file:
            try:
                cve_infos.extend(
                    self.read_csv(
                        os.path.join(self.cve_file),
                        out_path=self.folder,
                        return_content=True,
                    )
                )
            except TypeError:
                raise ValueError(
                    "The return value of the read_csv function must be iterable"
                )
        if all([self.pkg, self.cve]):
            cve_infos.append([self.pkg, self.cve])

        # Traversal process the searched patch information
        for cve in cve_infos:
            pkg_name, cve_num = cve
            self._overwrite_text(self.folder, pkg_name, cve_num, apply_result)

    def extract_text(self, path):
        """
        Extracting the comment content from the text
        """
        patchs = list()
        apply_result = []
        with open(path, "r", encoding="utf-8") as file:
            lines = file.readlines()
            for index, line in enumerate(lines, start=1):
                if all([p in line for p in ("Platform", "Patchs")]):
                    patchs.extend(re.findall(URL_REGEX, line))
                if "Apply Result" in line:
                    apply_result = lines[index:]
                    break
        if self._apply in apply_result:
            apply_result = [branch + ":" + "apply failed" for branch in self.branches]

        return {
            "urls": list(set(patchs)),
            "apply_result": dict([tuple(apply.split(":")[1:]) for apply in apply_result]),
        }


class RequestsUrl:
    """
    File download save method
    """

    def __init__(self, url, crawl, callback=None, **kwargs) -> None:
        self.crawl = crawl
        self.url = url
        self.callback = callback or self._wget
        self.__dict__.update(**kwargs)

    def _wget(self, response, **kwargs):
        """
        Send the request
        Args:
            response: response
            **kwargs:

        Returns:

        """
        folder = self.crawl.folder or DEFAULT_SAVE_PATH
        tmp_path = os.path.join(folder, "tmp-folder")
        try:
            os.makedirs(tmp_path, exist_ok=True)
            with open(
                os.path.join(
                    tmp_path,
                    self.crawl.cve
                    + "_{r}.patch".format(
                        r=hashlib.sha1(self.url.encode()).hexdigest()
                    ),
                ),
                "w",
                encoding="utf-8",
            ) as file:
                file.write(response.text)
        except IOError as error:
            logger.error(error)
        else:
            folders = self.crawl.create_folders(self.crawl.versions)
            if isinstance(folders, str):
                folders = [folders]

            for target_folder in folders:
                FileHandle.copy(tmp_path, target_folder)
        finally:
            if os.path.exists(tmp_path):
                shutil.rmtree(tmp_path)


class RequestRepeat:
    """
    Request address duplicate determination
    """

    def __init__(self) -> None:
        self._fingerprints = set()

    def _to_bytes(self, text, encoding="utf-8"):
        if isinstance(text, bytes):
            return text
        return text.encode(encoding)

    def _request_figerprint(self, request):
        hash_fp = hashlib.sha1()
        hash_fp.update(self._to_bytes(request.crawl.cve))
        hash_fp.update(self._to_bytes(request.url))
        return hash_fp.hexdigest()

    def request_seen(self, request):
        """
        Check if the URL has already been processed
        """
        hash_fp = self._request_figerprint(request=request)
        if hash_fp in self._fingerprints:
            return True
        self._fingerprints.add(hash_fp)

        return False


class SavePipe:
    """
    Data storage pipeline
    """

    def __init__(self, crawl, **kwargs) -> None:
        """
        Initialize the class
        Args:
            crawl:
            **kwargs: crawl
        """
        self.crawl = crawl
        self.__dict__.update(**kwargs)

    def save_process(self, crawl):
        """
        Data storage pipeline
        Args:
            crawl: crawl

        Returns:

        """
        path = os.path.join(crawl.folder, RECORD_FILE)
        try:
            os.makedirs(crawl.folder, exist_ok=True)
            if not hasattr(self, "text") or not self.text:
                return
            with open(path, "a", encoding="utf-8") as file:
                file.write(getattr(self, "text", "") + "\n")
        except IOError as error:
            logger.error(error)
