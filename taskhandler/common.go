package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"fmt"
	"strconv"
)

type GiteeToken struct {
	GrantType    string
	UserName     string
	Password     string
	ClientId     string
	ClientSecret string
	Scope        string
}

func CommentTemplate(assignee, commentCmd string) string {
	//commentTemplate := ""
	commentTemplate := "<br> Hey @" + assignee + "</br><br>" +
		` 以下内容需要您填写
- [Y]表示不需要填写，或者可以修改 | [N]需要填写且必填 | [?] 无法判断是否已填写
  
  |是否填写 |    模板名称   | 模板内容  |    模板标签    |
  |------- | ------------- | ------------- | ------------- |
  |  [N]   |    影响分析说明 | [IAD]填写影响分析说明的内容[/IAD] | [IAD][/IAD] |
  |  [N]   |    openEuler评分     | [OES]填写openEuler评分的内容[/OES] | [OES][/OES] |
  |  [N]   |    影响的版本     | [IV]填写影响版本的内容[/IV]  | [IV][/IV] |
 
    #### 具体示例如下: ####
- 分析issue填写模板（ps 每一次分析评论必须用/analysis指令 填写项可以一次填完也可不填写完 填写完成加上/done指令 请拷贝以下内容：    
 /analysis   
 影响分析说明:  
    [IAD] 请写内容 [/IAD]  
 openEuler评分:  
    [OES] 请写内容 [/OES]  
 影响的版本:  
    [IV] 请写内容 [/IV]  
 /done` + "</br>" + "<br>也可以参考: " + commentCmd + "</br>"
	return commentTemplate
}

func GitOpenEulerData(values map[string]interface{}, ge *models.GitOpenEuler, tb models.GitPackageTable) {
	defer common.Catchs()
	ge.TableName = tb.TableName
	ge.TableId = tb.TableId
	ge.Status = 0
	if values["feature"] == nil {
		ge.Feature = ""
	} else {
		switch values["feature"].(type) {
		case string:
			ge.Feature = values["feature"].(string)
		case int:
			ge.Feature = strconv.Itoa(values["feature"].(int))
		case int64:
			ge.Feature = strconv.FormatInt(values["feature"].(int64), 10)
		case float64:
			ge.Feature = strconv.FormatInt(int64(values["feature"].(float64)), 10)
		default:
			ge.Feature = ""
		}
	}
	if values["url"] == nil {
		ge.OriginUrl = ""
	} else {
		ge.OriginUrl = values["url"].(string)
	}
	switch values["id"].(type) {
	case string:
		ge.PackageId, _ = strconv.ParseInt(values["id"].(string), 10, 64)
	case int:
		ge.PackageId = values["id"].(int64)
	case int64:
		ge.PackageId = values["id"].(int64)
	case float64:
		ge.PackageId = int64(values["id"].(float64))
	default:
		ge.PackageId = 0
	}
	if values["name"] == nil {
		ge.PackageName = ""
	} else {
		packName := values["name"].(string)
		if packName != "" {
			packName = common.DeletePreAndSufSpace(packName)
		}
		ge.PackageName = packName
	}
	if values["version"] == nil {
		ge.Version = ""
	} else {
		version := values["version"].(string)
		if version != "" {
			version = common.DeletePreAndSufSpace(version)
		}
		ge.Version = version
	}
	if values["release"] == nil {
		ge.Release = ""
	} else {
		release := values["release"].(string)
		if release != "" {
			release = common.DeletePreAndSufSpace(release)
		}
		ge.Release = release
	}
	if values["rpm_license"] == nil {
		ge.License = ""
	} else {
		ge.License = values["rpm_license"].(string)
	}
	if values["maintainer"] == nil {
		ge.MainTainer = ""
	} else {
		ge.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		ge.MainTainLevel = 0
	} else {
		ge.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["release_time"] == nil {
		ge.ReleaseTime = ""
	} else {
		ge.ReleaseTime = values["release_time"].(string)
	}
	switch values["used_time"].(type) {
	case string:
		ge.UsedTime = values["used_time"].(string)
	case int:
		ge.UsedTime = strconv.Itoa(values["used_time"].(int))
	case int64:
		ge.UsedTime = strconv.FormatInt(values["used_time"].(int64), 10)
	case float64:
		ge.UsedTime = strconv.FormatInt(int64(values["used_time"].(float64)), 10)
	default:
		ge.UsedTime = ""
	}
	if values["latest_version"] == nil {
		ge.LatestVersion = ""
	} else {
		ge.LatestVersion = values["latest_version"].(string)
	}
	if values["latest_version_time"] == nil {
		ge.LatestVersionTime = ""
	} else {
		ge.LatestVersionTime = values["latest_version_time"].(string)
	}
	switch values["issue"].(type) {
	case string:
		ge.IssueCount, _ = strconv.ParseInt(values["issue"].(string), 10, 64)
	case int:
		ge.IssueCount = values["issue"].(int64)
	case int64:
		ge.IssueCount = values["issue"].(int64)
	case float64:
		ge.IssueCount = int64(values["issue"].(float64))
	default:
		ge.IssueCount = 0
	}
}

func GitOpenEulerInfoData(values map[string]interface{}, gp *models.GitPackageInfo, ge models.GitOpenEuler) {
	defer common.Catchs()
	gp.GitId = ge.GitId
	gp.Ids = 0
	if values["pkg_name"] == nil {
		gp.PackageName = ""
	} else {
		PackageName := values["pkg_name"].(string)
		if PackageName != "" {
			PackageName = common.DeletePreAndSufSpace(PackageName)
		}
		gp.PackageName = PackageName
	}
	if values["version"] == nil {
		gp.Version = ""
	} else {
		Version := values["version"].(string)
		if Version != "" {
			Version = common.DeletePreAndSufSpace(Version)
		}
		gp.Version = Version
	}
	if values["release"] == nil {
		gp.Release = ""
	} else {
		Release := values["release"].(string)
		if Release != "" {
			Release = common.DeletePreAndSufSpace(Release)
		}
		gp.Release = Release
	}
	if values["url"] == nil {
		gp.OriginUrl = ""
	} else {
		gp.OriginUrl = values["url"].(string)
	}
	if values["license"] == nil {
		gp.License = ""
	} else {
		gp.License = values["license"].(string)
	}
	switch values["feature"].(type) {
	case string:
		gp.Feature = values["feature"].(string)
	case int:
		gp.Feature = strconv.Itoa(values["feature"].(int))
	case int64:
		gp.Feature = strconv.FormatInt(values["feature"].(int64), 10)
	case float64:
		gp.Feature = strconv.FormatInt(int64(values["feature"].(float64)), 10)
	default:
		gp.Feature = ""
	}
	if values["maintainer"] == nil {
		gp.MainTainer = ""
	} else {
		gp.MainTainer = values["maintainer"].(string)
	}
	if values["maintainlevel"] == nil {
		gp.MainTainLevel = 0
	} else {
		gp.MainTainLevel = values["maintainlevel"].(int8)
	}
	if values["gitee_url"] == nil {
		gp.GitUrl = ""
	} else {
		gp.GitUrl = values["gitee_url"].(string)
	}
	if values["summary"] == nil {
		gp.Summary = ""
	} else {
		gp.Summary = values["summary"].(string)
	}
	if values["description"] == nil {
		gp.Decription = ""
	} else {
		gp.Decription = values["description"].(string)
	}
	BuildRequired := ""
	if values["buildrequired"].([]interface{}) != nil && len(values["buildrequired"].([]interface{})) > 0 {
		for _, vx := range values["buildrequired"].([]interface{}) {
			BuildRequired = BuildRequired + vx.(string) + ","
		}
		gp.BuildRequired = BuildRequired[:len(BuildRequired)-1]
	} else {
		gp.BuildRequired = BuildRequired
	}
	gp.Status = 0
}

type GitTablePackCount struct {
	Page      int
	Size      int
	TableName string
	Count     int64
}

func CreateIssueBody(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score, OpenEulerScore, score, labels string,
	its models.IssueTemplate, flag int, issueType, pkgLink string) string {
	requestBody := ""
	scoretype := ""
	if sc.ScoreType == "v2" {
		scoretype = "2.0"
	} else {
		scoretype = "3.0"
	}
	if flag == 1 {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>" + path + "</br>" +
			"<br>漏洞归属的版本: </br>" + "<br>" + cve.CveVersion + "</br>" + "<br>CVSS V" + scoretype + "分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: CVSS:" + scoretype + "/" + sc.NvectorVule + "</br>" + "<br>漏洞简述: </br>" +
			"<br>" + cve.Description + "</br>" + "<br>影响性分析说明: </br>" +
			"<br>" + its.CveAnalysis + " </br>" +
			"<br>openEuler评分: </br>" + "<br> " + OpenEulerScore + "</br>" +
			"<br>受影响版本: </br>" + "<br> " + its.AffectedVersion + "</br><br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, its.StatusName, body, assignee, labels)
	} else if flag == 2 {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>" + path + "</br>" +
			"<br>漏洞归属的版本: </br>" + "<br>" + cve.CveVersion + "</br>" + "<br>CVSS V" + scoretype + "分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: CVSS:" + scoretype + "/" + sc.NvectorVule + "</br>" + "<br>漏洞简述: </br>" +
			"<br>" + cve.Description + "</br>" + "<br>影响性分析说明: </br>" +
			"<br> </br>" +  "<br>openEuler评分: </br>" + "<br> </br>" +
			"<br>受影响版本: </br>" + "<br> </br><br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"issue_type": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, issueType, body, assignee, labels)
	} else {
		body := "漏洞编号: " + "<br>[" + cve.CveNum + "](https://nvd.nist.gov/vuln/detail/" + cve.CveNum + ")" + "</br>" +
			"<br>漏洞归属组件: </br>" + "<br>" + path + "</br>" +
			"<br>漏洞归属的版本: </br>" + "<br>" + cve.CveVersion + "</br>" + "<br>CVSS V" + scoretype + "分值: </br>" +
			"<br>BaseScore: " + score + " " + cve.CveLevel + "</br>" +
			"<br>Vector: CVSS:" + scoretype + "/" + its.NVDVector + "</br>" + "<br>漏洞简述: </br>" +
			"<br>" + cve.Description + "</br>" + "<br>影响性分析说明: </br>" +
			"<br>" + its.CveAnalysis + " </br>" +
			"<br>openEuler评分: </br>" + "<br> " + OpenEulerScore + "</br>" +
			"<br>受影响版本: </br>" + "<br> " + its.AffectedVersion + "</br>" + "<br> </br>"
		requestBody = fmt.Sprintf(`{
			"access_token": "%s",
			"repo": "%s", 
			"title": "%s",
			"state": "%s",
			"body": "%s",
			"assignee": "%s",
			"labels": "%s",
			"security_hole": "false"
			}`, accessToken, path, cve.CveNum, its.StatusName, body, its.Assignee, labels)
	}
	return requestBody
}
