package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"github.com/astaxie/beego/logs"
	"strings"
)

func CheckCveOriginData(prcnum int) (string, error) {
	defer common.Catchs()
	//var os []models.OriginUpstream
	count := 0
	ok := models.UpdateOriginExistTemp()
	if !ok {
		logs.Info("UpdateOriginExistTemp, 没有数据需要处理")
		return "", nil
	}
	for {
		os, num, err := models.QueryOriginCveE(prcnum)
		if err != nil || num == 0 {
			logs.Info("当前无异常cve原始数据处理, err: ", err,
				", 处理时间范围: beforetime: ",
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("总共有: ", num, "条数据需要处理, ", os)
		ch := make(chan int, len(os))
		for i, cveOrg := range os {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveOrg.Ids)
			go func(idx int, cveData models.OriginUpstream) {
				ch <- idx
				packNameList := []string{}
				if cveData.PackName != "" && len(cveData.PackName) > 0 {
					packNameList = strings.Split(cveData.PackName, ",")
				}
				if len(packNameList) > 0 {
					for _, pk := range packNameList {
						pkList := strings.Split(pk, "==")
						if len(pkList) == 2 {
							gits, ok := models.QueryCveOpeneulerdata(pkList[0], pkList[1])
							if !ok {
								models.UpdateOriginExist(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 0)
								logs.Info("仓库和版本对应关系错误, 还原: ", cveData, ", gits: ", gits)
								break
							} else {
								models.UpdateOriginExist(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 1)
								logs.Info("加入到cve漏洞中: ", cveData, ", gits: ", gits)
							}
						}
					}
				}
			}(i, cveOrg)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return "", nil
}

func UnLockTableData() {

}
