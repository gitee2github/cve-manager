package util

import (
	"fmt"
	"regexp"
	"sort"
	"strings"
	"sync"
)

const (
	KwAnalysisDesc   = "影响性分析说明:"
	KwOpenEulerScore = "openEuler评分:"
	KwEffectVersion  = "受影响版本排查(受影响/不受影响):"
)

var (
	LAC         = "LAC"  //漏洞组件标签
	LN          = "LN"   //漏洞编号标签
	LAV         = "LAV"  //漏洞版本标签
	CVS         = "CVS"  //cvss 3.0分值标签
	CVV         = "CVV"  //cvss 3.1向量标签
	LD          = "LD"   //漏洞描述标签
	IAD         = "IAD"  //影响分析说明标签
	PA          = "PA"   //原理分析标签
	OES         = "OES"  //openEuler评分标签
	OEV         = "OEV"  //openEuler向量标签
	IV          = "IV"   //影响的版本标签
	CPMM        = "CPMM" //规避方案措施
	IW          = "IW"   //影响的包
	CommentKeys = []string{KwAnalysisDesc, KwOpenEulerScore, KwEffectVersion}
)

var (
	CvsScoreV3          = "v3"
	CvsScoreV2          = "v2"
	RegexpCveNumber     = regexp.MustCompile(`漏洞编号[:：](?s:(.*?))漏洞归属组件[:：]`)
	RegexpCveNumberLink = regexp.MustCompile(`\[(.*?)\]\((.*?)\)`)
	RegexpCveComponents = regexp.MustCompile(`漏洞归属组件[:：](?s:(.*?))漏洞归属的?版本[:：]`)
	RegexpCveVersion    = regexp.MustCompile(`漏洞归属的?版本[:：](?s:(.*?))CVSS V[23].0分值[:：]`)
	RegexpCveScore      = regexp.MustCompile(`CVSS V[23].0分值[:：](?s:(.*?))漏洞[简描]述[:：]`)
	//RegexpCveScore             = regexp.MustCompile(`CVSS V3.0分值[:：](?s:(.*?))Vector[:：]`)
	//RegexpCveVector            = regexp.MustCompile(`Vector[:：](?s:(.*?))(漏洞简述[:：])`)
	RegexpCveBriefDesc         = regexp.MustCompile(`漏洞[简描]述[:：](?s:(.*?))影响性分析说明[:：]`)
	RegexpCveInfluencesDesc    = regexp.MustCompile(`影响性分析说明[:：](?s:(.*?))原理分析[:：]`)
	RegexpCveInfluencesDescNew = regexp.MustCompile(`影响性分析说明[:：](?s:(.*?))openEuler评分[:：]`)
	RegexpCvePrincipleDesc     = regexp.MustCompile(`原理分析[:：](?s:(.*?))openEuler评分[:：]`)
	RegexpCveOpScore           = regexp.MustCompile(`openEuler评分[:：](?s:(.*?))受影响版本[:：]`)
	RegexpCveOpScoreNew        = regexp.MustCompile(`openEuler评分[:：](?s:(.*?))受影响版本排查\(受影响/不受影响\)[:：]`)
	//RegexpCveOpScore1          = regexp.MustCompile(`openEuler评分[:：](?s:(.*?))受影响版本[:：]`)
	//RegexpCveOpVector          = regexp.MustCompile(`openEulerVector[:：](?s:(.*?))受影响版本[:：]`)
	RegexpCveInfluencesVersion    = regexp.MustCompile(`受影响版本[:：](?s:(.*?))规避方案或消减措施[:：]`)
	RegexpCveInfluencesVersionNew = regexp.MustCompile(`受影响版本排查\(受影响/不受影响\)[:：](?s:(.*?))$`)
	RegexpCvePlannedMeasures      = regexp.MustCompile(`规避方案或消减措施[:：](?s:(.*?))受影响的包[:：]`)
	RegexpCvePlannedMeasures1     = regexp.MustCompile(`规避方案或消减措施[:：](?s:(.*?))$`)
	RegexpCveInfluencesPkg        = regexp.MustCompile(`受影响的包[:：](?s:(.*?))$`)
	RegexpSpecialDigital          = regexp.MustCompile(`(CVSS[:：]3.0|CVSS[:：]2.0|cvss[:：]3.0|cvss[:：]2.0|3.0/|2.0/|3.0 /|2.0 /)*`) //^((CVSS：3.0|CVSS：2.0|3.0/|2.0/|3.0 /|2.0 /).)*$
	RegexpDigital                 = regexp.MustCompile(`(\d){1,}(\.?\d+)?`) //(\d){1,}(\.\d+)?
	//`/AV:[NLAP]/AC:[HL]/PR:[NLH]/UI:[NR]/S:[UC]/C:[NLH]/I:[HNL]/A:[LNH]`
	RegexpVector          = regexp.MustCompile(`AV:[NLAP](?s:(.*?))/A:[LNH]`)
	RegexpVectorV2        = regexp.MustCompile(`AV:[LAN](?s:(.*))/Au:[MSN](?s:(.*))/A:[NPC]`)
	RegexpScoreTypeV2     = regexp.MustCompile(`(?mi)^CVSS v2.0分值\s*`)
	RegexpScoreTypeV3     = regexp.MustCompile(`(?mi)^CVSS v3.0分值\s*`)
	RegexpIsNewTpl        = regexp.MustCompile(`(?mi)^原理分析[：:]\s*`)
	RegexpIsNewTpl2       = regexp.MustCompile(`(?mi)^规避方案或消减措施[:：]\s*`)
	regexpEffectVersion   = regexp.MustCompile(`(?mi)[\d]{1,}\.(.*?)[:：]受影响`)
	regexpNoEffectVersion = regexp.MustCompile(`(?mi)[\d]{1,}\.(.*?)[:：]不受影响`)
	regexpOtherEffectVersion = regexp.MustCompile(`(?mi)[\d]{1,}\.(.*?)[:：]`)
)

var (
	VectorMapV2 map[string]map[string]string
	VectorMap   map[string]map[string]string
	mutex       sync.Mutex
)

type CommentAnalysis struct {
	KeyName  string
	KeyIdx   int
	KeyValue string
}
type CaSlice []CommentAnalysis

func (a CaSlice) Len() int {
	return len(a)
}
func (a CaSlice) Swap(i, j int) {
	a[i], a[j] = a[j], a[i]
}
func (a CaSlice) Less(i, j int) bool {
	return a[j].KeyIdx > a[i].KeyIdx
}

func init() {
	//pattenStr := `/AV:[NLAP]/AC:[HL]/PR:[NLH]/UI:[NR]/S:[UC]/C:[NLH]/I:[HNL]/A:[LNH]`
	VectorMap = make(map[string]map[string]string)
	mAv := make(map[string]string)
	mAv["N"] = "Network"
	mAv["L"] = "Local"
	mAv["A"] = "Adjacent"
	mAv["P"] = "Physical"
	VectorMap["AV"] = mAv
	mAc := make(map[string]string)
	mAc["H"] = "High"
	mAc["L"] = "Low"
	VectorMap["AC"] = mAc
	mPr := make(map[string]string)
	mPr["H"] = "High"
	mPr["N"] = "None"
	mPr["L"] = "Low"
	VectorMap["PR"] = mPr
	mUi := make(map[string]string)
	mUi["N"] = "None"
	mUi["R"] = "Require"
	VectorMap["UI"] = mUi
	mS := make(map[string]string)
	mS["U"] = "Unchanged"
	mS["C"] = "Changed"
	VectorMap["S"] = mS
	mC := make(map[string]string)
	mC["H"] = "High"
	mC["L"] = "Low"
	mC["N"] = "None"
	VectorMap["C"] = mC
	mI := make(map[string]string)
	mI["H"] = "High"
	mI["N"] = "None"
	mI["L"] = "Low"
	VectorMap["I"] = mC
	mA := make(map[string]string)
	mA["H"] = "High"
	mA["L"] = "Low"
	mA["N"] = "None"
	VectorMap["A"] = mA
	VectorMapV2 = make(map[string]map[string]string)
	//AV:L/AC:L/Au:N/C:C/I:C/A:C
	mAv2 := make(map[string]string)
	mAv2["L"] = "Local"
	mAv2["A"] = "AdjacentNetwork"
	mAv2["N"] = "Network"
	VectorMapV2["AV"] = mAv2
	mAc2 := make(map[string]string)
	mAc2["H"] = "High"
	mAc2["M"] = "Medium"
	mAc2["L"] = "Low"
	VectorMapV2["AC"] = mAc2
	mAu := make(map[string]string)
	mAu["M"] = "Multiple"
	mAu["S"] = "Single"
	mAu["N"] = "None"
	VectorMapV2["Au"] = mAu
	mCi := make(map[string]string)
	mCi["N"] = "None"
	mCi["P"] = "Partial"
	mCi["C"] = "Complete"
	VectorMapV2["C"] = mCi
	mII := make(map[string]string)
	mII["N"] = "None"
	mII["P"] = "Partial"
	mII["C"] = "Complete"
	VectorMapV2["I"] = mII
	mAi := make(map[string]string)
	mAi["N"] = "None"
	mAi["P"] = "Partial"
	mAi["C"] = "Complete"
	VectorMapV2["A"] = mAi
}

//GenerateCommentAnalysis Generate analytical entities based on comments.
func GenerateCommentAnalysis(content string) (ca CaSlice) {
	if content == "" {
		return
	}
	for _, v := range CommentKeys {
		if strings.Contains(content, v) {
			cm := CommentAnalysis{KeyName: v}
			index := strings.Index(content, v)
			cm.KeyIdx = index
			ca = append(ca, cm)
		}
	}
	//sort ca item by key index
	if len(ca) > 0 {
		//sort by index
		sort.Sort(ca)
		//extract keyword value
		for k, _ := range ca {
			if k == len(ca)-1 {
				start := ca[k].KeyIdx + len(ca[k].KeyName)
				ca[k].KeyValue = content[start:]
			} else {
				start := ca[k].KeyIdx + len(ca[k].KeyName)
				end := ca[k+1].KeyIdx
				ca[k].KeyValue = content[start:end]
			}
		}
	}
	return ca
}

//ParseCommentContent extract comment content based on tags.
func ParseCommentContent(content string, label string) (res string, ok bool) {
	ret := regexp.MustCompile(genCommentRegexpStr(label))
	sm := ret.FindAllStringSubmatch(content, 1)
	if len(sm) > 0 {
		res = sm[0][1]
		ok = true
	}
	return
}

func ParseCommentVector(content string) string {
	sm := RegexpVector.Find([]byte(content))
	return string(sm)
}

func ExtractVector(body, scoreType string) string {
	if body == "" {
		return body
	}
	if scoreType == CvsScoreV2 {
		rvs := RegexpVectorV2.Find([]byte(body))
		if rv := string(rvs); rv != "" {
			return rv
		}
	} else {
		rvs := RegexpVector.Find([]byte(body))
		if rv := string(rvs); rv != "" {
			return rv
		}
	}

	return ""
}

func ReadVmValue(kStr string) (value string) {
	if kStr == "" {
		return ""
	}
	if !strings.Contains(kStr, ":") {
		return ""
	}
	kStr = TrimString(kStr)
	sKs := strings.Split(kStr, ":")
	if len(sKs) != 2 {
		return ""
	}
	mutex.Lock()
	defer mutex.Unlock()
	if _, ok := VectorMap[sKs[0]]; ok {
		value = VectorMap[sKs[0]][sKs[1]]
	}
	return
}

func ReadVmValueV2(kStr string) (value string) {
	if kStr == "" {
		return ""
	}
	if !strings.Contains(kStr, ":") {
		return ""
	}
	kStr = TrimString(kStr)
	sKs := strings.Split(kStr, ":")
	if len(sKs) != 2 {
		return ""
	}
	mutex.Lock()
	defer mutex.Unlock()
	if _, ok := VectorMapV2[sKs[0]]; ok {
		value = VectorMapV2[sKs[0]][sKs[1]]
	}
	return
}

func VctToMap(vct string) (vctMap map[string]string, ok bool) {
	if vct == "" {
		return nil, false
	}
	sp := strings.Split(vct, "/")
	if len(sp) < 1 {
		return nil, false
	}
	vMap := make(map[string]string)
	for _, v := range sp {
		spv := strings.Split(v, ":")
		if len(spv) != 2 {
			continue
		}
		vMap[spv[0]] = v
	}
	if len(vMap) > 0 {
		return vMap, true
	} else {
		return nil, false
	}
}

func ParseCommentWithAllLabel(content string) map[string]string {
	res := make(map[string]string, 0)
	s, ok := ParseCommentContent(content, IAD)
	if ok {
		res["cve_analysis"] = s
	}
	s, ok = ParseCommentContent(content, PA)
	if ok {
		res["principle_analysis"] = s
	}
	s, ok = ParseCommentContent(content, OES)
	if ok {
		res["openeuler_score"] = TrimString(s)
	}
	s, ok = ParseCommentContent(content, OEV)
	if ok {
		vector := ParseCommentVector(s)
		if vector != "" {
			res["openeuler_vector"] = s
		}
	}
	s, ok = ParseCommentContent(content, IV)
	if ok {
		res["affected_version"] = s
	}
	s, ok = ParseCommentContent(content, CPMM)
	if ok {
		res["solution"] = s
	}
	s, ok = ParseCommentContent(content, IW)
	if ok {
		res["issue_package"] = s
	}

	return res
}

func ExtractCommentAnalysisAllValue(content string) map[string]string {
	res := make(map[string]string, 0)
	ca := GenerateCommentAnalysis(content)
	if len(ca) > 0 {
		value, ext := ExtractCommentValue(ca, KwAnalysisDesc)
		if ext {
			res["cve_analysis"] = TrimStringNR(value)
		}
		value, ext = ExtractCommentValue(ca, KwEffectVersion)
		if ext {
			value = ExtractCommentEffectVersion(value)
			//if value != "" {
			res["affected_version"] = value
			//}
		}
		value, ext = ExtractCommentValue(ca, KwOpenEulerScore)
		if ext {
			score, vector := ExtractCommentOpenEulerScore(value)
			if score != ""{
			res["openeuler_score"] = score
			}
			if vector != "" {
			res["openeuler_vector"] = vector
			}
		}
	}
	return res
}

func ExtractCommentEffectVersion(str string) string {
	str = strings.Trim(str, " ")
	var res []string
	match := regexpEffectVersion.FindAllStringSubmatch(str, -1)
	match2 := regexpNoEffectVersion.FindAllStringSubmatch(str, -1)
	if len(match) > 0 || len(match2) > 0 {
		if len(match) > 0 {
			for _, v := range match {
				if len(v) > 1 {
					res = append(res, TrimString(v[1])+":受影响")
				}
			}
		}
		if len(match2) > 0 {
			for _, v := range match2 {
				if len(v) > 1 {
					res = append(res, TrimString(v[1])+":不受影响")
				}
			}
		}
	} else {
		match3 := regexpOtherEffectVersion.FindAllStringSubmatch(str, -1)
		if len(match3) > 0 {
			for _, v := range match3 {
				if len(v) > 1 {
					res = append(res, TrimString(v[1])+":")
				}
			}
		}
	}
	if len(res) > 0 {
		return strings.Join(res, ",")
	}
	return ""
}

func ExtractCommentValue(ca CaSlice, keyWord string) (string, bool) {
	for _, v := range ca {
		if v.KeyName == keyWord {
			return v.KeyValue, true
		}
	}
	return "", false
}

func ExtractCommentOpenEulerScore(str string) (score, vector string) {
	str = TrimString(str)
	score = ExtractDigital(str)
	vector = ExtractVector(str, CvsScoreV3)
	if vector == "" {
		vector = ExtractVector(str, CvsScoreV2)
	}
	return
}

func genCommentRegexpStr(label string) string {
	return fmt.Sprintf(`\[%s\](?s:(.*?))\[/%s\]`, label, label)
}

func TrimString(str string) string {
	str = strings.Replace(str, " ", "", -1)
	str = strings.Replace(str, "\n", "", -1)
	str = strings.Replace(str, "\r", "", -1)
	str = strings.Replace(str, "\t", "", -1)
	return str
}

func TrimStringNR(str string) string {
	str = strings.Replace(str, "\n", "", -1)
	str = strings.Replace(str, "\r", "", -1)
	str = strings.Replace(str, "\t", "", -1)
	return str
}

func RemoveSpecialDigital(body string) string {
	if body == "" {
		return body
	}
	sds := RegexpSpecialDigital.ReplaceAllString(body, "")
	if len(sds) > 0 {
		return sds
	}
	return ""
}

func ExtractDigital(body string) string {
	if body == "" {
		return body
	}
	scoreStr := ""
	tempStr := RemoveSpecialDigital(body)
	if tempStr != "" && len(tempStr) > 0 {
		scoreStr = tempStr
	} else {
		scoreStr = body
	}
	sds := RegexpDigital.FindAllStringSubmatch(scoreStr, -1)
	if len(sds) > 0 {
		return sds[0][0]
	}
	return ""
}

func GetCveNumber(ov string) string {
	if v := RegexpCveNumberLink.Find([]byte(ov)); len(v) > 0 {
		sv := string(v)
		start := strings.Index(sv, "[") + 1
		end := strings.Index(sv, "]")
		return sv[start:end]
	} else {
		return ov
	}
}
