package common

import (
	"errors"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"strings"
	"time"
)

func DesString(dbpwd string) (strs string) {
	if "" != dbpwd || len(dbpwd) > 0 {
		key := beego.AppConfig.String("key")
		key1 := []byte(key)
		bytes, _ := DePwdCode(dbpwd, key1)
		strs = string(bytes)
	} else {
		strs = ""
	}
	return strs
}


func GetTokenExpirTime() (token_expir_time int) {
	token_expir_time, err := beego.AppConfig.Int("token_expir_time")
	if err == nil {
		return token_expir_time
	}
	return 3
}


func VectorParams(Vector string, VectorMap map[string]string) map[string]string{
	if Vector != "" || len(Vector) != 0{
		VertorList := strings.Split(Vector, "/")
		if VertorList != nil && len(VertorList) > 0 {
			for _, vule := range VertorList {
				if strings.Contains(vule, ":") {
					SubList := strings.Split(vule, ":")
					if SubList != nil && len(SubList) == 2 {
						VerKey := strings.ToUpper(SubList[0])
						verVule := strings.ToUpper(SubList[1])
						switch VerKey {
						case "AV":
							if verVule == "N" {
								VectorMap["NattackVector"] = "Network"
							} else {
								VectorMap["NattackVector"] = "Local"
							}
						case "AC":
							if verVule == "L" {
								VectorMap["NattackComplexity"] = "Low"
							} else if verVule == "H"{
								VectorMap["NattackComplexity"] = "High"
							} else {
								VectorMap["NattackComplexity"] = "None"
							}
						case "PR":
							if verVule == "L" {
								VectorMap["NprivilegeRequired"] = "Low"
							} else if verVule == "H"{
								VectorMap["NprivilegeRequired"] = "High"
							} else {
								VectorMap["NprivilegeRequired"] = "None"
							}
						case "UI":
							if verVule == "L" {
								VectorMap["NuserInteraction"] = "Low"
							} else if verVule == "H"{
								VectorMap["NuserInteraction"] = "High"
							} else {
								VectorMap["NuserInteraction"] = "None"
							}
						case "S":
							if verVule == "U" {
								VectorMap["Nscope"] = "Unchanged"
							} else {
								VectorMap["Nscope"] = "None"
							}
						case "C":
							if verVule == "L" {
								VectorMap["Nconfidentiality"] = "Low"
							} else if verVule == "H"{
								VectorMap["Nconfidentiality"] = "High"
							} else {
								VectorMap["Nconfidentiality"] = "None"
							}
						case "I":
							if verVule == "L" {
								VectorMap["Nintegrity"] = "Low"
							} else if verVule == "H"{
								VectorMap["Nintegrity"] = "High"
							} else {
								VectorMap["Nintegrity"] = "None"
							}
						case "A":
							if verVule == "L" {
								VectorMap["Navailability"] = "Low"
							} else if verVule == "H"{
								VectorMap["Navailability"] = "High"
							} else {
								VectorMap["Navailability"] = "None"
							}
						default:
							VectorMap = make(map[string]string)
						}
					}
				}
			}
		}
	}
	return VectorMap
}

func GetCurTime() string{
	return time.Now().Format("2006-01-02 15:04:05")
}

func GetBeforeTime(days int) string {
	nowTime := time.Now()
	getTime := nowTime.AddDate(0, 0, days)                //年，月，日   获取一天前的时间
	resTime := getTime.Format("2006-01-02 15:04:05") //获取的时间的格式
	logs.Info("获取：", days, "前的时间：", resTime)

	//getTime = nowTime.AddDate(0, -1, 0)             //年，月，日   获取一个月前的时间
	//resTime = getTime.Format("2006-01-02 15:04:05") //获取的时间的格式
	//fmt.Println(resTime)
	//
	//getTime = nowTime.AddDate(-2, 0, 0)  //年，月，日   获取两年前的时间
	//resTime = getTime.Format("20060102") //获取的时间的格式
	//fmt.Println(resTime)
	return resTime
}

func Catchs() {
	if err := recover(); err != nil {
		logs.Error("程序发生异常, err: ", err)
	}
}


func DeletePreAndSufSpace(str string) string {
	strList := []byte(str)
	spaceCount, count := 0, len(strList)
	for i := 0; i <= len(strList)-1; i++ {
		if strList[i] == 32 {
			spaceCount++
		} else {
			break
		}
	}
	strList = strList[spaceCount:]
	spaceCount, count = 0, len(strList)
	for i := count - 1; i >= 0; i-- {
		if strList[i] == 32 {
			spaceCount++
		} else {
			break
		}
	}
	return string(strList[:count-spaceCount])
}

type CveDescription struct {
	EnDesc string `json:"en"`
	ZhDesc string `json:"zh"`
}

type NodeCpe struct {
	Cpe23Uri string `json:"cpe23Uri"`
	CpeMatchString string `json:"cpeMatchString"`
	Vulnerable string `json:"vulnerable"`
}

type ConfNodes struct {
	Operator string `json:"operator"`
	Cpe []NodeCpe `json:"cpe"`
}

type CveConfigurations struct {
	Nodes []ConfNodes `json:"nodes"`
}

type BmCvssV3 struct {
	VectorString string `json:"vectorString"`
	AttackComplexity string `json:"attackComplexity"`
	AttackVector string `json:"attackVector"`
	AvailabilityImpact string `json:"availabilityImpact"`
	BaseSeverity string `json:"baseSeverity"`
	UserInteraction string `json:"userInteraction"`
	BaseScore float64 `json:"baseScore"`
	PrivilegesRequired string `json:"privilegesRequired"`
	Version string `json:"version"`
	ConfidentialityImpact string `json:"confidentialityImpact"`
	IntegrityImpact string `json:"integrityImpact"`
	Scope string `json:"scope"`
}

type ImBaseMetricV3 struct {
	CvssV3 BmCvssV3 `json:"cvssV3"`
	ImpactScore float64 `json:"impactScore"`
	ExploitabilityScore float64 `json:"exploitabilityScore"`
}

type BmCvssV2 struct {
	VectorString string `json:"vectorString"`
	AccessComplexity string `json:"accessComplexity"`
	AvailabilityImpact string `json:"availabilityImpact"`
	Authentication string `json:"authentication"`
	Version string `json:"version"`
	BaseScore float64 `json:"baseScore"`
	IntegrityImpact string `json:"integrityImpact"`
	ConfidentialityImpact string `json:"confidentialityImpact"`
	AccessVector string `json:"accessVector"`
}

type ImBaseMetricV2 struct {
	AcInsufInfo string `json:"acInsufInfo"`
	CvssV2 BmCvssV2 `json:"cvssV2"`
	UserInteractionRequired string `json:"userInteractionRequired"`
	Severity string `json:"severity"`
	ObtainUserPrivilege string `json:"obtainUserPrivilege"`
	ObtainAllPrivilege string `json:"obtainAllPrivilege"`
	ImpactScore float64 `json:"impactScore"`
	ExploitabilityScore float64 `json:"exploitabilityScore"`
	ObtainOtherPrivilege string `json:"obtainOtherPrivilege"`
}

type CveImpact struct {
	BaseMetricV3 ImBaseMetricV3 `jsong:"baseMetricV3"`
	BaseMetricV2 ImBaseMetricV2 `jsong:"baseMetricV2"`
}

type CvePoc struct {
	Source string `json:"source"`
	Date string `json:"date"`
	Path string `json:"path"`
	Dbindex string `json:"dbindex"`
	Url string `json:"url"`
	Desc string `json:"desc"`
}

type CveEvent struct {
	Title string `json:"title"`
	Date string `json:"date"`
	Description string `json:"description"`
	Url string `json:"url"`
}

type CveReferenceData struct {
	Url string `json:"url"`
	Name string `json:"name"`
	Refsource string `json:"refsource"`
	Tags []string `json:"tags"`
}

type CveVulType struct {
	Cwe string `json:"cwe"`
	En string `json:"en"`
	Zh string `json:"zh"`
}

type FixReferences struct {
	Url string `json:"url"`
	Refsource string `json:"refsource"`
	Name string `json:"name"`
	Tags []string `json:"tags"`
}

type CveFixSuggest struct {
	Detail string `jsong:"detail"`
	References []FixReferences `jsong:"references"`
}

type CveOriginData struct {
	Ids string `json:"ids"`
	CveNum string `json:"cveNum"`
	UpdateType string `json:"updateType"`
	CvePackName string `json:"cvePackName"`
	PackName string `json:"packName"`
	Description CveDescription `json:"description"`
	Title string `json:"title"`
	AffectProduct string `json:"affectProduct"`
	Configurations CveConfigurations `json:"configurations"`
	CnnvdID string `json:"cnnvdID"`
	CnvdID string `json:"cnvdID"`
	PublishedDate string `json:"publishedDate"`
	Impact CveImpact `json:"impact"`
	VulStatus string `json:"vulStatus"`
	Poc CvePoc `json:"poc"`
	Event CveEvent `json:"event"`
	ReferenceData []CveReferenceData `json:"referenceData"`
	VulType CveVulType `json:"vulType"`
	FixSuggest CveFixSuggest `json:"fixSuggest"`
	Version string `json:"version"`
}

type UploadData struct {
	Token string `json:"Token"`
	CveData []CveOriginData
}

func GetRepoOrg() (string, error) {
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil{
		logs.Error("config init error:", err)
		return "", err
	}
	owner := BConfig.String("gitee::owner")
	if owner == "" {
		logs.Error("config gitee::owner error: invalid value is ", owner)
		return "", errors.New("value is nil")
	}
	return owner, nil
}