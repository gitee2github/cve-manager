package taskhandler

import (
	"encoding/json"
	"errors"
	"os"
	"sort"
	"strings"

	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"

	"cvevulner/common"
	"cvevulner/util"
)

func GetOautToken(gt GiteeToken) {
	url := "https://gitee.com/oauth/token"
	var req util.RequestInfo
	req.URL = url
	req.Data = make(map[string]string)
	req.Data["grant_type"] = gt.GrantType
	req.Data["username"] = gt.UserName
	req.Data["password"] = gt.Password
	req.Data["client_id"] = gt.ClientID
	req.Data["client_secret"] = gt.ClientSecret
	req.Data["scope"] = gt.Scope
	resp, err := util.PostURLEncoded(req)
	if err != nil {
		logs.Error("Failed to obtain token,url: ", url,
			",Request parameter: ", gt, ", err:", err)
		return
	}
	var respDict map[string]interface{}
	err = json.Unmarshal(resp, &respDict)
	if err != nil {
		logs.Error(err)
		return
	}
	if _, ok := respDict["access_token"]; !ok {
		logs.Error("Failed to obtain token, err: ", ok, ", url: ", url)
		return
	}
	GitToken := respDict["access_token"].(string)
	os.Setenv("GITEE_TOKEN", GitToken)
}

func GetCollaboratorInfo(accessToken string, owner string, path string) (string, error) {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/collaborators?access_token=" + accessToken
		collabor, err := util.HTTPGet(url)
		if err == nil && collabor != nil {
			for _, value := range collabor {
				if _, ok := value["id"]; !ok {
					logs.Error("collaborators, err: ", ok, "url: ", url)
					continue
				}
				assignee := ""
				for mapKey, mapValue := range value {
					if mapKey == "login" {
						assignee = mapValue.(string)
					}
				}
				if assignee != "" {
					return assignee, nil
				}
			}
		} else {
			logs.Error("Failed to obtain repo owner, owner:", owner, ",path:", path, ",err: ", err)
			return "", err
		}
	}
	return "", errors.New("参数错误")
}

func GetBranchesInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	BrandVerSlice := make([]string, 0)
	switch organizationID {
	case util.OpenLookeng:
		if openlookengVersion := beego.AppConfig.String("openlookeng::openlookeng_version"); len(openlookengVersion) > 0 {
			BrandVerSlice = strings.Split(openlookengVersion, ",")
		}
	case util.MindSpore:
		if mindsporeVersion := beego.AppConfig.String("mindspore::mindspore_version"); len(mindsporeVersion) > 0 {
			BrandVerSlice = strings.Split(mindsporeVersion, ",")
		}
	case util.OpenGauss:
		if gaussVersion := beego.AppConfig.String("opengauss::gauss_version"); len(gaussVersion) > 0 {
			BrandVerSlice = strings.Split(gaussVersion, ",")
		}
		path = beego.AppConfig.String("opengauss::openGauss-server")
	default:
		if eulerVersion := beego.AppConfig.String("cve::affected_branchs"); len(eulerVersion) > 0 {
			BrandVerSlice = strings.Split(eulerVersion, ",")
		}
	}
	branchNameList := []string{}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/branches?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("branches, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					switch organizationID {
					case util.OpenGauss, util.OpenLookeng:
						if !common.IsContainsLetters(mapValue) {
							branchNameList = append(branchNameList, mapValue)
						}
					case util.MindSpore:
						if common.IsContainSpecialChar(mapValue, 1) {
							branchNameList = append(branchNameList, mapValue)
						}
					default:
						for _, gv := range BrandVerSlice {
							if gv == mapValue {
								branchNameList = append(branchNameList, mapValue)
							}
						}
					}
				}
			}
		} else {
			logs.Error("Failed to get branch name, "+
				"err: ", err, ",owner: ", owner, ",path: ", path)
			if organizationID != util.Openeuler {
				logs.Info("1.Obtained branch information: ", BrandVerSlice)
				return BrandVerSlice, err
			}
			logs.Info("2.Obtained branch information: ", branchNameList)
			return branchNameList, err
		}
	}

	if len(branchNameList) > 0 {
		sort.Strings(branchNameList)
	}

	if organizationID == util.OpenGauss {
		if len(branchNameList) > 2 {
			branchNameList = branchNameList[len(branchNameList)-2:]
		}
	} else if organizationID == util.MindSpore {
		if len(branchNameList) > 4 {
			branchNameList = branchNameList[len(branchNameList)-4:]
		}
	} else if organizationID == util.OpenLookeng {
		if len(branchNameList) > 1 {
			branchNameList = branchNameList[len(branchNameList)-1:]
		}
	}

	if len(BrandVerSlice) > 0 {
		branchNameList = append(branchNameList, BrandVerSlice...)
	}

	branchNameList = common.RemoveDupString(branchNameList)

	return branchNameList, nil
}

func GetTagsInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	var tagsList []string
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/tags?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("tagsInfo, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					if organizationID == util.OpenLookeng {
						if !common.IsContainsLetters(mapValue) {
							tagsList = append(tagsList, mapValue)
						}
					} else {
						if common.IsContainSpecialChar(mapValue, 2) {
							tagsList = append(tagsList, mapValue)
						}
					}
				}
			}
		} else {
			logs.Error("Failed to get tags name, err: ", err, ",owner: ", owner, ",path: ", path)
			return tagsList, err
		}
	}

	if len(tagsList) > 0 {
		sort.Strings(tagsList)
	}

	if organizationID == util.OpenLookeng {
		if len(tagsList) > 1 {
			tagsList = tagsList[len(tagsList)-1:]
		}
	}

	return tagsList, nil
}
