package task

import (
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/toolbox"
)

//CheckOriCveTask Verify the original cve data
func CheckOriCveTask(oriCveCheck string, ch *chan bool) {
	logs.Info("校验原始cve数据 task start")
	CheckTask := toolbox.NewTask("CheckOriCve", oriCveCheck, CheckOriCve)
	err := CheckTask.Run()
	if err != nil {
		logs.Error("创建校验原始cve数据失败 ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("CheckOriCve", CheckTask)
	toolbox.StartTask()
	logs.Info("校验原始cve数据 task end")
	*ch <- true
}

//InitYamlTask Get yaml data source
func InitYamlTask(getYaml string, ch *chan bool) {
	logs.Info("获取yaml数据源 task start")
	YamlTask := toolbox.NewTask("GetYamlData", getYaml, GetYamlData)
	err := YamlTask.Run()
	if err != nil {
		logs.Error("创建获取yaml数据源任务失败 ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("GetYamlData", YamlTask)
	toolbox.StartTask()
	logs.Info("获取yaml数据源 task end")
	*ch <- true
}

//InitCveTask Generate cve original data into cve library
func InitCveTask(getCve string, ch *chan bool) {
	logs.Info("将cve原始数据生成cve库 task start")
	CveTask := toolbox.NewTask("ParamsCveOriginData", getCve, ParamsCveOriginData)
	err := CveTask.Run()
	if err != nil {
		logs.Error("创建Cve任务失败 ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("ParamsCveOriginData", CveTask)
	toolbox.StartTask()
	logs.Info("将cve原始数据生成cve库 task end")
	*ch <- true
}

// InitIssueTask Get the created issue data source
func InitIssueTask(getIssue string, ch *chan bool) {
	logs.Info("获取已经创建的issue数据源 task start")
	issueTask := toolbox.NewTask("GetIssueData", getIssue, GetIssueData)
	err := issueTask.Run()
	if err != nil {
		logs.Error("获取已经创建的issue数据源任务失败 ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("GetIssueData", issueTask)
	toolbox.StartTask()
	logs.Info("获取已经创建的issue数据源 task end")
	*ch <- true
}

// InitIssueToken Execute the token acquisition task to start
func InitIssueToken(issueOath string, ch *chan bool) {
	logs.Info("执行获取token任务开始")
	TokenTask := toolbox.NewTask("GetGiteeToken", issueOath, GetGiteeToken)
	err := TokenTask.Run()
	if err != nil {
		logs.Error("create Issue token task failed ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("GetGiteeToken", TokenTask)
	toolbox.StartTask()
	logs.Info("执行获取token任务结束")
	*ch <- true
}

// CreatTask  Execute the create issue task to start
func CreatTask(createIssue string, ch *chan bool) {
	logs.Info("执行创建issue任务开始")
	cIssueTask := toolbox.NewTask("CreateIssue", createIssue, CreateIssue)
	err := cIssueTask.Run()
	if err != nil {
		logs.Error("create Issue task failed ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("CreateIssue", cIssueTask)
	toolbox.StartTask()
	logs.Info("执行创建issue任务结束")
	*ch <- true
}

//GenSAExcelTask Execute issue to generate excel task start
func GenSAExcelTask(genExcel string, ch *chan bool) {
	logs.Info("执行issue生成excel任务开始")
	genExcelTask := toolbox.NewTask("GenExcelData", genExcel, GenExcelData)
	err := genExcelTask.Run()
	if err != nil {
		logs.Error("create genExcelTask failed ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("GenExcelData", genExcelTask)
	toolbox.StartTask()
	logs.Info("执行issue生成excel任务结束")
	*ch <- true
}

// Print logs to the console and delete redundant logs
func PrintLogTask(printLog string, ch *chan bool) {
	logs.Info("创建日志任务 task start")
	printLogTask := toolbox.NewTask("ProcLogData", printLog, ProcLogData)
	err := printLogTask.Run()
	if err != nil {
		logs.Error("创建日志任务失败 ,err:", err)
		*ch <- false
		return
	}
	toolbox.AddTask("ProcLogData", printLogTask)
	toolbox.StartTask()
	logs.Info("创建日志任务 task end")
	*ch <- true
}

//InitTask Timing task initialization
func InitTask() bool {
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error: file:conf/app.conf: ", err)
		return false
	}
	// Get the original yaml data
	ymalflag, errxs := BConfig.Int("crontab::ymalflag")
	if ymalflag == 1 && errxs == nil {
		getymal := BConfig.String("crontab::getymal")
		var yamch = make(chan bool)
		go InitYamlTask(getymal, &yamch)
		ok := <-yamch
		if !ok {
			logs.Error("Failed to get yaml data: init task")
			return false
		}
		close(yamch)
	}
	// Verify the original cve data
	oricveflag, errxs := BConfig.Int("crontab::oricveflag")
	if oricveflag == 1 && errxs == nil {
		oricvecheck := BConfig.String("crontab::oricvecheck")
		var checkch = make(chan bool)
		go CheckOriCveTask(oricvecheck, &checkch)
		ok := <-checkch
		if !ok {
			logs.Error("Filter cve data, whether it corresponds to the warehouse provided in yaml: init task")
			return false
		}
		close(checkch)
	}
	// Refresh gittoken regularly
	gittokenflag, errx := BConfig.Int("crontab::gittokenflag")
	if gittokenflag == 1 && errx == nil {
		issueoath := BConfig.String("crontab::issueoath")
		// Get token from environment variable
		gitToken := BConfig.String("gitee::git_token")
		if gitToken == "xxx" {
			var ch = make(chan bool)
			go InitIssueToken(issueoath, &ch)
			ok := <-ch
			if !ok {
				logs.Error("Failed to get gitee token: init task")
				return false
			}
			close(ch)
		}
	}
	// Get the created issue
	getissueflag, errxs := BConfig.Int("crontab::getissueflag")
	if getissueflag == 1 && errxs == nil {
		getissue := BConfig.String("crontab::getissue")
		var issuech = make(chan bool)
		go InitIssueTask(getissue, &issuech)
		ok := <-issuech
		if !ok {
			logs.Error("Failed to synchronize template on gitee: init task")
			return false
		}
		close(issuech)
	}
	// Generate cve vulnerability library
	cveflag, errxs := BConfig.Int("crontab::cveflag")
	if cveflag == 1 && errxs == nil {
		getcve := BConfig.String("crontab::getcve")
		var cvech = make(chan bool)
		go InitCveTask(getcve, &cvech)
		ok := <-cvech
		if !ok {
			logs.Error("Failed to initialize cve vulnerability library: init task")
			return false
		}
		close(cvech)
	}
	// Regularly output logs to the console
	printLogFlag, errxs := BConfig.Int("crontab::printlogflag")
	if printLogFlag == 1 && errxs == nil {
		printLog := BConfig.String("crontab::printlog")
		var logch = make(chan bool)
		go PrintLogTask(printLog, &logch)
		ok := <-logch
		if !ok {
			logs.Error("Failed to clean log: init task")
			return false
		}
		close(logch)
	}
	// Add issue
	taskFlag, errx := BConfig.Int("crontab::issueflag")
	if taskFlag == 1 && errx == nil {
		var ch = make(chan bool)
		createIssue := BConfig.String("crontab::createissue")
		go CreatTask(createIssue, &ch)
		ok := <-ch
		if !ok {
			logs.Error("Failed to create issue on gitee: init task", )
			return false
		}
		close(ch)
	} else {
		logs.Info("no task")
	}
	// Generate excel data from issue
	genexcelflag, errx := BConfig.Int("crontab::genexcelflag")
	if genexcelflag == 1 && errx == nil {
		var ch = make(chan bool)
		genExcel := BConfig.String("crontab::genexcel")
		go GenSAExcelTask(genExcel, &ch)
		ok := <-ch
		if !ok {
			logs.Error("Exporting a closed issue from gitee failed: init task")
			return false
		}
		close(ch)
	} else {
		logs.Info("no task")
	}
	return true
}
