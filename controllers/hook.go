package controllers

import (
	"bytes"
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/task"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	//GiteeUserAgent gitee hook request flag
	GiteeUserAgent = "git-oschina-hook"
	//XGiteeToken password or sign
	XGiteeToken = "X-Gitee-Token"
	//XGIteeEventType webhook event type
	XGIteeEventType = "X-Gitee-Event"
	//NoteHookType type of comment
	NoteHookType = "Note Hook"
	//PullReqHookType type of pull request
	PullReqHookType = "Merge Request Hook"
	//PushTagHookType type of push or tag
	PushTagHookType = "Tag Push Hook"
	//IssueHookType type of issue
	IssueHookType = "Issue Hook"
)

const (
	//CommentAnalysisCplTpl complete comment analysis reply template
	CommentAnalysisCplTpl = "@%v %v"
	//ReviewPrivateLettersTpl send private review letters template
	ReviewPrivateLettersTpl = `%s(%s)analysis is over,CVEScore:%v;OpenEulerScore:%v.Please review!`
	//ReviewRejectScore reply the review reject template
	ReviewRejectScore = `@%v you submit issue score audit failed(reject by %v),Please re-analyze and submit!`
	//ReviewApproveScore replay the review approve template
	ReviewApproveScore = `@%v you submit issue score audit success(approved by %v),You can proceed to the next step!`
	//CommentReviewTpl comment review template
	CommentReviewTpl = `%v The CVE score needs to be reviewed (the review instruction /approve&/reject means agreement and rejection).`
	//IssueRejectState issue state rejected
	IssueRejectState = "rejected"
	//IssueCloseState issue state closed
	IssueCloseState = "closed"
	//IssueProgressState issue  state progressing
	IssueProgressState = "progressing"
	//IssueOpenState issue state open
	IssueOpenState = "open"
	//AnalysisComplete issue analysis complete comment
	AnalysisComplete = "@%v 经过 cve-manager 解析, 已分析的内容如下表所示:\n"
	// Content review tips
	ContentReview = "%v 请完成以下操作:\n"
	// Not filling in the correct format
	IssueErroFormat = "%v 经过 cve-manager 解析, 填写openEuler评分未通过安全组成员审核需要再次在评论区提交评分,通过审核后才能关闭issue."
	// Remind the security group to review
	CommentReviewRemind = "%v 经过 cve-manager 解析 openEuler评分 已改变 需要您及时进行审核,以便maintainer进行后续操作."
	// Review private messages
	CommentPrivateReview = "%v 仓库的CVE和安全问题的ISSUE,需要您进行审核,CVE编号: %v"
	// Rating review failed
	CommentPrivateOpenEuler = "%v 仓库的CVE和安全问题的ISSUE, CVE编号: %v, 填写openEuler评分未通过安全组成员审核需要再次在评论区提交评分,通过审核后才能关闭issue."
	// Review reminder
	CommentReviewRemindMaintainer = "@%v 经过 cve-manager 解析 openEuler评分 已改变 需要等待安全组成员审核通过以后, 才能进行后续操作."
	CIssueType                    = "CVE和安全问题"
)

var comLock sync.Mutex

//HookEventControllers gitee hook callback
type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		c.Ctx.ResponseWriter.WriteHeader(406)
		c.Ctx.WriteString("Illegal incident, discarded")
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	c.Ctx.ResponseWriter.WriteHeader(200)
	c.Ctx.WriteString("Event received: " + eventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

//isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	//logs.Info(xToken)
	hookPwd := beego.AppConfig.String("hook::hookpwd")
	if xToken != hookPwd {
		logs.Error("hookPwd Err, xToken: ", xToken)
	}
	return
}

func (c *HookEventControllers) handleNoteDate() {
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	hookPwd := beego.AppConfig.String("hook::hookpwd")
	hookNote.Password = util.TrimString(hookNote.Password)
	hookPwd = util.TrimString(hookPwd)
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" && hookNote.Password == hookPwd {
		logs.Info(string(c.Ctx.Input.RequestBody))
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {
	logs.Info(string(c.Ctx.Input.RequestBody))
	issueHook := models.IssuePayload{}
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &issueHook)
	if err != nil {
		logs.Error(err)
		return
	}
	cuAccount := issueHook.Sender.Login
	if cuAccount != "" && len(cuAccount) > 1 {
		if cuAccount == "openeuler-ci-bot" {
			logs.Error("openeuler-ci-bot, Ignore this comment")
			return
		}
		if cuAccount == "opengauss-bot" {
			logs.Error("opengauss-bot, Ignore this comment")
			return
		}
		if cuAccount == "mindspore-ci-bot" || cuAccount == "mindspore_ci" {
			logs.Error("mindspore-ci-bot, Ignore this comment")
			return
		}
	}
	hookPwd := beego.AppConfig.String("hook::hookpwd")
	issueHook.Password = util.TrimString(issueHook.Password)
	if issueHook.Password != hookPwd {
		logs.Error("Hook callback pwd verification error, hook: ", issueHook)
		return
	}
	if issueHook.Action == "assign" {
		//Update the person in charge of the issue template
		issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid, IssueId: issueHook.Issue.Id}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if err != nil {
			logs.Error(err)
			return
		}
		issueTmp.Assignee = issueHook.Assignee.Login
		err = models.UpdateIssueTemplate(&issueTmp, "issue_assignee")
		if err != nil {
			logs.Error(err)
		}
	}
	if issueHook.Action == "state_change" {
		//handle issue state change
		err = handleIssueStateChange(&issueHook)
		if err != nil {
			logs.Error(err)
			return
		}
	}
	if issueHook.Action == "open" {
		issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid, IssueId: issueHook.Issue.Id}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if err == nil {
			logs.Error(err)
			return
		}
		err = gitAddIssueProc(&issueHook)
		if err != nil {
			logs.Error(err)
			return
		}
	}
	if issueHook.Action == "delete" {
		err = gitDelIssueProc(&issueHook)
		if err != nil {
			logs.Error(err)
			return
		}
	}
}

func closeIssuePrivilage(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix string, cveCenter *models.VulnCenter) bool {
	closePrBool := true
	if issueHook.Sender.UserName != "" && len(issueHook.Sender.UserName) > 1 {
		if isReviewer(util.TrimString(issueHook.Sender.UserName)) {
			if msg, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
				//send comment to issue
				issueTmp.IssueStatus = 1
				issueTmp.MtAuditFlag = 1
				issueTmp.IssueLabel = unFix
				issueTmp.StatusName = "open"
				_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
					*cveCenter, *issueTmp)
				if issueErr == nil {
					na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
					cc := fmt.Sprintf(ContentReview, "@"+issueHook.Sender.UserName) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v,", issueTmp.Repo, issueTmp.CveNum)
					taskhandler.SendPrivateLetters(token, content+msg, issueHook.Issue.Assignee.Login)
				}
			} else {
				issueTmp.StatusName = issueHook.Issue.StateName
				issueTmp.SaAuditFlag = 1
				issueTmp.MtAuditFlag = 1
				issueTmp.OpAuditFlag = 1
				issueTmp.Status = 3
				if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
					issueTmp.IssueStatus = 2
					cveCenter.IsExport = 3
					issueTmp.IssueLabel = fixed
				} else {
					issueTmp.IssueStatus = 6
					cveCenter.IsExport = 2
					issueTmp.IssueLabel = unFix
				}
			}
			closePrBool = false
		}
	}
	return closePrBool
}

func sigReviewSend(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix, assignee string, cveCenter *models.VulnCenter) {
	issueTmp.IssueStatus = 1
	issueTmp.Status = 1
	issueTmp.IssueLabel = unFix
	issueTmp.StatusName = "open"
	_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
		*cveCenter, *issueTmp)
	if issueErr == nil {
		if issueTmp.OpAuditFlag == 2 {
			cc := fmt.Sprintf(IssueErroFormat, assignee)
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
			content := fmt.Sprintf(CommentPrivateOpenEuler, issueTmp.Repo, issueTmp.CveNum)
			taskhandler.SendPrivateLetters(token, content, issueHook.Sender.UserName)
		} else if issueTmp.OpAuditFlag == 0 {
			list, revErr := models.GetSecurityReviewerList()
			if revErr == nil && len(list) > 0 {
				content := fmt.Sprintf(CommentPrivateReview, issueTmp.Repo, issueTmp.CveNum)
				ns := make([]string, len(list))
				for k, v := range list {
					ns[k] = "@" + v.NameSpace + " "
					taskhandler.SendPrivateLetters(token, content, v.NameSpace)
				}
				if len(ns) > 0 {
					cc := fmt.Sprintf(CommentReviewRemind, strings.Join(ns, ","))
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
				}
			} else {
				logs.Error(revErr)
			}
		}
	}
}

func getMaintainer(path, prSender, assignee string) string {
	maintainerList, mainOk := models.QueryRepoAllMaintainer(path)
	assList := []string{}
	if mainOk && len(maintainerList) > 0 {
		for _, v := range maintainerList {
			assList = append(assList, "@"+v.MemberName+" ")
		}
	}
	if prSender != "" && len(prSender) > 1 {
		isListBool := common.IsValueInList("@"+prSender+" ", assList)
		if !isListBool {
			assList = append(assList, "@"+prSender+" ")
		}
	}
	maintainerVaule := ""
	if len(assList) > 0 {
		maintainerVaule = strings.Join(assList, ",")
	} else {
		maintainerVaule = "@" + assignee + " "
	}
	return maintainerVaule
}

func gaussCloseIssueProc(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix, path string, cveCenter *models.VulnCenter) {
	if _, tb, ok := checkGaussIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		issueTmp.IssueStatus = 1
		issueTmp.IssueLabel = unFix
		issueTmp.StatusName = "open"
		_, issueErr := taskhandler.UpdateIssueToGit(token, owner, path,
			*cveCenter, *issueTmp)
		if issueErr == nil {
			na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
			cc := fmt.Sprintf(ContentReview, issueTmp.Assignee) + tb + na
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, token)
		}
	} else {
		issueTmp.IssueLabel = unFix
		issueTmp.StatusName = "open"
		issueTmp.Status = 1
		assignee := "@" + issueTmp.Assignee
		issuePrFlag := VerifyIssueAsPr(issueTmp, *cveCenter, false,
			assignee, issueHook.Sender.UserName)
		if issuePrFlag {
			//1. change issue status
			issueTmp.IssueStatus = 2
			//issueTmp.Status = 3
			cveCenter.IsExport = 3
			issueTmp.StatusName = issueHook.Issue.StateName
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
				issueTmp.IssueLabel = fixed
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
				issueTmp.IssueLabel = unFix
			}
		} else {
			issueTmp.IssueStatus = 1
			cveCenter.IsExport = 0
		}
	}
}

func sporeCloseIssueProc(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix, path string, cveCenter *models.VulnCenter) {
	if _, tb, ok := checkSporeIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		issueTmp.IssueStatus = 1
		issueTmp.IssueLabel = unFix
		issueTmp.StatusName = "open"
		_, issueErr := taskhandler.UpdateIssueToGit(token, owner, path,
			*cveCenter, *issueTmp)
		if issueErr == nil {
			na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
			cc := fmt.Sprintf(ContentReview, issueTmp.Assignee) + tb + na
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, token)
		}
	} else {
		issueTmp.IssueLabel = unFix
		issueTmp.StatusName = "open"
		issueTmp.Status = 1
		assignee := "@" + issueTmp.Assignee
		issuePrFlag := VerifyIssueAsPr(issueTmp, *cveCenter, false,
			assignee, issueHook.Sender.UserName)
		if issuePrFlag {
			//1. change issue status
			issueTmp.IssueStatus = 2
			//issueTmp.Status = 3
			cveCenter.IsExport = 3
			issueTmp.StatusName = issueHook.Issue.StateName
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
				issueTmp.IssueLabel = fixed
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
				issueTmp.IssueLabel = unFix
			}
		} else {
			issueTmp.IssueStatus = 1
			cveCenter.IsExport = 0
		}
	}
}

func closeIssueProc(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix string, cveCenter *models.VulnCenter) {
	closePrBool := true
	closeIssuePrFlag, closeOk := beego.AppConfig.Int64("cve::close_issue_privilege")
	if closeOk == nil && closeIssuePrFlag == 1 {
		closePrBool = closeIssuePrivilage(issueHook, issueTmp,
			token, owner, fixed, unFix, cveCenter)
	}
	if closePrBool {
		issueTmp.Status = 1
		cveCenter.IsExport = 0
		issueTmp.MtAuditFlag = 1
		assignee := getMaintainer(issueTmp.Repo, issueHook.Sender.UserName, issueTmp.Assignee)
		openScoreFlag := true
		if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
			issueTmp.OpAuditFlag != 1 && issueTmp.OpenEulerScore > 0 {
			//send comment to issue
			openScoreFlag = false
			sigReviewSend(issueHook, issueTmp, token, owner, fixed, unFix, assignee, cveCenter)
		}
		if openScoreFlag {
			if msg, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
				//send comment to issue
				issueTmp.IssueStatus = 1
				issueTmp.IssueLabel = unFix
				issueTmp.StatusName = "open"
				_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
					*cveCenter, *issueTmp)
				if issueErr == nil {
					na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
					cc := fmt.Sprintf(ContentReview, assignee) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v,", issueTmp.Repo, issueTmp.CveNum)
					taskhandler.SendPrivateLetters(token, content+msg, issueHook.Sender.UserName)
				}
			} else {
				//1. change issue status
				issueTmp.IssueStatus = 2
				//issueTmp.Status = 3
				cveCenter.IsExport = 3
				if issueTmp.MtAuditFlag == 0 {
					issueTmp.IssueStatus = 1
					issueTmp.Status = 1
					cveCenter.IsExport = 0
					issueTmp.IssueLabel = unFix
					issueTmp.StatusName = "open"
					_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
						*cveCenter, *issueTmp)
					if issueErr == nil {
						na := "\n**issue关闭前,请确认模板分析内容的准确性与完整性,确认无误后,请在评论区输入: /approve, 否则无法关闭当前issue.**"
						cc := fmt.Sprintf(ContentReview, assignee) + tb + na
						taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					}
					return
				}
				issueTmp.IssueLabel = unFix
				issueTmp.StatusName = "open"
				issueTmp.Status = 1
				issuePrFlag := VerifyIssueAsPr(issueTmp, *cveCenter, false,
					assignee, issueHook.Sender.UserName)
				if issuePrFlag {
					issueTmp.StatusName = issueHook.Issue.StateName
					issueTmp.Status = 3
					if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
						issueTmp.IssueStatus = 2
						cveCenter.IsExport = 3
						issueTmp.IssueLabel = fixed
					} else {
						issueTmp.IssueStatus = 6
						cveCenter.IsExport = 2
						issueTmp.IssueLabel = unFix
					}
				} else {
					issueTmp.IssueStatus = 1
					cveCenter.IsExport = 0
				}
			}
		}
	}
}

// Entry function for handling issue status
func handleIssueStateChange(issueHook *models.IssuePayload) error {
	unFix := beego.AppConfig.String("labelUnFix")
	fixed := beego.AppConfig.String("labelFixed")
	uNaffected := beego.AppConfig.String("labeUnaffected")
	gaussIssuePath := beego.AppConfig.String("opengauss::gauss_issue_path")
	issueId := issueHook.Issue.Id
	issueTmp := models.IssueTemplate{}
	issueTmp.IssueId = issueId
	issueTmp.IssueNum = issueHook.Iid
	if issueHook.Issue.Repository.Path != "" &&
		len(issueHook.Issue.Repository.Path) > 1 &&
		issueHook.Issue.Repository.Path != gaussIssuePath {
		issueTmp.OwnedComponent = issueHook.Issue.Repository.Path
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "owned_component", "issue_id")
		if issueErr != nil {
			return issueErr
		}
	} else {
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if issueErr != nil {
			return issueErr
		}
	}
	cveCenter := models.VulnCenter{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num")
	if cveErr != nil {
		return cveErr
	}
	path := issueTmp.Repo
	token := beego.AppConfig.String("gitee::git_token")
	owner := beego.AppConfig.String("gitee::owner")
	if cveCenter.OrganizationID == 2 {
		gaussOwner := beego.AppConfig.String("opengauss::gauss_owner")
		gitGaussToken := beego.AppConfig.String("opengauss::git_gauss_token")
		owner = gaussOwner
		token = gitGaussToken
		gaussIssuePath := beego.AppConfig.String("opengauss::gauss_issue_path")
		path = gaussIssuePath
	} else if cveCenter.OrganizationID == 3 {
		mindsporeOwner := beego.AppConfig.String("mindspore::mindspore_owner")
		gitMindsporeToken := beego.AppConfig.String("mindspore::git_mindspore_token")
		owner = mindsporeOwner
		token = gitMindsporeToken
		// Query the repo that needs to submit an issue
		cveList := strings.Split(cveCenter.CveVersion, ",")
		if len(cveList) > 0 {
			for _, cl := range cveList {
				ms := models.MindSporeYaml{PackageName: cveCenter.PackName, Version: cl}
				sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
				if ms.Id > 0 {
					path = ms.Repo
					break
				}
				logs.Info("GetMindSporeYaml, sporeErr: ", sporeErr)
			}
		}
	}
	issueTmp.StatusName = issueHook.Issue.StateName
	logs.Info("Initiating issue status modification, sponsor: @", issueHook.Sender.UserName, ", Modify status: ",
		issueHook.Issue.StateName, ", data: ", issueHook)
	switch issueHook.State {
	case IssueOpenState:
		issueTmp.Status = 1
		cveCenter.IsExport = 0
		checkFunc := checkIssueAnalysisComplete
		if cveCenter.OrganizationID == 2 {
			checkFunc = checkGaussIssueAnalysisComplete
		} else if cveCenter.OrganizationID == 3 {
			checkFunc = checkSporeIssueAnalysisComplete
		}
		_, _, ok := checkFunc(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = unFix
		//issueTmp.IssueStatus = 1
	case IssueProgressState:
		issueTmp.Status = 2
		cveCenter.IsExport = 0
		checkFunc := checkIssueAnalysisComplete
		if cveCenter.OrganizationID == 2 {
			checkFunc = checkGaussIssueAnalysisComplete
		} else if cveCenter.OrganizationID == 3 {
			checkFunc = checkSporeIssueAnalysisComplete
		}
		_, _, ok := checkFunc(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = unFix
	case IssueCloseState:
		if issueTmp.Status == 3 {
			// The issue has been closed and cannot be operated again
			logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
			return errors.New("The issue has been closed and cannot be operated again")
		}
		if cveCenter.OrganizationID == 3 {
			sporeCloseIssueProc(issueHook, &issueTmp, token, owner, fixed, unFix, path, &cveCenter)
		} else if cveCenter.OrganizationID == 2 {
			gaussCloseIssueProc(issueHook, &issueTmp, token, owner, fixed, unFix, path, &cveCenter)
		} else {
			closeIssueProc(issueHook, &issueTmp, token, owner, fixed, unFix, &cveCenter)
		}
	case IssueRejectState:
		issueTmp.Status = 4
		issueTmp.IssueStatus = 6
		cveCenter.IsExport = 2
		issueTmp.IssueLabel = uNaffected
	}
	updateBool := updateTempAndCenter(issueTmp, cveCenter, token, owner)
	if !updateBool {
		return errors.New("handle issue state hook appear error maybe some step fail")
	}
	return nil
}

// When the issue status is complete, verify whether the pr is associated
func VerifyIssueAsPr(issueTmp *models.IssueTemplate, cveCenter models.VulnCenter,
	effectFlag bool, assignee, prSend string) bool {
	sn := models.SecurityNotice{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum}
	secErr := sn.Read("cve_id", "cve_num")
	if secErr != nil {
		logs.Error("no data has been found, issueTmp: ", issueTmp)
		return true
	}
	affectBranchsxList := make([]string, 0)
	affectedBranchs := ""
	token := ""
	owner := ""
	path := ""
	prRepoSlice := []string{}
	if cveCenter.OrganizationID == 3 {
		affectedBranchs = beego.AppConfig.String("mindspore::mindspore_version")
		owner = beego.AppConfig.String("mindspore::mindspore_owner")
		token = beego.AppConfig.String("mindspore::git_mindspore_token")
		// Query the repo that needs to submit an issue
		cveList := strings.Split(cveCenter.CveVersion, ",")
		if len(cveList) > 0 {
			for _, cl := range cveList {
				ms := models.MindSporeYaml{PackageName: cveCenter.PackName, Version: cl}
				sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
				if ms.Id > 0 {
					path = ms.Repo
					break
				}
				logs.Info("GetMindSporeYaml, sporeErr: ", sporeErr)
			}
		}
		prRepoSlice = append(prRepoSlice, path)
		if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
			tmpTagList := make([]string, 0)
			affectProductSlice := strings.Split(sn.AffectProduct, "/")
			for _, tags := range affectProductSlice {
				mdbt := models.MindSporeBrandTags{PackageName: path, Tags: tags}
				mtErr := models.QueryMindSporeBrandTags(&mdbt, "PackageName", "Tags")
				if mtErr == nil {
					tmpTagList = append(tmpTagList, mdbt.Brand)
				}
			}
			//logs.Info("tmpTagList ===> ", tmpTagList)
			if len(tmpTagList) > 0 {
				sn.AffectProduct = strings.Join(tmpTagList, "/")
			} else {
				sn.AffectProduct = ""
			}
		}
	} else if cveCenter.OrganizationID == 2 {
		affectedBranchs = beego.AppConfig.String("opengauss::gauss_version")
		token = beego.AppConfig.String("opengauss::git_gauss_token")
		owner = beego.AppConfig.String("opengauss::gauss_owner")
		issuePath := beego.AppConfig.String("opengauss::gauss_issue_path")
		prRepo := beego.AppConfig.String("opengauss::pr_repo")
		prRepoSlice = strings.Split(prRepo, ",")
		prRepoSlice = append(prRepoSlice, issuePath)
		path = issuePath
	} else {
		affectedBranchs = beego.AppConfig.String("cve::affected_branchs")
		token = beego.AppConfig.String("gitee::git_token")
		owner = beego.AppConfig.String("gitee::owner")
		prRepoSlice = append(prRepoSlice, issueTmp.Repo)
		path = issueTmp.Repo
	}
	if affectedBranchs != "" && len(affectedBranchs) > 0 {
		affectBranchsxList = strings.Split(affectedBranchs, ",")
	}
	if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
		issueTmp.SaAuditFlag = 0
		affectProductList := strings.Split(sn.AffectProduct, "/")
		var branchMaps = make(map[string]bool)
		for _, brands := range affectProductList {
			brands = common.BranchVersionRep(brands)
			if len(affectBranchsxList) > 0 {
				for _, affectBranch := range affectBranchsxList {
					if affectBranch == brands {
						branchMaps[brands] = false
						for _, prRepo := range prRepoSlice {
							prList := getRepoIssueAllPR(affectBranch, token, owner, prRepo, *issueTmp)
							if len(prList) > 0 {
								branchMaps[brands] = true
								break
							}
						}
					}
				}
			}
		}
		brandStr := ""
		//logs.Info("branchMaps===> ", branchMaps)
		for brand, bv := range branchMaps {
			if !bv {
				logs.Error("brand: ", brand, ", pr is not related to issue, issueTmp: ", issueTmp)
				brandStr = brandStr + brand + "/"
			}
		}
		if brandStr != "" && len(brandStr) > 1 {
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, path,
				cveCenter, *issueTmp)
			if issueErr == nil {
				commentBody := assignee + "\n" +
					"关闭issue前,需要将受影响的分支在合并pr时关联上当前issue编号: #" + issueTmp.IssueNum + "\n" +
					"受影响分支: " + brandStr[:len(brandStr)-1] + "\n" +
					"具体操作参考: " + "https://gitee.com/help/articles/4142" + "\n"
				taskhandler.AddCommentToIssue(commentBody, issueTmp.IssueNum, owner, path, token)
				content := issueTmp.Repo + " 仓库的CVE和安全问题的ISSUE,CVE编号: " + issueTmp.CveNum +
					",关闭issue前,需要将受影响的分支在合并pr时关联上当前issue编号: #" + issueTmp.IssueNum +
					",受影响分支: " + brandStr[:len(brandStr)-1] +
					",具体操作参考: " + "https://gitee.com/help/articles/4142."
				taskhandler.SendPrivateLetters(token, content, prSend)
			}
			return false
		}
	} else {
		if effectFlag && issueTmp.SaAuditFlag == 0 {
			unaffectedBranchList := []string{}
			if issueTmp.AffectedVersion != "" && len(issueTmp.AffectedVersion) > 1 {
				unaffectedBranchList = paraAffectBrands(issueTmp.AffectedVersion)
			}
			branchStrs := ""
			if len(unaffectedBranchList) > 0 {
				for _, brands := range unaffectedBranchList {
					if len(affectBranchsxList) > 0 {
						for _, affectBranch := range affectBranchsxList {
							if affectBranch == brands {
								branchStrs = branchStrs + brands + "/"
							}
						}
					}
				}
			}
			if branchStrs != "" && len(branchStrs) > 1 {
				branchStrs = branchStrs[:len(branchStrs)-1]
				list, err := models.GetSecurityReviewerList()
				if err != nil {
					logs.Error(err)
					issueTmp.SaAuditFlag = 1
					return true
				}
				if len(list) == 0 {
					logs.Error("list is null, issueTemp: ", issueTmp)
					issueTmp.SaAuditFlag = 1
					return true
				}
				anName := []string{}
				content := fmt.Sprintf(CommentPrivateReview, issueTmp.Repo, issueTmp.CveNum)
				for _, v := range list {
					anName = append(anName, "@"+v.NameSpace+" ")
					taskhandler.SendPrivateLetters(token, content, v.NameSpace)
				}
				if len(anName) > 0 {
					_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
						cveCenter, *issueTmp)
					if issueErr == nil {
						assignee := strings.Join(anName, ",")
						commentBody := assignee + "\n" +
							"关闭issue前,请确认分支: " + branchStrs + ": 受影响/不受影响, 如受影响,请联系maintainer: @" +
							issueTmp.Assignee + ", **进行处理后, 或者按照模板格式在评论区填写内容, 最后记得在评论区回复: /approve ,才能正常关闭issue.**"
						taskhandler.AddCommentToIssue(commentBody, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					}
					return false
				} else {
					issueTmp.SaAuditFlag = 1
				}
			} else {
				issueTmp.SaAuditFlag = 1
			}
		}
	}
	return true
}

func paraAffectBrands(affectedVersion string) (unaffectedBranchList []string) {
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams != "受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams != "受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
			if len(brandList) == 1 {
				unaffectedBranchList = append(unaffectedBranchList, brandList[0])
			}
		}
	}
	return unaffectedBranchList
}

func paraAffectBrandBool(affectedVersion string) bool {
	unaffectedBranchList := make([]string, 0)
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "受影响" || prams == "不受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" || prams == "不受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func getPRRelatedBrandsAllIssue(token, owner, repo string, num int, issueNum string) bool {
	issueFlag := false
	url := fmt.Sprintf(`https://gitee.com/api/v5/repos/%s/%s/pulls/%v/issues`, owner, repo, num)
	pageSize := 20
	pageCount := 1
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error(err)
		return false
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("per_page", strconv.Itoa(pageSize))
	for {
		q.Del("page")
		q.Add("page", strconv.Itoa(pageCount))
		req.URL.RawQuery = q.Encode()
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			logs.Error(err)
			break
		}
		if resp.StatusCode == http.StatusOK {
			var il []models.HookIssue
			read, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				logs.Error(err)
				break
			}
			err = json.Unmarshal(read, &il)
			if err != nil {
				logs.Error(err)
				break
			}
			for _, v := range il {
				d, ok := isLegallyIssue(v)
				if ok {
					if issueNum == d.Number {
						issueFlag = true
						break
					}
				}
			}
			if len(il) < pageSize {
				break
			}
			pageCount++
		} else {
			resp.Body.Close()
			break
		}
	}
	return issueFlag
}

// Verify that the current issue meets the requirements
func isLegallyIssue(i models.HookIssue) (pri models.PullRequestIssue, ok bool) {
	if i.IssueType != CIssueType || (i.State != "closed" && i.State != "已完成") {
		return
	}
	tt := strings.Trim(i.Title, " ")
	regCveNum := regexp.MustCompile(`(?mi)CVE-[\d]{1,}-([\d]{1,})$`)
	sm := util.RegexpCveNumber.FindAllStringSubmatch(i.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		val := sm[0][1]
		tt = util.GetCveNumber(util.TrimString(val))
		if tt != "" && regCveNum.Match([]byte(tt)) {
			ok = true
		}
	}
	if ok {
		pri.Id = i.Id
		pri.Number = i.Number
		pri.CveNumber = tt
		pri.Repo = i.Repository.Path
	}
	return
}

// Get the pr associated with a single repo
func getRepoIssueAllPR(affectBranch, token, owner, repo string, isTemp models.IssueTemplate) (prList []models.PullRequestIssue) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/issues/%v/pull_requests", owner, isTemp.IssueNum)
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error("NewRequest, url: ", url, ",err: ", err)
		return
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("repo", repo)
	req.URL.RawQuery = q.Encode()
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		logs.Error("DefaultClient, url: ", url, ",err: ", err)
		return
	}
	if resp.StatusCode == http.StatusOK {
		issuePr := make([]map[string]interface{}, 0)
		read, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			logs.Error("ReadAll, url: ", url, ",err: ", err)
			return
		}
		resp.Body.Close()
		//logs.Info("getRepoIssueAllPR, body ===> ", read)
		err = json.Unmarshal(read, &issuePr)
		if err != nil {
			logs.Error("Unmarshal, url: ", url, ",err: ", err)
			return
		}
		logs.Info("issuePr: ", issuePr)
		for _, v := range issuePr {
			if _, ok := v["id"]; !ok {
				continue
			}
			pr := models.PullRequestIssue{}
			if v["state"].(string) == "merged" && v["mergeable"].(bool) {
				if v["base"].(map[string]interface{})["label"].(string) == affectBranch {
					if v["base"].(map[string]interface{})["repo"].(map[string]interface{})["path"] == repo {
						if v["base"].(map[string]interface{})["repo"].(map[string]interface{})["namespace"].(map[string]interface{})["path"] == owner {
							pr.Id = int64(v["id"].(float64))
							pr.Number = isTemp.IssueNum
							pr.CveNumber = isTemp.CveNum
							pr.Repo = repo
							prList = append(prList, pr)
						}
					}
				}
			}
		}
	} else {
		resp.Body.Close()
	}
	return
}

func isNormalCloseIssue(cveID int64, issueState int8) bool {
	if issueState == 1 {
		return false
	}
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		logs.Error(err)
		return false
	}
	if score.Ostatus != 3 {
		return false
	}
	return true
}

// update data
func updateTempAndCenter(issueTmp models.IssueTemplate, cveCenter models.VulnCenter, token, owner string) bool {
	appearErr := 0
	affectBrandFlag := false
	uNaffected := beego.AppConfig.String("labeUnaffected")
	labelFixed := beego.AppConfig.String("labelFixed")
	labelUnFix := beego.AppConfig.String("labelUnFix")
	path := ""
	if cveCenter.OrganizationID == 3 {
		// Query the repo that needs to submit an issue
		cveList := strings.Split(cveCenter.CveVersion, ",")
		if len(cveList) > 0 {
			for _, cl := range cveList {
				ms := models.MindSporeYaml{PackageName: cveCenter.PackName, Version: cl}
				sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
				if ms.Id > 0 {
					path = ms.Repo
					break
				}
				logs.Info("GetMindSporeYaml, sporeErr: ", sporeErr)
			}
		}
	} else if cveCenter.OrganizationID == 2 {
		path = beego.AppConfig.String("opengauss::gauss_issue_path")
	} else {
		path = issueTmp.Repo
	}
	sn := models.SecurityNotice{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum}
	snErr := sn.Read("cve_id", "cve_num")
	if snErr != nil {
		logs.Error("err: ", snErr)
	} else {
		if issueTmp.Status > 2 {
			affectBranchsxList := make([]string, 0)
			affectedBranchs := ""
			if cveCenter.OrganizationID == 3 {
				affectedBranchs = beego.AppConfig.String("mindspore::mindspore_version")
				if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
					tmpTagList := make([]string, 0)
					affectProductSlice := strings.Split(sn.AffectProduct, "/")
					for _, tags := range affectProductSlice {
						mdbt := models.MindSporeBrandTags{PackageName: path, Tags: tags}
						mtErr := models.QueryMindSporeBrandTags(&mdbt, "PackageName", "Tags")
						if mtErr == nil {
							tmpTagList = append(tmpTagList, mdbt.Brand)
						}
					}
					if len(tmpTagList) > 0 {
						sn.AffectProduct = strings.Join(tmpTagList, "/")
					} else {
						sn.AffectProduct = ""
					}
				}
			} else if cveCenter.OrganizationID == 2 {
				affectedBranchs = beego.AppConfig.String("opengauss::gauss_version")
			} else {
				affectedBranchs = beego.AppConfig.String("cve::affected_branchs")
			}
			if affectedBranchs != "" && len(affectedBranchs) > 0 {
				affectBranchsxList = strings.Split(affectedBranchs, ",")
			}
			if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
				affectProductList := strings.Split(sn.AffectProduct, "/")
				if len(affectProductList) > 0 {
					for _, brands := range affectProductList {
						if len(affectBranchsxList) > 0 {
							for _, affectBranch := range affectBranchsxList {
								if affectBranch == brands {
									affectBrandFlag = true
									break
								}
							}
						}
						if affectBrandFlag {
							break
						}
					}
				}
			}
		}
		switch issueTmp.IssueStatus {
		case 2:
			sn.AffectStatus = "Fixed"
		case 6:
			sn.AffectStatus = "UnAffected"
		default:
			sn.AffectStatus = "UnFixed"
		}
		err := sn.Update("affect_status")
		if err != nil {
			appearErr++
			logs.Error(err)
		}
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
		appearErr += 1
	}
	if affectBrandFlag {
		issueTmp.IssueLabel = labelFixed
	} else {
		if issueTmp.Status == 3 {
			issueTmp.IssueLabel = uNaffected
		} else {
			issueTmp.IssueLabel = labelUnFix
		}
	}
	tpErr := models.UpdateIssueTemplate(&issueTmp, "status", "issue_status",
		"status_name", "issue_label", "mt_audit_flag", "sa_audit_flag")
	if tpErr != nil {
		logs.Error(tpErr)
		appearErr += 1
	}
	update = UpdateIssueLabels(token, path, issueTmp.IssueNum, owner, issueTmp.IssueLabel)
	//update = ChangeIssueLabel(token, path, issueTmp.IssueNum, owner, issueTmp.IssueLabel)
	if !update {
		logs.Error("update gitee issue label  fail ,", issueTmp.IssueNum, issueTmp.IssueLabel)
		appearErr++
	}
	if appearErr > 0 {
		logs.Error("handle issue state hook appear error maybe some step "+
			"fail, appearErr: ", appearErr, ",issuetmp: ", issueTmp)
		return false
	}
	return true
}

func openEulerScoreReview(issueTmp *models.IssueTemplate, cuAccount, owner, token string) bool {
	approveFlag := true
	if isReviewer(cuAccount) {
		issueTmp.OpAuditFlag = 1
		approveFlag = false
		err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
		if err != nil {
			logs.Error(err)
		} else {
			err = models.UpdateIssueTemplate(issueTmp, "op_audit_flag")
			if err != nil {
				logs.Error(err)
			}
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewApproveScore, issueTmp.Assignee, cuAccount),
				issueTmp.IssueNum, owner, issueTmp.Repo, token)
		}
	} else {
		taskhandler.AddCommentToIssue(fmt.Sprintf(CommentReviewRemindMaintainer, cuAccount),
			issueTmp.IssueNum, owner, issueTmp.Repo, token)
	}
	return approveFlag
}

func gaussMaintainerApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed,
	unfixed, path string, cveCenter models.VulnCenter) {
	if _, tb, ok := checkGaussIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, token)
		return
	} else {
		if !isGaussReviewer(cuAccount) {
			logs.Error("Invalid user review, cuAccount: ", cuAccount)
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		issueTmp.Status = 1
		assignee := "@" + issueTmp.Assignee
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false,
			assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容, cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, path, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("Initiate an issue to close,issuetmp: ", issueTmp)
			} else {
				logs.Error("Issue closing operation failed, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			//issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			gaussIssuePath := beego.AppConfig.String("opengauss::gauss_issue_path")
			issueTmp.Repo = gaussIssuePath
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
	}
}

func sporeMaintainerApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed,
	unfixed, path string, cveCenter models.VulnCenter) {
	if _, tb, ok := checkSporeIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, token)
		return
	} else {
		if !isMindSporeReviewer(cuAccount) {
			logs.Error("Invalid user review, cuAccount: ", cuAccount)
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		issueTmp.Status = 1
		assignee := "@" + issueTmp.Assignee
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false, assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容, cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, path, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("Initiate an issue to close,issuetmp: ", issueTmp)
			} else {
				logs.Error("Issue closing operation failed, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			//issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
	}
}

func maintainerApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed, unfixed string) {
	if _, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
		return
	} else {
		issueTmp.MtAuditFlag = 1
		err := models.UpdateIssueTemplate(issueTmp, "mt_audit_flag")
		if err != nil {
			logs.Error(err)
			return
		}
		cveCenter := models.VulnCenter{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum}
		err = models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num")
		if err != nil {
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		assignee := getMaintainer(issueTmp.Repo, cuAccount, issueTmp.Assignee)
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false, assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容, cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("Initiate an issue to close, issuetmp: ", issueTmp)
			} else {
				logs.Error("Issue closing operation failed, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			//issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
		return
	}
}

func securityApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed, unfixed string) {
	if _, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
		return
	} else {
		if !isReviewer(cuAccount) {
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v maintainer具有通过/approve关闭issue, 请通过issue页面按钮关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			return
		}
		cveCenter := models.VulnCenter{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum}
		err := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num")
		if err != nil {
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		assignee := getMaintainer(issueTmp.Repo, cuAccount, issueTmp.Assignee)
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false, assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容,cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("Initiate an issue to close, issuetmp: ", issueTmp)
			} else {
				logs.Error("issue close operation failed, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
		return
	}
}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	// The default timeout for receiving hooks
	logs.Info("payload.Comment: ", payload.Comment, ", Number: ", payload.Issue.Number, "id: ", payload.Issue.Id)
	issueNum := payload.Issue.Number           //issue number string
	issueId := payload.Issue.Id                // issue id int64
	cBody := payload.Comment.Body              //Comment subject
	cuAccount := payload.Comment.User.UserName //gitee domain address
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	cmdClose := beego.AppConfig.DefaultString("closeCmd", "/close")
	cmdError := beego.AppConfig.DefaultString("errorCmd", "/error")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		logs.Error("Data has null values: issueNum, cuAccount, cBody: ", issueNum, cuAccount, cBody)
		return
	}
	// Ignore this comment
	if cuAccount != "" && len(cuAccount) > 1 {
		if cuAccount == "openeuler-ci-bot" {
			logs.Error("openeuler-ci-bot, Ignore this comment")
			return
		}
		if cuAccount == "opengauss-bot" {
			logs.Error("opengauss-bot, Ignore this comment")
			return
		}
		if cuAccount == "mindspore-ci-bot" || cuAccount == "mindspore_ci" {
			logs.Error("mindspore-ci-bot, Ignore this comment")
			return
		}
	}
	issueTmp := models.IssueTemplate{IssueNum: issueNum, IssueId: issueId}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
	if err != nil {
		logs.Error(err)
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	fixed := beego.AppConfig.String("labelFixed")
	unfixed := beego.AppConfig.String("labelUnFix")
	path := issueTmp.Repo
	vc := models.VulnCenter{CveId: issueTmp.CveId}
	vcErr := models.GetVulnCenterByCid(&vc, "CveId")
	if vcErr != nil {
		logs.Error("GetVulnCenterByCid, vcErr: ", vcErr, ",CveId: ", issueTmp.CveId)
		return
	}
	if vc.OrganizationID == 2 {
		owner = beego.AppConfig.String("opengauss::gauss_owner")
		accessToken = beego.AppConfig.String("opengauss::git_gauss_token")
		path = beego.AppConfig.String("opengauss::gauss_issue_path")
		cBody = strings.ReplaceAll(cBody, util.KwOpenGaussScore, util.KwOpenEulerScore)
	} else if vc.OrganizationID == 3 {
		owner = beego.AppConfig.String("mindspore::mindspore_owner")
		accessToken = beego.AppConfig.String("mindspore::git_mindspore_token")
		// Query the repo that needs to submit an issue
		cveList := strings.Split(vc.CveVersion, ",")
		if len(cveList) > 0 {
			for _, cl := range cveList {
				ms := models.MindSporeYaml{PackageName: vc.PackName, Version: cl}
				sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
				if ms.Id > 0 {
					path = ms.Repo
					break
				}
				logs.Info("GetMindSporeYaml, sporeErr: ", sporeErr)
			}
		}
		cBody = strings.ReplaceAll(cBody, util.KwMindSporeScore, util.KwOpenEulerScore)
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//Review rejected Add comment @Analyst
		if !isReviewer(cuAccount) {
			return
		}
		if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
			issueTmp.OpenEulerScore > 0 {
			err = changeOpenEulerScoreStatus(issueTmp.CveId, 2)
			if err != nil {
				logs.Error(err)
			}
			issueTmp.OpAuditFlag = 2
			err = models.UpdateIssueTemplate(&issueTmp, "op_audit_flag")
			if err != nil {
				logs.Error(err)
			}
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewRejectScore, issueTmp.Assignee, cuAccount),
				issueTmp.IssueNum, owner, path, accessToken)
		}
	} else if strings.HasPrefix(cBody, cmdApe) {
		if issueTmp.Status == 3 {
			// The issue has been closed and cannot be operated again
			logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
			return
		}
		if vc.OrganizationID == 3 {
			comLock.Lock()
			sporeMaintainerApprove(&issueTmp, cuAccount, owner, accessToken, fixed, unfixed, path, vc)
			comLock.Unlock()
		} else if vc.OrganizationID == 2 {
			comLock.Lock()
			gaussMaintainerApprove(&issueTmp, cuAccount, owner, accessToken, fixed, unfixed, path, vc)
			comLock.Unlock()
		} else {
			approveFlag := true
			if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
				issueTmp.OpAuditFlag != 1 && issueTmp.OpenEulerScore > 0 {
				//Approved to modify the rating status
				approveFlag = openEulerScoreReview(&issueTmp, cuAccount, owner, accessToken)
			}
			if approveFlag {
				mtAuditFlag := false
				// Analysis command belongs to the time period
				maintainerList, mainOk := models.QueryRepoAllMaintainer(issueTmp.Repo)
				if mainOk && len(maintainerList) > 0 {
					for _, v := range maintainerList {
						if util.TrimString(v.MemberName) == cuAccount {
							mtAuditFlag = true
							break
						}
					}
				}
				if mtAuditFlag {
					comLock.Lock()
					maintainerApprove(&issueTmp, cuAccount, owner, accessToken, fixed, unfixed)
					comLock.Unlock()
				} else {
					comLock.Lock()
					securityApprove(&issueTmp, cuAccount, owner, accessToken, fixed, unfixed)
					comLock.Unlock()
				}
			}
		}
	} else if strings.HasPrefix(cBody, cmdClose) {
		if !isReviewer(cuAccount) {
			return
		}
		//close issue
		closeFlag := false
		//call the gitee api to change issue status
		c := strings.TrimPrefix(cBody, cmdClose)
		c = strings.TrimSpace(c)
		issueTmp.ErrorDescription = c
		// No issue closing command is provided temporarily
		if closeFlag {
			success := CloseIssue(accessToken, issueTmp.Repo, issueNum, owner)
			if success {
				//update issue tpl
				err = models.UpdateIssueTemplate(&issueTmp, "error_description")
				if err != nil {
					logs.Error(err)
					return
				}
			}
		}
	} else if strings.HasPrefix(cBody, cmdError) {
		c := strings.TrimPrefix(cBody, cmdError)
		c = strings.TrimSpace(c)
		issueTmp.ErrorDescription = c
		issueTmp.UpdateTime = time.Now()
		//update issue tpl
		err = models.UpdateIssueTemplate(&issueTmp, "error_description", "update_time")
		if err != nil {
			logs.Error(err)
			return
		}
	} else {
		if payload.Issue.State == "closed" || payload.Issue.State == "rejected" ||
			payload.Issue.State == "已完成" || payload.Issue.State == "已拒绝" {
			logs.Error("Cannot edit comment, value: ", payload.Issue)
			return
		}
		cBody = strings.ReplaceAll(cBody, "：", ":")
		comLock.Lock()
		analysisComment(owner, accessToken, path, cuAccount, cBody, &payload, issueTmp, vc.OrganizationID)
		comLock.Unlock()
	}
}

func isReviewer(path string) bool {
	sr := models.SecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func isGaussReviewer(path string) bool {
	sr := models.OpenGaussSecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func isMindSporeReviewer(path string) bool {
	sr := models.MindSporeSecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func analysisComment(owner, accessToken, path string, cuAccount string, cBody string,
	payload *models.CommentPayload, issueTmp models.IssueTemplate, OrganizationID int8) {
	if issueTmp.Status == 3 {
		// The issue has been closed and cannot be operated again
		logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
		return
	}
	canVerfy := false
	issueTmp.MtAuditFlag = 1
	//is Analyst comment and content start with '/analysis'
	vMap := util.ExtractCommentAnalysisAllValue(cBody)
	if len(vMap) > 0 {
		canVerfy = true
		cols := make([]string, 0)
		for k, v := range vMap {
			switch k {
			case "cve_analysis":
				if v != "" && len(v) > 1 {
					issueTmp.CveAnalysis = common.DeletePreAndSufSpace(v)
					cols = append(cols, k)
				}
			case "principle_analysis":
				issueTmp.PrincipleAnalysis = v
				cols = append(cols, k)
			case "openeuler_score":
				fv, err := strconv.ParseFloat(v, 64)
				if err == nil && fv > 0 {
					if issueTmp.OpenEulerScore > 0 && issueTmp.OpenEulerScore != fv {
						issueTmp.OpAuditFlag = 0
						cols = append(cols, "op_audit_flag")
					}
					issueTmp.OpenEulerScore = fv
					cols = append(cols, k)
				}
			case "openeuler_vector":
				if v != "" && len(v) > 1 {
					issueTmp.OpenEulerVector = common.DeletePreAndSufSpace(v)
					cols = append(cols, k)
				}
			case "affected_version":
				if v != "" && len(v) > 1 {
					if paraAffectBrandBool(v) {
						issueTmp.AffectedVersion = v
						cols = append(cols, k)
					}
				}
			case "solution":
				issueTmp.Solution = v
				cols = append(cols, k)
			}
		}
		if len(cols) > 0 {
			cols = append(cols, "mt_audit_flag")
			err := models.UpdateIssueTemplate(&issueTmp, cols...)
			if err != nil {
				logs.Error(err)
			} else {
				if _, ok := vMap["openeuler_vector"]; ok {
					err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
					if err != nil {
						logs.Error(err)
					}
				}
				if _, ok := vMap["openeuler_score"]; ok {
					//更新分数到 score
					score, err := models.QueryIssueScore(issueTmp.CveId)
					if err != nil {
						logs.Error(err)
					} else {
						score.OpenEulerScore = issueTmp.OpenEulerScore
						score.Ostatus = 1
						err := models.UpdateScore(&score, "openeuler_score", "o_score_status")
						if err != nil {
							logs.Error(err)
						}
					}
				}
			}
			// update gitee issue
			commentUpdateIssue(issueTmp, owner, accessToken, path)
		}
		if _, ok := vMap["issue_package"]; ok {
			// handle comment package
			err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
			if err != nil {
				logs.Error(err)
			}
		}
	}
	if canVerfy {
		//Check whether the data is legal
		checkFunc := checkIssueAnalysisComplete
		if OrganizationID == 2 {
			checkFunc = checkGaussIssueAnalysisComplete
		} else if OrganizationID == 3 {
			checkFunc = checkSporeIssueAnalysisComplete
		}
		if msg, tb, ok := checkFunc(&issueTmp); !ok {
			//send comment to issue
			issueTmp.IssueStatus = 1
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			assignee := ""
			if cuAccount != "" && len(cuAccount) > 1 {
				assignee = cuAccount
			} else {
				assignee = issueTmp.Assignee
			}
			msg = fmt.Sprintf(CommentAnalysisCplTpl, assignee, msg)
			taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)
		} else {
			if OrganizationID == 3 {
				na := "\n**请确认分析内容的准确性, 确认无误后, 您可以进行后续步骤, 否则您可以继续分析.**"
				cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
				taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			} else if OrganizationID == 2 {
				na := "\n**请确认分析内容的准确性, 确认无误后, 您可以进行后续步骤, 否则您可以继续分析.**"
				cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
				taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			} else {
				//1. change issue status
				issueTmp.IssueStatus = 3
				//2. Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
				var na string
				if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.OpenEulerScore > 0 &&
					issueTmp.NVDScore > 0 && issueTmp.OpAuditFlag == 0 {
					na = "\n**因OpenEulerScore与NvdScore不一致,分析内容需审核,请等待安全组审核!**"
					//Notify the responsible person for review
					notifyAuditorReview(payload, issueTmp)
				} else {
					if issueTmp.MtAuditFlag == 0 {
						maintainerList, mainOk := models.QueryRepoAllMaintainer(issueTmp.Repo)
						assList := []string{}
						if mainOk && len(maintainerList) > 0 {
							for _, v := range maintainerList {
								assList = append(assList, "@"+v.MemberName+" ")
								content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v, "+
									"已经完成了模板填写,需要您对填写的内容进行审核,审核通过才能进行后续操作.", issueTmp.Repo, issueTmp.CveNum)
								taskhandler.SendPrivateLetters(accessToken, content, v.MemberName)
							}
						}
						assignee := ""
						if len(assList) > 0 {
							assignee = strings.Join(assList, ",")
						} else {
							assignee = "@" + issueTmp.Assignee
						}
						na = "\n**请确认模板分析内容的准确性与完整性, 确认无误后,请在评论区输入: /approve, 否则无法关闭当前issue.**"
						cc := fmt.Sprintf(ContentReview, assignee) + tb + na
						taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
					} else {
						na = "\n**请确认分析内容的准确性, 确认无误后, 您可以进行后续步骤, 否则您可以继续分析.**"
						cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
						taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
					}
					// change score status
					err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
					if err != nil {
						logs.Error(err)
					}
				}
			}
		}
		err := models.UpdateIssueTemplate(&issueTmp, "issue_status", "mt_audit_flag")
		if err != nil {
			logs.Error(err)
		}
	}
}

func notifyAuditorReview(payload *models.CommentPayload, issueTmp models.IssueTemplate) {
	//Notify the responsible person for review
	list, err := models.GetSecurityReviewerList()
	if err != nil {
		logs.Error(err)
		return
	}
	if len(list) == 0 {
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	content := fmt.Sprintf(ReviewPrivateLettersTpl,
		payload.Issue.Title, payload.Issue.HtmlUrl, issueTmp.NVDScore, issueTmp.OpenEulerScore)
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	ns := make([]string, len(list))
	for k, v := range list {
		ns[k] = "@" + v.NameSpace + " "
		taskhandler.SendPrivateLetters(accessToken, content, v.NameSpace)
		//add @comment
	}
	msg := fmt.Sprintf(CommentReviewTpl, strings.Join(ns, ","))
	taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)
}

func changeOpenEulerScoreStatus(cveID int64, status int8) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	score.Ostatus = status
	err = models.UpdateScore(&score, "o_score_status")
	return err
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`

	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
		return
	}
	tbContent[0] = "已分析"
	tbContent[1] = "影响性分析说明"
	tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affectx := range affectedVersionArry {
				affect := common.BranchVersionRep(affectx)
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
			return
		}
		if versionfFlag {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		} else {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "openEulerScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			msg = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
			ok = false
			return
		}
		tbContent[3] = "已分析"
		tbContent[4] = "openEulerScore"
		tbContent[5] = i.OpenEulerScore

		if i.OpenEulerVector == "" || len(i.OpenEulerVector) < 1 {
			msg = fmt.Sprintf("openEulerVector没有正确填写")
			ok = false
			return
		}
		tbContent[6] = "已分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkGaussIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`
	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
		return
	}
	tbContent[0] = "已分析"
	tbContent[1] = "影响性分析说明"
	tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
			return
		}
		if versionfFlag {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		} else {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "openGaussScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "openGaussVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			msg = fmt.Sprintf("openGaussScore没有填写或正确填写(0-10)")
			ok = false
			return
		}
		tbContent[3] = "已分析"
		tbContent[4] = "openGaussScore"
		tbContent[5] = i.OpenEulerScore

		if i.OpenEulerVector == "" || len(i.OpenEulerVector) < 1 {
			msg = fmt.Sprintf("openGaussVector没有正确填写")
			ok = false
			return
		}
		tbContent[6] = "已分析"
		tbContent[7] = "openGaussVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkSporeIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`
	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
		return
	}
	tbContent[0] = "已分析"
	tbContent[1] = "影响性分析说明"
	tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
			return
		}
		if versionfFlag {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		} else {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "MindSporeScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "MindSporeVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			msg = fmt.Sprintf("MindSporeScore没有填写或正确填写(0-10)")
			ok = false
			return
		}
		tbContent[3] = "已分析"
		tbContent[4] = "MindSporeScore"
		tbContent[5] = i.OpenEulerScore
		if i.OpenEulerVector == "" || len(i.OpenEulerVector) < 1 {
			msg = fmt.Sprintf("MindSporeVector没有正确填写")
			ok = false
			return
		}
		tbContent[6] = "已分析"
		tbContent[7] = "MindSporeVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkIssueClosedAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`
	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		tbContent[0] = "待分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
	} else {
		tbContent[0] = "已分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	}
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affectx := range affectedVersionArry {
				affect := common.BranchVersionRep(affectx)
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
		} else {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "openEulerScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			tbContent[3] = "待分析"
			tbContent[4] = "openEulerScore"
			tbContent[5] = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
			msg = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
			ok = false
		} else {
			tbContent[3] = "已分析"
			tbContent[4] = "openEulerScore"
			tbContent[5] = i.OpenEulerScore
		}
		if util.TrimString(i.OpenEulerVector) == "" || len(util.TrimString(i.OpenEulerVector)) < 1 {
			tbContent[6] = "待分析"
			tbContent[7] = "openEulerVector"
			tbContent[8] = fmt.Sprintf("openEulerVector没有正确填写")
			msg = fmt.Sprintf("openEulerVector没有正确填写")
			ok = false
		} else {
			tbContent[6] = "已分析"
			tbContent[7] = "openEulerVector"
			tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
		}
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkGaussIssueClosedAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`
	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		tbContent[0] = "待分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
	} else {
		tbContent[0] = "已分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	}
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
		} else {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "openGaussScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "openGaussVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			tbContent[3] = "待分析"
			tbContent[4] = "openGaussScore"
			tbContent[5] = fmt.Sprintf("openGaussScore没有填写或正确填写(0-10)")
			msg = fmt.Sprintf("openGaussScore没有填写或正确填写(0-10)")
			ok = false
		} else {
			tbContent[3] = "已分析"
			tbContent[4] = "openGaussScore"
			tbContent[5] = i.OpenEulerScore
		}
		if util.TrimString(i.OpenEulerVector) == "" || len(util.TrimString(i.OpenEulerVector)) < 1 {
			tbContent[6] = "待分析"
			tbContent[7] = "openGaussVector"
			tbContent[8] = fmt.Sprintf("openGaussVector没有正确填写")
			msg = fmt.Sprintf("openGaussVector没有正确填写")
			ok = false
		} else {
			tbContent[6] = "已分析"
			tbContent[7] = "openGaussVector"
			tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
		}
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkSporeIssueClosedAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`
	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		tbContent[0] = "待分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
	} else {
		tbContent[0] = "已分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	}
	affectedVersionFlag := 1
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						if versionArry[1] == "受影响" {
							affectedVersionFlag = 2
						}
						continue
					} else {
						affectedVersionFlag = 3
						versionfFlag = false
						break
					}
				} else {
					affectedVersionFlag = 3
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
		} else {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	if affectedVersionFlag == 1 {
		tbContent[3] = "已分析"
		tbContent[4] = "MindSporeScore"
		tbContent[5] = i.OpenEulerScore
		tbContent[6] = "已分析"
		tbContent[7] = "MindSporeVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	} else {
		if i.OpenEulerScore == 0.0 {
			tbContent[3] = "待分析"
			tbContent[4] = "MindSporeScore"
			tbContent[5] = fmt.Sprintf("MindSporeScore没有填写或正确填写(0-10)")
			msg = fmt.Sprintf("MindSporeScore没有填写或正确填写(0-10)")
			ok = false
		} else {
			tbContent[3] = "已分析"
			tbContent[4] = "MindSporeScore"
			tbContent[5] = i.OpenEulerScore
		}
		if util.TrimString(i.OpenEulerVector) == "" || len(util.TrimString(i.OpenEulerVector)) < 1 {
			tbContent[6] = "待分析"
			tbContent[7] = "MindSporeVector"
			tbContent[8] = fmt.Sprintf("MindSporeVector没有正确填写")
			msg = fmt.Sprintf("MindSporeVector没有正确填写")
			ok = false
		} else {
			tbContent[6] = "已分析"
			tbContent[7] = "MindSporeVector"
			tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
		}
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate, owner, accessToken, path string) {
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveID int64) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	if util.RegexpVectorV2.Match([]byte(vct)) {
		//update v2 vector
		avv := util.ReadVMValueV2(vMap["AV"])
		if avv != "" {
			score.OaccessVector = avv
			upFields = append(upFields, "o_access_vector")
		}
		acv := util.ReadVMValueV2(vMap["AC"])
		if acv != "" {
			score.OaccessComplexity = acv
			upFields = append(upFields, "o_access_complexity")
		}
		au := util.ReadVMValueV2(vMap["Au"])
		if au != "" {
			score.Oauthentication = au
			upFields = append(upFields, "o_authentication")
		}
		cv := util.ReadVMValueV2(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValueV2(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValueV2(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	} else {
		//update v3 vector
		avv := util.ReadVMValue(vMap["AV"])
		if avv != "" {
			score.OattackVector = avv
			upFields = append(upFields, "o_attack_vector")
		}
		acv := util.ReadVMValue(vMap["AC"])
		if acv != "" {
			score.OattackComplexity = acv
			upFields = append(upFields, "o_attack_complexity")
		}
		prv := util.ReadVMValue(vMap["PR"])
		if prv != "" {
			score.OprivilegeRequired = prv
			upFields = append(upFields, "o_privilege_required")
		}
		uiv := util.ReadVMValue(vMap["UI"])
		if uiv != "" {
			score.OuserInteraction = uiv
			upFields = append(upFields, "o_user_interaction")
		}
		sv := util.ReadVMValue(vMap["S"])
		if sv != "" {
			score.Oscope = sv
			upFields = append(upFields, "o_scope")
		}
		cv := util.ReadVMValue(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValue(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValue(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	}
	if len(upFields) > 0 {
		//Perform update
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveID int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveID)
	if err != nil {
		return err
	}
	return nil
}

//CloseIssue close gitee issue
func CloseIssue(token, repo, issueNum, owner string) bool {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/issues/%s", owner, issueNum)
	param := struct {
		AccessToken string `json:"access_token"`
		Repo        string `json:"repo"`
		State       string `json:"state"`
	}{token, repo, "closed"}
	pj, err := json.Marshal(&param)
	if err != nil {
		logs.Error(err)
		return false
	}
	return UpdateGiteIssue(url, pj)
}

//UpdateGiteIssue update gitee issue
func UpdateGiteIssue(url string, param []byte) bool {
	read := bytes.NewReader(param)
	req, err := http.NewRequest(http.MethodPatch, url, read)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer req.Body.Close()
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		return true
	}
	return false
}

func UpdateIssueLabels(token, repo, issueNum, owner, label string) bool {
	labelStr := label
	labelSlice := strings.Split(label, ",")
	if len(labelSlice) > 0 {
		laSlice := []string{}
		for _, la := range labelSlice {
			laSlice = append(laSlice, fmt.Sprintf("\"%v\"", la))
		}
		if len(laSlice) > 0 {
			labelStr = strings.Join(laSlice, ",")
		}
	}
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/%v/issues/%v/labels?access_token=%v", owner, repo, issueNum, token)
	reqBody := fmt.Sprintf("[%v]", labelStr)
	logs.Info("UpdateIssueLabels, reqBody: ", reqBody)
	resp, err := util.HTTPPut(url, reqBody)
	if err != nil {
		logs.Error("UpdateIssueLabels, Failed to update label, url: ", url, ", err: ", err)
		return false
	}
	if _, ok := resp[0]["id"]; !ok {
		logs.Error("UpdateIssueLabels, Failed to update label, err: ", ok, ", url: ", url)
		return false
	}
	return true
}

func AddGitIssue(issueHook *models.IssuePayload, desc, product string) {
	issueTitle := util.TrimString(issueHook.Title)
	issueType := util.TrimString(issueHook.Issue.TypeName)
	issueNumber := util.TrimString(issueHook.Issue.Number)
	issueState := util.TrimString(issueHook.Issue.State)
	issueZhState := util.TrimString(issueHook.Issue.StateName)
	repoPath := util.TrimString(issueHook.Repository.Path)
	nameSpace := util.TrimString(issueHook.Repository.NameSpace)
	organizationID := int8(1)
	organizationID = taskhandler.GetOrganizationId(nameSpace)
	if issueType == CIssueType || strings.HasPrefix(issueTitle, "CVE") {
		item := models.GiteOriginIssue{IssueId: issueHook.Issue.Id, Url: issueHook.Issue.HtmlUrl,
			Number: issueNumber, State: issueState, Title: issueTitle,
			IssueType: issueType, SecurityHole: true,
			IssueCreateAt: issueHook.Issue.CreateAt, IssueUpdateAt: issueHook.Issue.UpdateAt,
			IssueFinishAt: issueHook.Issue.FinishedAt, IssueCreate: issueHook.Issue.User.Login,
			IssueAssignee: issueHook.Assignee.Login, RepoPath: repoPath,
			RepoUrl: issueHook.Repository.Url, InfProduct: product,
			RepoDesc: desc, IssueState: issueZhState, Owner: nameSpace, OrganizationID: organizationID}
		//vt := util.TrimString(v.Title)
		if strings.HasPrefix(issueTitle, "CVE") {
			item.CveNumber = issueTitle
		} else if issueHook.Issue.Body != "" {
			//通过正则表达式去body中截取 稍后完善
			sm := util.RegexpCveNumber.FindAllStringSubmatch(issueHook.Issue.Body, -1)
			if len(sm) > 0 && len(sm[0]) > 0 {
				item.CveNumber = util.TrimString(sm[0][1])
			}
		}
		//vb := util.TrimString(v.Body)
		vb := strings.ReplaceAll(issueHook.Issue.Body, "：", ":")
		item.Body = vb
		issueTmp := models.IssueTemplate{}
		issueTmp.CveNum = item.CveNumber
		issueTmp.OwnedComponent = repoPath
		issueTmp.IssueId = issueHook.Issue.Id
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "CveNum", "OwnedComponent", "IssueId")
		if issueErr == nil {
			item.IssueExistTpl = true
		} else {
			item.IssueExistTpl = false
		}
		err := item.InsertOrUpdate(2)
		if err != nil {
			logs.Error("insert or update issue fail:", err)
		}
	}
}

func DelOrgIssue(issueHook *models.IssuePayload) {
	issueTitle := util.TrimString(issueHook.Title)
	issueType := util.TrimString(issueHook.Issue.TypeName)
	issueNumber := util.TrimString(issueHook.Issue.Number)
	issueState := util.TrimString(issueHook.Issue.State)
	issueZhState := util.TrimString(issueHook.Issue.StateName)
	repoPath := util.TrimString(issueHook.Repository.Path)
	nameSpace := util.TrimString(issueHook.Repository.NameSpace)
	organizationID := int8(1)
	organizationID = taskhandler.GetOrganizationId(nameSpace)
	if issueType == CIssueType || strings.HasPrefix(issueTitle, "CVE") {
		item := models.GiteOriginIssue{IssueId: issueHook.Issue.Id, Url: issueHook.Issue.HtmlUrl,
			Number: issueNumber, State: issueState, Title: issueTitle,
			IssueType: issueType, SecurityHole: true,
			IssueCreateAt: issueHook.Issue.CreateAt, IssueUpdateAt: issueHook.Issue.UpdateAt,
			IssueFinishAt: issueHook.Issue.FinishedAt, IssueCreate: issueHook.Issue.User.Login,
			IssueAssignee: "", RepoPath: repoPath,
			RepoUrl: issueHook.Repository.Url, InfProduct: "",
			RepoDesc: "", IssueState: issueZhState, Owner: nameSpace, OrganizationID: organizationID}
		if strings.HasPrefix(issueTitle, "CVE") {
			item.CveNumber = issueTitle
		} else if issueHook.Issue.Body != "" {
			//通过正则表达式去body中截取 稍后完善
			sm := util.RegexpCveNumber.FindAllStringSubmatch(issueHook.Issue.Body, -1)
			if len(sm) > 0 && len(sm[0]) > 0 {
				item.CveNumber = util.TrimString(sm[0][1])
			}
		}
		err := item.Detlete()
		if err != nil {
			logs.Error("Failed to delete issue:", err)
		}
		issueTmp := models.IssueTemplate{}
		issueTmp.IssueId = issueHook.Issue.Id
		issueTmp.IssueNum = issueNumber
		issueTmp.OwnedComponent = repoPath
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "owned_component", "issue_id")
		if issueErr != nil {
			return
		}
		issueTmp.Status = 6
		issueTmp.IssueStatus = 6
		issueTmp.StatusName = "已删除"
		tpErr := models.UpdateIssueTemplate(&issueTmp, "status", "issue_status",
			"status_name")
		if tpErr != nil {
			logs.Error(tpErr)
		}
		cveCenter := models.VulnCenter{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum, PackName: issueTmp.OwnedComponent}
		cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
		if cveErr != nil {
			return
		}
		cveCenter.Status = 7
		update := models.UpdateVulnCenter(&cveCenter, "cve_status")
		if !update {
			logs.Error("update vulnCenter fail ")
		}
	}
}

// Entry function for handling issue status
func gitAddIssueProc(issueHook *models.IssuePayload) error {
	token := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	path := issueHook.Repository.Path
	// The amount of data processed at a time
	prcNum, err := beego.AppConfig.Int("crontab::prcnum")
	if err != nil {
		logs.Error("crontab::prcnum, error:  ", err)
		return errors.New("value is nil")
	}
	// How many days have been processed to date data
	days, ok := beego.AppConfig.Int("crontab::days")
	if ok != nil {
		logs.Error("crontab::days, err:", err)
		return ok
	}
	// openeuler Number start value
	cveRef := beego.AppConfig.String("cve::cveref")
	openeulerNum, ok := beego.AppConfig.Int("cve::openeulernum")
	if ok != nil {
		logs.Error("cve::openeulernum, err:", err)
		return ok
	}
	// Determine whether the issue has been created
	product, err := taskhandler.GetInfProduct(token, owner, path)
	if err != nil {
		logs.Error("GetInfProduct, err: ", err)
	}
	desc := taskhandler.GetRepoDescription(path)
	AddGitIssue(issueHook, desc, product)
	// Compatible with created issue data
	oki, err := taskhandler.GetCveIssueData(prcNum, days, openeulerNum, cveRef, owner)
	if !oki {
		logs.Error("ProcCveOriginData, GetCveIssueData, err: ", err)
	}
	createErr := task.CreateIssue()
	if createErr != nil {
		logs.Error("Failed to synchronize issue data of cve, err: ", createErr)
	}
	comErr := AddIssueComment(token, owner, path, issueHook.Issue.Number,
		issueHook.Issue.User.Login, issueHook.Issue.Id)
	logs.Info("CreateIssueToGit, Issue comment creation result, err: ", comErr)
	return createErr
}

func AddIssueComment(token, owner, path, issueNum, assignee string, issueId int64) error {
	// Create the first comment
	branchList := []string{}
	errBrands := errors.New("")
	issueTmp := models.IssueTemplate{}
	issueTmp.IssueId = issueId
	issueTmp.IssueNum = issueNum
	issueTmp.OwnedComponent = path
	issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "owned_component", "issue_id")
	if issueErr != nil {
		logs.Error("GetIssueTemplateByColName, err: ", issueErr, ", issue: ", issueTmp)
		return issueErr
	}
	cveCenter := models.VulnCenter{CveId: issueTmp.CveId, CveNum: issueTmp.CveNum, PackName: path}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		return cveErr
	}
	if cveCenter.OrganizationID == 3 {
		owner = beego.AppConfig.String("mindspore::mindspore_owner")
		token = beego.AppConfig.String("mindspore::git_mindspore_token")
		// Query the repo that needs to submit an issue
		cveList := strings.Split(cveCenter.CveVersion, ",")
		if len(cveList) > 0 {
			for _, cl := range cveList {
				ms := models.MindSporeYaml{PackageName: cveCenter.PackName, Version: cl}
				sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
				if ms.Id > 0 {
					path = ms.Repo
					break
				}
				logs.Info("GetMindSporeYaml, sporeErr: ", sporeErr)
			}
		}
		// Get branch information
		branchList = taskhandler.CreateBrandAndTags(token, owner, path, cveCenter.OrganizationID)
		if branchList == nil || len(branchList) == 0 {
			logs.Error("mindspore GetBranchesInfo, Failed to obtain the branch information of the repo, ", path, ", err: ", errBrands)
			return errors.New("Failed to obtain branch information")
		}
	} else if cveCenter.OrganizationID == 2 {
		owner = beego.AppConfig.String("opengauss::gauss_owner")
		token = beego.AppConfig.String("opengauss::git_gauss_token")
		path = beego.AppConfig.String("opengauss::openGauss-server")
		// Get branch information
		branchList, errBrands = taskhandler.GetBranchesInfo(token, owner, path, cveCenter.OrganizationID)
		if branchList == nil || len(branchList) == 0 {
			logs.Error("Gauss GetBranchesInfo, Failed to obtain the branch information of the repo, ", path, ", err: ", errBrands)
			return errors.New("Failed to obtain branch information")
		}
	} else {
		// Get branch information
		branchList, errBrands = taskhandler.GetBranchesInfo(token, owner, path, cveCenter.OrganizationID)
		if branchList == nil || len(branchList) == 0 {
			logs.Error("Euler GetBranchesInfo, Failed to obtain the branch information of the repo, ", path, ", err: ", errBrands)
			return errors.New("Failed to obtain branch information")
		}
	}

	// Create issue comment
	affectedVersion := ""
	if len(branchList) > 0 {
		for i, brand := range branchList {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brandx := ""
			if cveCenter.OrganizationID == 1 {
				brandx = common.BranchVersionRep(brand)
				brandx = taskhandler.OrgRepoParams(cveCenter.PackName, brandx)
			} else {
				brandx = brand
			}
			affectedVersion = affectedVersion + strconv.Itoa(i+1) + "." + brandx + ":\n"
		}
	} else {
		affectedVersion = affectedVersion + "\n"
	}
	errx := taskhandler.CreateIssueComment(token, owner, path, assignee,
		cveCenter, issueNum, affectedVersion)
	return errx
}

func gitDelIssueProc(issueHook *models.IssuePayload) error {
	DelOrgIssue(issueHook)
	return nil
}
