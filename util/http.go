package util

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

//RequestInfo http request information
type RequestInfo struct {
	URL           string
	Data          map[string]string //The data to be transmitted by the post, the key value must be both string
	DataInterface map[string]interface{}
}

//HTTPPatch patch request
func HTTPPatch(url string, requestBody string) (map[string]interface{}, error) {
	req, err := http.NewRequest("PATCH", url, bytes.NewBuffer([]byte(requestBody)))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("Post request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Patch request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil {
		logs.Error("post 返回失败, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("post 返回成功!, body: ", string(body))
	var iss map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//HTTPPost post request
func HTTPPost(url string, requestBody string) (map[string]interface{}, error) {
	req, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(requestBody)))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("Post request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Post request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil {
		logs.Error("post 返回失败, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("post 返回成功!, body: ", string(body))
	var iss map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//HTTPPost1 post request
func HTTPPost1(url string, requestBody string) ([]map[string]interface{}, error) {
	req, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(requestBody)))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("Post request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Post request 失败, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil {
		logs.Error("post 返回失败, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("post 返回成功!, body: ", string(body))
	var iss []map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//PostURLEncoded request params encode
func PostURLEncoded(this RequestInfo) ([]byte, error) {
	client := &http.Client{}
	//post data to be submitted
	DataURLVal := url.Values{}
	for key, val := range this.Data {
		DataURLVal.Add(key, val)
	}
	req, err := http.NewRequest("POST", this.URL, strings.NewReader(DataURLVal.Encode()))
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	//Camouflage head
	req.Header.Set("Accept", "application/json")
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	//Submit request
	resp, err := client.Do(req)
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	defer resp.Body.Close()
	//Read return value
	result, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	logs.Info(string(result))
	return result, nil
}

//HTTPGet get request
func HTTPGet(url string) ([]map[string]interface{}, error) {
	resp, err := http.Get(url)
	if err != nil {
		logs.Error("get error, url:", url, "error: ", err)
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("url:", url, ",err: ", err)
		return nil, err
	}
	logs.Info("body: \n", string(body), "url: ", url)
	var col []map[string]interface{}
	err = json.Unmarshal(body, &col)
	if err != nil {
		logs.Error(err)
	}
	return col, nil
}

//HTTPGetCom common get request
func HTTPGetCom(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		logs.Error("get error, url:", url, "error: ", err)
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	logs.Info("body: \n", string(body), "url: ", url)
	return body, nil
}
