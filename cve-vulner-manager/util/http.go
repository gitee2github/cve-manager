package util

import (
	"bytes"
	"cvevulner/common"
	"encoding/json"
	"fmt"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

//RequestInfo http request information
type RequestInfo struct {
	URL           string
	Data          map[string]string //The data to be transmitted by the post, the key value must be both string
	DataInterface map[string]interface{}
}

//HTTPPatch patch request
func HTTPPatch(url string, requestBody string) (map[string]interface{}, error) {
	req, err := http.NewRequest("PATCH", url, bytes.NewBuffer([]byte(requestBody)))
	defer common.Catchs()
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("PATCH request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Patch request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil || body == nil {
		logs.Error("PATCH failed, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("PATCH successed!, body: ", string(body))
	var iss map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//HTTPPost post request
func HTTPPost(url string, requestBody string) (map[string]interface{}, error) {
	req, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(requestBody)))
	defer common.Catchs()
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("Post request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Post request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil || body == nil {
		logs.Error("post failed, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("post successed!, body: ", string(body))
	var iss map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//HTTPPost1 post request
func HTTPPost1(url string, requestBody string) ([]map[string]interface{}, error) {
	req, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(requestBody)))
	defer common.Catchs()
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("Post request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Post request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil || body == nil {
		logs.Error("post failed, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("post successed!, body: ", string(body))
	var iss []map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//PostURLEncoded request params encode
func PostURLEncoded(this RequestInfo) ([]byte, error) {
	client := &http.Client{}
	//post data to be submitted
	DataURLVal := url.Values{}
	for key, val := range this.Data {
		DataURLVal.Add(key, val)
	}
	req, err := http.NewRequest("POST", this.URL, strings.NewReader(DataURLVal.Encode()))
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	//Camouflage head
	req.Header.Set("Accept", "application/json")
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	//Submit request
	resp, err := client.Do(req)
	if err != nil {
		logs.Error(err)
		return nil, err
	}
	defer resp.Body.Close()
	//Read return value
	result, err := ioutil.ReadAll(resp.Body)
	if err != nil || result == nil {
		logs.Error(err)
		return nil, err
	}
	logs.Info(string(result))
	return result, nil
}

//HTTPGet get request
func HTTPGet(url string) ([]map[string]interface{}, error) {
	resp, err := http.Get(url)
	if err != nil {
		logs.Error("get error, url:", url, "error: ", err)
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error("url:", url, ",err: ", err)
		return nil, err
	}
	logs.Info("body: \n", string(body), "url: ", url)
	var col []map[string]interface{}
	err = json.Unmarshal(body, &col)
	if err != nil {
		logs.Error("HTTPGet,err: ", err, "url: ", url)
	}
	return col, nil
}

//HTTPGetCom common get request
func HTTPGetCom(urls string) ([]byte, error) {
	resp, err := http.Get(urls)
	if err != nil {
		logs.Error("get error, url:", urls, "error: ", err)
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error(err)
		return nil, err
	}
	logs.Info("body: \n", string(body), "url: ", urls)
	return body, nil
}

func HTTPDelCom(url, requestBody string) ([]map[string]interface{}, error) {
	req, err := http.NewRequest("DELETE", url, bytes.NewBuffer([]byte(requestBody)))
	defer common.Catchs()
	if err != nil {
		logs.Error("NewRequest, url: ", url, ",req: ", requestBody, ",err: ", err)
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("DELETE request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("DELETE request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil || body == nil {
		logs.Error("DELETE failed, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("DELETE successed!, body: ", string(body))
	var iss []map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	logs.Info(iss)
	return iss, nil
}

//HTTPPut patch request
func HTTPPut(url string, requestBody string) ([]map[string]interface{}, error) {
	req, err := http.NewRequest("PUT", url, bytes.NewBuffer([]byte(requestBody)))
	defer common.Catchs()
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error("PATCH request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	defer resp.Body.Close()
	logs.Info("response Status:", resp.Status, "url: ", url)
	logs.Info("response Headers:", resp.Header, "url: ", url)
	status, _ := strconv.Atoi(resp.Status)
	if status > 300 {
		logs.Error("Patch request failed, err: ", err, "body: ", requestBody, "url:", url)
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))
	if err != nil || body == nil {
		logs.Error("PUT failed, err: ", err, "body: ", requestBody)
		return nil, err
	}
	logs.Info("PUT successed!, body: ", string(body))
	var iss []map[string]interface{}
	err = json.Unmarshal(body, &iss)
	if err != nil {
		logs.Error(err, string(body))
		return nil, err
	}
	return iss, nil
}

func HTTPPostCom(req map[string]interface{}, url string) {
	logs.Info("post req_body: ", req)
	bytesData, err := json.Marshal(req)
	if err != nil {
		logs.Error(err.Error())
		return
	}
	reader := bytes.NewReader(bytesData)
	request, err := http.NewRequest("POST", url, reader)
	defer request.Body.Close()
	if err != nil {
		logs.Error(err.Error())
		return
	}
	request.Header.Set("Content-Type", "application/json;charset=UTF-8")
	client := http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		logs.Error("url", url, ",req: ", req, ",err: ", err.Error())
		return
	}
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("url", url, ",req: ", req, ",err: ", err.Error())
		return
	}
	logs.Info("respBytes", string(respBytes))
}
