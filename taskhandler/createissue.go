package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"strconv"
	"strings"
)

func CreateIssueData(issueTemp *models.IssueTemplate, cve models.VulnCenter, sc models.Score, resp map[string]interface{},
	path, assignee, issueType, labels, owner string) *models.IssueTemplate {
	issueTemp.CveId = cve.CveId
	issueTemp.CveNum = cve.CveNum
	issueTemp.OwnedComponent = path
	issueTemp.OwnedVersion = cve.CveVersion
	issueTemp.NVDScore = sc.NVDScore
	issueTemp.NVDVector = sc.NvectorVule
	issueTemp.CveBrief = cve.Description
	issueTemp.CveLevel = cve.CveLevel
	issueTemp.IssueId = int64(resp["id"].(float64))
	issueTemp.IssueNum = resp["number"].(string)
	issueTemp.Assignee = assignee
	issueTemp.StatusName = resp["state"].(string)
	if strings.ToLower(resp["state"].(string)) == "open" || resp["state"].(string) == "待办的"{
		issueTemp.Status = 1
		issueTemp.StatusName = "open"
	} else if strings.ToLower(resp["state"].(string)) == "started" ||
		strings.ToLower(resp["state"].(string)) == "progressing" ||
		strings.ToLower(resp["state"].(string)) == "进行中" {
		issueTemp.Status = 2
		issueTemp.StatusName = "progressing"
	} else if strings.ToLower(resp["state"].(string)) == "closed" || resp["state"].(string) == "已完成"{
		issueTemp.Status = 3
		issueTemp.StatusName = "closed"
	} else {
		if strings.ToLower(resp["state"].(string)) == "rejected" || resp["state"].(string) == "已拒绝" {
			issueTemp.StatusName = "rejected"
		}
		issueTemp.Status = 4
	}
	issueTemp.IssueStatus = 1
	issueTemp.IssueLabel = labels
	issueTemp.Owner = owner
	issueTemp.Repo = path
	issueTemp.Title = cve.CveNum
	issueTemp.IssueType = issueType
	issueTemp.Collaborators = ""
	issueTemp.Milestone = ""
	issueTemp.Program = ""
	issueTemp.SecurityHole = 0
	logs.Info("组装issue,模板数据存入db: ", issueTemp)
	return issueTemp
}

func CreateIssueToGit(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score, brandArry []string) (string, error) {
	defer common.Catchs()
	var it models.IssueTemplate
	it.CveId = cve.CveId
	its, err := models.GetIssueTemplet(&it)
	if err && its.IssueNum != "" && len(its.IssueNum) > 0 {
		if its.Assignee == "" || len(its.Assignee) == 0 {
			its.Assignee = assignee
		}
		issueType := its.IssueType
		labels := its.IssueLabel
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + its.IssueNum
			score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
			OpenEulerScore := strconv.FormatFloat(its.OpenEulerScore, 'f', 1, 64)
			requestBody := CreateIssueBody(accessToken, owner, path, its.Assignee,
				cve, sc, OpenEulerScore, score, labels, its, 1, its.IssueType, "", brandArry)
			logs.Info("isssue_body: ", requestBody)
			resp, err := util.HttpPatch(url, requestBody)
			if err != nil {
				logs.Error("创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建issue 失败, err: ", ok, "url: ", url)
				return "", errors.New("创建issue失败")
			}
			logs.Info("issue 创建成功，cveNum: ", cve.CveNum, "issueNum: ", resp["number"].(string))
			// 构建数据
			var issueTemp models.IssueTemplate
			CreateIssueData(&issueTemp, cve, sc, resp, path, its.Assignee, issueType, labels, owner)
			if len(brandArry) > 0 {
				var brandArryTmp []string
				for _, brand := range brandArry {
					brandArryTmp = append(brandArryTmp, brand + ":")
				}
				brandStr := strings.Join(brandArryTmp, ",")
				issueTemp.AffectedVersion = brandStr
			}
			// 存储issue数据
			issTempId, err := models.CreateIssueTemplet(&issueTemp)
			if err != nil {
				logs.Error("创建issue 模板的数据失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cve.CveNum)
			}
			// 构建回调
			//err = CreateIssueHooks(accessToken, owner, path, cve, resp)
			//if err != nil {
			//	logs.Error("创建hooks 失败, cveNum: ", cve.CveNum, "err: ", err)
			//	return "", err
			//} else {
			//	logs.Info("创建hooks 成功, cveNum: ", cve.CveNum)
			//}
			//CreateIssueLabel(accessToken, owner, path, resp["number"].(string))
			// 更新issue状态
			models.UpdateIssueStatus(cve, 2)
			// 更新分数状态
			models.UpdateIssueScore(cve, 2)
			// 更新分数记录状态
			models.UpdateIssueScoreRe(cve, 1)
		}
	} else {
		issueType := "CVE和安全问题"
		//labels := "CVE/Bug,CVE/Undisclosed,CVE/Disclosed"
		labels := "CVE/Undisclosed"
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/issues"
			score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
			requestBody := CreateIssueBody(accessToken, owner, path, assignee,
				cve, sc, "", score, labels, its, 2, issueType, "", brandArry)
			logs.Info("isssue_body: ", requestBody)
			resp, err := util.HttpPost(url, requestBody)
			if err != nil {
				logs.Error("创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建issue 失败, err: ", ok, "url: ", url)
				return "", errors.New("创建issue失败")
			}
			// 构建数据
			var issueTemp models.IssueTemplate
			CreateIssueData(&issueTemp, cve, sc, resp, path, assignee, issueType, labels, owner)
			// 存储issue数据
			if len(brandArry) > 0 {
				var brandArryTmp []string
				for _, brand := range brandArry {
					brandArryTmp = append(brandArryTmp, brand + ":")
				}
				brandStr := strings.Join(brandArryTmp, ",")
				issueTemp.AffectedVersion = brandStr
			}
			issTempId, err := models.CreateIssueTemplet(&issueTemp)
			if err != nil {
				logs.Error("创建issue 模板的数据失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cve.CveNum)
			}
			// 创建issue评论
			affectedVersion := ""
			if len(brandArry) > 0 {
				for i, brand := range brandArry {
					if brand == "" || len(brand) < 2 {
						continue
					}
					affectedVersion = affectedVersion + strconv.Itoa(i + 1) +"." + brand + ":\n"
				}
			} else {
				affectedVersion = affectedVersion + "\n"
			}
			errx := CreateIssueComment(accessToken, owner, path, assignee, cve, resp, affectedVersion)
			logs.Info("issue评论创建结果, err: ", errx)
			// 构建回调
			issueNum := resp["number"].(string)
			issueId := int64(resp["id"].(float64))
			err = CreateDepositHooks(accessToken, owner, path, cve, issueNum, issueId)
			if err != nil {
				logs.Error("创建hooks 失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建hooks 成功, cveNum: ", cve.CveNum)
			}
			// 创建issue标签
			//CreateIssueLabel(accessToken, owner, path, resp["number"].(string))
			// 更新issue状态
			models.UpdateIssueStatus(cve, 2)
			// 更新分数状态
			models.UpdateIssueScore(cve, 2)
			// 更新分数记录状态
			models.UpdateIssueScoreRe(cve, 1)
		}
	}
	return "", nil
}

func UpdateIssueToGit(accessToken string, owner string, path string,
	cve models.VulnCenter, its models.IssueTemplate) (string, error) {
	//issueType := its.IssueType
	logs.Info("更新模板请求参数: cve: ", cve, ",its: ", its, ", owner: ", owner, ",path: ", path)
	labels := its.IssueLabel
	pkgList, err := models.QueryPackageByCveId(its.CveId)
	pkgLink := ""
	var brandArray []string
	if err == nil && len(pkgList) > 0 {
		for _, p := range pkgList {
			pkgLink = pkgLink + fmt.Sprintf(`[%v](%v)\r\n`, p.PackName, p.PackUrl)
		}
	}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + its.IssueNum
		score := strconv.FormatFloat(its.NVDScore, 'f', 1, 64)
		OpenEulerScore := strconv.FormatFloat(its.OpenEulerScore, 'f', 1, 64)
		var sc models.Score
		sc, scok := models.QueryScoreByCveId(cve.CveId)
		if !scok {
			logs.Error("评分不存在, cve: ", cve)
		}
		requestBody := CreateIssueBody(accessToken, owner, path, its.Assignee,
			cve, sc, OpenEulerScore, score, labels, its, 3, its.IssueType, pkgLink, brandArray)
		logs.Info("isssue_body: ", requestBody)
		resp, err := util.HttpPatch(url, requestBody)
		if err != nil {
			logs.Error("更新issue失败, cveNum: ", cve.CveNum, "err: ", err)
			return "", err
		}
		if _, ok := resp["id"]; !ok {
			logs.Error("创建issue 失败, err: ", ok, "url: ", url)
			return "", errors.New("创建issue失败")
		}
		// 存储安全公告相关信息
		var sec models.SecurityNotice
		CreateSecNoticeData(&sec, cve, path, its.AffectedVersion)
		secId, err := models.UpdateSecNotice(&sec)
		if err != nil {
			logs.Error("更新安全信息失败,CveNum: ", cve.CveNum, ",path: ", path, ",err: ", err)
			return "", err
		} else {
			logs.Info("更新安全信息成功, secId: ", secId, ",cveNum: ", cve.CveNum)
		}
	}
	return "", nil
}

//func UpdateCommentInfo(owner, path, issueNumber string) {
//	issueUrl := "https://gitee.com/" + owner + "/" + path + "/issues/" + issueNumber
//	util.HttpGet(issueUrl)
//}

func CreateIssueHookData(issHook *models.IssueHooks, cve models.VulnCenter, resp map[string]interface{},
	path, owner string, issueNum string, issueId int64) *models.IssueHooks {
	issHook.CveId = cve.CveId
	issHook.IssueId = issueId
	issHook.IssueNum = issueNum
	issHook.HookId = int64(resp["id"].(float64))
	issHook.Owner = owner
	issHook.Repo = path
	issHook.CreateTime = common.GetCurTime()
	issHook.UpdateTime = common.GetCurTime()
	issHook.Status = 1
	issHook.HookUrl = resp["url"].(string)
	if resp["push_events"].(bool) == true {
		issHook.PushEvent = 1
	} else {
		issHook.PushEvent = 0
	}
	if resp["tag_push_events"].(bool) == true {
		issHook.TagPushEvent = 1
	} else {
		issHook.TagPushEvent = 0
	}
	if resp["issues_events"].(bool) == true {
		issHook.IssueEvent = 1
	} else {
		issHook.IssueEvent = 0
	}
	if resp["note_events"].(bool) == true {
		issHook.NoteEvent = 1
	} else {
		issHook.NoteEvent = 0
	}
	if resp["merge_requests_events"].(bool) == true {
		issHook.MergeRequestEvent = 1
	} else {
		issHook.MergeRequestEvent = 0
	}
	return issHook
}

func CreateDepositHooks(accessToken string, owner string, path string,
	cve models.VulnCenter, issueNum string, issueId int64) error {
	var ih models.IssueHooks
	ih.CveId = cve.CveId
	ih.IssueNum = issueNum
	ih.Owner = owner
	ih.Status = 1
	ih.Repo = path
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	//pwd := os.Getenv("hookpwd")
	pwd := BConfig.String("hook::hookpwd")
	hookurl := BConfig.String("hook::hookurl")
	ihs, errh := models.GetIssueHook(&ih)
	if errh {
		var hookExist = false
		for _, wh := range ihs {
			if wh.HookUrl == hookurl {
				hookExist = true
				if accessToken != "" && owner != "" && path != "" {
					url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks/" + strconv.Itoa(int(wh.HookId))
					push_events := "true"
					tag_push_events := "true"
					issues_events := "true"
					note_events := "true"
					merge_requests_events := "true"
					requestBody := fmt.Sprintf(`{
					"access_token": "%s",
					"url": "%s", 
					"password": "%s",
					"push_events": "%s",
					"tag_push_events": "%s",
					"issues_events": "%s",
					"note_events": "%s",
					"merge_requests_events": "%s"
					}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
					logs.Info("hook_body: ", requestBody)
					resp, err := util.HttpPatch(url, requestBody)
					if err != nil {
						logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
						return err
					}
					if _, ok := resp["id"]; !ok {
						logs.Error("创建仓库 hook失败, err: ", ok, "url: ", url)
						return errors.New("创建仓库 hook失败")
					}
					// 构建数据
					if resp["password"].(string) == pwd {
						var issHook models.IssueHooks
						CreateIssueHookData(&issHook, cve, resp,
							path, owner, issueNum, issueId)
						// 存储issue数据
						hookId, err := models.CreateDepositHooks(&issHook)
						if err != nil {
							logs.Error("创建仓库 hook数据失败, cveNum: ", cve.CveNum, "err: ", err)
							return nil
						} else {
							logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
						}
					}
				}
			}
		}
		if !hookExist {
			if accessToken != "" && owner != "" && path != "" {
				url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks"
				push_events := "true"
				tag_push_events := "true"
				issues_events := "true"
				note_events := "true"
				merge_requests_events := "true"
				requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
				logs.Info("hook_body: ", requestBody)
				resp, err := util.HttpPost(url, requestBody)
				if err != nil {
					logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
					return err
				}
				if _, ok := resp["id"]; !ok {
					logs.Error("创建仓库hook失败, err: ", ok, "url: ", url)
					return errors.New("创建仓库hook失败")
				}
				// 构建数据
				if resp["password"].(string) == pwd {
					var issHook models.IssueHooks
					CreateIssueHookData(&issHook, cve, resp,
						path, owner, issueNum, issueId)
					// 存储issue数据
					hookId, err := models.CreateDepositHooks(&issHook)
					if err != nil {
						logs.Error("创建仓库hook失败, cveNum: ", cve.CveNum, "err: ", err)
						return err
					} else {
						logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
					}
				}
			}
		}
	} else {
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks"
			push_events := "true"
			tag_push_events := "true"
			issues_events := "true"
			note_events := "true"
			merge_requests_events := "true"
			requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
			logs.Info("hook_body: ", requestBody)
			resp, err := util.HttpPost(url, requestBody)
			if err != nil {
				logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
				return err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建仓库hook失败, err: ", ok, "url: ", url)
				return errors.New("创建仓库hook失败")
			}
			// 构建数据
			if resp["password"].(string) == pwd {
				var issHook models.IssueHooks
				CreateIssueHookData(&issHook, cve, resp,
					path, owner, issueNum, issueId)
				// 存储issue数据
				hookId, err := models.CreateDepositHooks(&issHook)
				if err != nil {
					logs.Error("创建仓库hook失败, cveNum: ", cve.CveNum, "err: ", err)
					return err
				} else {
					logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
				}
			}
		}
	}
	return nil
}

func CreateIssueComment(accessToken, owner, path, Assignee string,
	cve models.VulnCenter, issResp map[string]interface{}, affectedVersion string) error {
	issueNum := issResp["number"].(string)
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issueNum + "/comments"
		BConfig, err := config.NewConfig("ini", "conf/app.conf")
		if err != nil {
			logs.Error("config init error:", err)
			return err
		}
		commentCmd := BConfig.String("reflink::comment_cmd")
		//commentBody := "Hey @" + Assignee + " , Please complete the content of the issue template in the issue comment. Please refer to the format:" +
		//	commentCmd
		commentBody := CommentTemplate(Assignee, commentCmd, affectedVersion)
		requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"body": "%s"
			}`, accessToken, commentBody)
		logs.Info("create issue comment body: ", requestBody)
		resp, err := util.HttpPost(url, requestBody)
		if err != nil {
			logs.Error("创建issue评论失败, url: ", url, "cveId", cve.CveId, ",issueNum: ", issueNum, ",err: ", err)
			return err
		}
		if _, ok := resp["id"]; !ok {
			logs.Error("创建issue评论失败, err: ", ok, "url: ", url)
			return errors.New("创建issue评论失败")
		}
		commentId := int64(resp["id"].(float64))
		models.UpdateIssueCommentId(issueNum, cve.CveNum, commentId)
	}
	return nil
}

func CreateSecNoticeData(sec *models.SecurityNotice, iss models.VulnCenter, path, branchVersion string) {
	branchs := ""
	if branchVersion != "" && len(branchVersion) > 0 {
		brandsGroup := strings.Split(branchVersion, ",")
		if len(brandsGroup) > 0 {
			for _, brand := range brandsGroup {
				if brand == "" || len(brand) < 2 {
					continue
				}
				brandList := strings.Split(brand, ":")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" {
						branchs += brandList[0] + "/"
					}
				} else {
					brandList := strings.Split(brand, "：")
					if len(brandList) > 1 {
						prams := strings.Replace(brandList[1], " ", "", -1)
						if prams == "受影响" {
							branchs += brandList[0] + "/"
						}
					}
				}
			}
		}
	}
	if branchs != "" && len(branchs) > 1 {
		branchs = branchs[: len(branchs) - 1]
	}
	sec.CveId = iss.CveId
	sec.CveNum = iss.CveNum
	sec.Introduction = "An update for " + path + " is now available for " + branchs
	//sec.Summary = "An update for " + path + " is now available for " + branchs
	sec.Theme = sec.Introduction + ";\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of medium. A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = branchs
}

func CreateIssueLabel(accessToken string, owner string, path string,
	issNum string) error {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issNum + "/labels"
		//label := []string{"CVE/Undisclosed","CVE/Disclosed"}
		//reqs ,err:= json.Marshal(&requestBody)
		//if err != nil {
		//	return err
		//}
		//requestBody := fmt.Sprintf(`{
		//	"access_token": "%s",
		//	"body": ["CVE/Undisclosed","CVE/Disclosed"]
		//	}`, accessToken)
		body := make(map[string]interface{})
		body["access_token"] = accessToken
		body["body"] = "[\"CVE/Undisclosed\",\"CVE/Disclosed\"]"
		requestBody, _ := json.Marshal(body)
		logs.Info("create issue label: ", string(requestBody))
		resp, err := util.HttpPost1(url, string(requestBody))
		if err != nil {
			logs.Error("cve标签创建失败, url: ", url, "requestBody: ", requestBody, "err: ", err)
			return err
		}
		for _, value := range resp {
			if _, ok := value["id"]; !ok {
				logs.Error("创建issue 标签失败, err: ", ok, "url: ", url)
				return errors.New("创建issue标签失败")
			}
		}
		logs.Info("issue 标签创建成功, resp: ", resp)
	}
	return nil
}
