package models

import (
	"cvevulner/util"
	"errors"
	"fmt"
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/orm"
)
var RepoInfoUrl       = "https://api.openeuler.org/pkgmanagedebug/packages/packageInfo?table_name=mainline&pkg_name=%s"

// body 解析后的数据model
type Loophole struct {
	Number            string //编号
	Components        string // 漏洞归属的组件
	Version           string // 漏洞归属的版本
	CvsScore          string //cvss 评分
	CvsVector         string //cvs向量
	BriefIntroduction string //漏洞简述
	Influences        string //漏洞造成的影响
	Principle         string //漏洞原理
	OpScore           string //openEuler 评分
	OpVector          string //openEuler 向量
	InfVersion        string //受影响的组件版本
	AvoidScheme       string //规避方案
	InfPackage        string //受影响的软件包
	InfProduct        string //受影响的产品
	Repo              string //漏洞所属仓库
	RepoDesc          string //组件描述
}


//vector 向量解析后的model
type VectorValue struct {
	AttackVector       string //AV
	AttackComplexity   string //AC
	PrivilegesRequired string //PR
	UserInteraction    string //UI
	Scope              string //S
	Confidentiality    string //C
	Integrity          string //I
	Availability       string //A
}

func (g *GiteOriginIssue) Insert() error {
	o := orm.NewOrm()
	_, err := o.Insert(g)
	return err
}

func (g GiteOriginIssue) Update() error {
	o := orm.NewOrm()
	_, err := o.Update(g)
	return err
}

func (g *GiteOriginIssue) InsertOrUpdate() error {
	if g.Number == "" {
		return errors.New("issue number can not be null")
	}
	o := orm.NewOrm()
	ex := GiteOriginIssue{Number: g.Number}
	err := o.Read(&ex, "number")
	if err == nil {
		g.Id = ex.Id
	}
	_, err = o.InsertOrUpdate(g)
	return err
}

func (g *GiteOriginIssue) ParseToLoophole() (hole Loophole, err error) {
	lp := Loophole{}

	if g.Body == "" {
		return lp, errors.New("can not parse a null body")
	}
	lp.InfProduct = g.InfProduct
	lp.Repo = g.RepoPath
	lp.RepoDesc =g.RepoDesc
	sm := util.RegexpCveNumber.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Number = util.TrimString(sm[0][1])
	}
	sm = util.RegexpCveComponents.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Components = util.TrimString(sm[0][1])
	}
	sm = util.RegexpCveVersion.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.Version = util.TrimString(sm[0][1])
	}
	sm = util.RegexpCveScore.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		if cs := util.ExtractDigital(sm[0][1]); cs != "" {
			lp.CvsScore = cs
		}
	}
	sm = util.RegexpCveVector.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		if v := util.ExtractVector(sm[0][1]); v != "" {
			lp.CvsVector = v
		}
	}
	sm = util.RegexpCveBriefDesc.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		//lp.BriefIntroduction = util.TrimString(sm[0][1])
		lp.BriefIntroduction =sm[0][1]
	}
	sm = util.RegexpCveInfluencesDesc.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		//lp.Influences = util.TrimString(sm[0][1])
		lp.Influences = sm[0][1]
	}
	sm = util.RegexpCvePrincipleDesc.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		//lp.Principle = util.TrimString(sm[0][1])
		lp.Principle = sm[0][1]
	}
	sm = util.RegexpCveOpScore.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 {
		if cs := util.ExtractDigital(sm[0][1]); cs != "" {
			lp.OpScore = cs
		}
	} else {
		sm = util.RegexpCveOpScore1.FindAllStringSubmatch(g.Body, -1)
		if len(sm) > 0 {
			if cs := util.ExtractDigital(sm[0][1]); cs != "" {
				lp.OpScore = cs
			}
		}
	}
	sm = util.RegexpCveOpVector.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		if v := util.ExtractVector(sm[0][1]); v != "" {
			lp.OpVector = v
		}
	}
	sm = util.RegexpCveInfluencesVersion.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		lp.InfVersion = util.TrimString(sm[0][1])
	}
	sm = util.RegexpCvePlannedMeasures.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 {
		if len(sm[0]) > 0 {
			//lp.AvoidScheme = util.TrimString(sm[0][1])
			lp.AvoidScheme = sm[0][1]
		}

	} else {
		sm = util.RegexpCvePlannedMeasures1.FindAllStringSubmatch(g.Body, -1)
		if len(sm) > 0 && len(sm[0]) > 0 {
			//lp.AvoidScheme = util.TrimString(sm[0][1])
			lp.AvoidScheme = sm[0][1]
		}
	}
	sm = util.RegexpCveInfluencesPkg.FindAllStringSubmatch(g.Body, -1)
	if len(sm) > 0 {
		lp.InfPackage = util.TrimString(sm[0][1])
	}
	logs.Error(fmt.Sprintf("%#v",lp))
	return lp, nil
}

func (v *VectorValue) VctToVectorValue(vector string) bool {
	if util.TrimString(vector) == "" {
		return false
	}
	m, ok := util.VctToMap(vector)
	if !ok {
		return false
	}
	v.AttackVector = util.ReadVmValue(m["AV"])
	v.AttackComplexity = util.ReadVmValue(m["AC"])
	v.Availability = util.ReadVmValue(m["A"])
	v.Confidentiality = util.ReadVmValue(m["C"])
	v.Integrity = util.ReadVmValue(m["I"])
	v.PrivilegesRequired = util.ReadVmValue(m["PR"])
	v.UserInteraction = util.ReadVmValue(m["UI"])
	v.Scope = util.ReadVmValue(m["S"])
	return true
}



