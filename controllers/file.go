package controllers

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

//FileController file operation routing processing
type FileController struct {
	beego.Controller
}

//DownloadLastExcel Download the latest excel file
// @router /lastExcel [get]
func (f *FileController) DownloadLastExcel() {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	err := util.MakeDir(fd)
	if err != nil {
		logs.Error(err)
	}
	er := models.ExportRecord{}
	err = er.QueryLast()
	if err != nil {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//DownLoadExcelByFileCode download excel file by code
//@router /downloadExcel
func (f *FileController) DownLoadExcelByFileCode() {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	fc := f.GetString("fileCode")
	if fc == "" {
		_ = f.Ctx.Output.Body([]byte("err: fileCode is a required parameter "))
		return
	}
	er := models.ExportRecord{FileCode: fc}
	err := er.Read("file_code")
	if err != nil {
		_ = f.Ctx.Output.Body([]byte(fmt.Sprintf("err: %v", err)))
		return
	}
	if er.FileName == "" {
		_ = f.Ctx.Output.Body([]byte("err: Can not find excel file by fileCode! "))
		return
	}
	if er.State == 0 {
		_ = f.Ctx.Output.Body([]byte("The file is being generated, please try again later!"))
		return
	}
	if er.State == 2 {
		_ = f.Ctx.Output.Body([]byte("File generation failed, please contact the administrator or regenerate!!"))
		return
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("error:file does not exist"))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//TriggerCveData touch off generate cve data excel and get cve package
//@router /triggerCveData [get]
func (f *FileController) TriggerCveData() {
	timeUnix := time.Now().Unix()
	startTime := f.GetString("startTime")
	if startTime == "" {
		f.Ctx.WriteString("Error:start time cannot be empty")
		return
	}
	//It is time-consuming to generate excel, here is the current limit processing
	er := models.ExportRecord{}
	err := er.QueryLast()
	if err == nil {
		if er.State == 0 && (timeUnix-er.CreateTime < 300) {
			eng := fmt.Sprintf("There is currently a file being generated, "+
				"file information: file name %s fileCode=%s; you can use fileCode to download the file.",
				er.FileName, er.FileCode)
			cha := fmt.Sprintf("\n当前有一个文件正在生成，文件信息：文件名 %s fileCode= %s ；"+
				"你可以使用fileCode去下载文件。", er.FileName, er.FileCode)
			f.Ctx.WriteString(eng + cha)
			return
		}
	} else {
		logs.Error(err)
	}
	rt := regexp.MustCompile(`^(\d{4})-\d{2}-(\d{2})$`)
	find := rt.Match([]byte(startTime))
	if !find {
		f.Ctx.WriteString(`Error: please enter the correct start time in a format like this "yyyy-MM-dd".`)
		return
	}
	affectBranchsxList := []string{}
	affectedBranchs := beego.AppConfig.String("cve::affected_branchs")
	if affectedBranchs != "" && len(affectedBranchs) > 0 {
		affectBranchsxList = strings.Split(affectedBranchs, ",")
	} else {
		affectBranchsxList = append(affectBranchsxList, "openEuler-20.03-LTS")
	}
	for _, affectBranch := range affectBranchsxList {
		now := time.Now().Unix()
		en := fmt.Sprintf("cve与安全公告%v_%v.xlsx", affectBranch, now)
		fileCode := common.EncryptMd5(en)
		//call the generate excel task by new thread
		er = models.ExportRecord{FileName: en, FileCode: fileCode, State: 0, CreateTime: timeUnix}
		err = er.Insert()
		if err != nil {
			f.Ctx.WriteString(fmt.Sprintf("error:%v", err))
		} else {
			//return the success notice
			go taskhandler.GenerateExcelTrigger(en, startTime, fileCode, affectBranch)
			f.Ctx.WriteString(fmt.Sprintf("Success：The name of the excel file generated this time is: %s. "+
				"It takes some time to generate the excel file. "+
				"You can try to call the download file interface and pass in the param fileCode=%s to be downloaded.", en, fileCode))
		}
	}
}
