package controllers

import (
	"bytes"
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
)

var (
	//GiteeUserAgent gitee hook request flag
	GiteeUserAgent = "git-oschina-hook"
	//XGiteeToken password or sign
	XGiteeToken = "X-Gitee-Token"
	//XGIteeEventType webhook event type
	XGIteeEventType = "X-Gitee-Event"
	//NoteHookType type of comment
	NoteHookType = "Note Hook"
	//PullReqHookType type of pull request
	PullReqHookType = "merge_request_hooks"
	//PushTagHookType type of push or tag
	PushTagHookType = "push_hooks/tag_push_hooks"
	//IssueHookType type of issue
	IssueHookType = "Issue Hook"
)

const (
	//CommentAnalysisCplTpl complete comment analysis reply template
	CommentAnalysisCplTpl = "@%v %v"
	//ReviewPrivateLettersTpl send private review letters template
	ReviewPrivateLettersTpl = `%s(%s)analysis is over,CVEScore:%v;OpenEulerScore:%v.Please review!`
	//ReviewRejectScore reply the review reject template
	ReviewRejectScore = `@%v you submit issue score audit failed(reject by %v),Please re-analyze and submit!`
	//ReviewApproveScore replay the review approve template
	ReviewApproveScore = `@%v you submit issue score audit success(approved by %v),You can proceed to the next step!`
	//CommentReviewTpl comment review template
	CommentReviewTpl = `%v The CVE score needs to be reviewed (the review instruction /approve&/reject means agreement and rejection).`
	//IssueRejectState issue state rejected
	IssueRejectState = "rejected"
	//IssueCloseState issue state closed
	IssueCloseState = "closed"
	//IssueProgressState issue  state progressing
	IssueProgressState = "progressing"
	//IssueOpenState issue state open
	IssueOpenState = "open"
	//AnalysisComplete issue analysis complete comment
	AnalysisComplete = "@%v 经过 cve-manager 解析, 您分析的内容如下表所示:\n"
	// Content review tips
	ContentReview = "%v 请完成以下操作:\n"
	// Not filling in the correct format
	IssueErroFormat = "%v 经过 cve-manager 解析, 填写openEuler评分未通过安全组成员审核需要再次在评论区提交评分,通过审核后才能关闭issue."
	// Remind the security group to review
	CommentReviewRemind = "%v 经过 cve-manager 解析 openEuler评分 已改变 需要您及时进行审核,以便maintainer进行后续操作."
	// Review private messages
	CommentPrivateReview = "%v 仓库的CVE和安全问题的ISSUE,需要您进行审核,CVE编号: %v"
	// Rating review failed
	CommentPrivateOpenEuler = "%v 仓库的CVE和安全问题的ISSUE, CVE编号: %v, 填写openEuler评分未通过安全组成员审核需要再次在评论区提交评分,通过审核后才能关闭issue."
	// Review reminder
	CommentReviewRemindMaintainer = "@%v 经过 cve-manager 解析 openEuler评分 已改变 需要等待安全组成员审核通过以后, 才能进行后续操作."
)

//HookEventControllers gitee hook callback
type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

//isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	logs.Info(xToken)
	return
}

func (c *HookEventControllers) handleNoteDate() {
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" {
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {
	logs.Info(string(c.Ctx.Input.RequestBody))
	issueHook := models.IssuePayload{}
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &issueHook)
	if err != nil {
		logs.Error(err)
		return
	}
	if issueHook.Action == "assign" {
		//Update the person in charge of the issue template
		issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
		}
		issueTmp.Assignee = issueHook.Assignee.Login
		err = models.UpdateIssueTemplate(&issueTmp, "issue_assignee")
		if err != nil {
			logs.Error(err)
		}
	}
	if issueHook.Action == "state_change" {
		//handle issue state change
		err = handleIssueStateChange(&issueHook)
		if err != nil {
			logs.Error(err)
		}
	}
}

func closeIssuePrivilage(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix string, cveCenter *models.VulnCenter) bool {
	closePrBool := true
	if issueHook.Sender.UserName != "" && len(issueHook.Sender.UserName) > 1 {
		if isReviewer(util.TrimString(issueHook.Sender.UserName)) {
			if msg, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
				//send comment to issue
				issueTmp.IssueStatus = 1
				issueTmp.MtAuditFlag = 1
				issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
				issueTmp.StatusName = "open"
				_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
					*cveCenter, *issueTmp)
				if issueErr == nil {
					na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
					cc := fmt.Sprintf(ContentReview, "@"+issueHook.Sender.UserName) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v,", issueTmp.Repo, issueTmp.CveNum)
					taskhandler.SendPrivateLetters(token, content+msg, issueHook.Issue.Assignee.Login)
				}
			} else {
				issueTmp.StatusName = issueHook.Issue.StateName
				issueTmp.SaAuditFlag = 1
				issueTmp.MtAuditFlag = 1
				issueTmp.OpAuditFlag = 1
				issueTmp.Status = 3
				if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
					issueTmp.IssueStatus = 2
					cveCenter.IsExport = 3
					issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(unFix, fixed)
				} else {
					issueTmp.IssueStatus = 6
					cveCenter.IsExport = 2
					issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
				}
			}
			closePrBool = false
		}
	}
	return closePrBool
}

func sigReviewSend(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix, assignee string, cveCenter *models.VulnCenter) {
	issueTmp.IssueStatus = 1
	issueTmp.Status = 1
	issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
	issueTmp.StatusName = "open"
	_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
		*cveCenter, *issueTmp)
	if issueErr == nil {
		if issueTmp.OpAuditFlag == 2 {
			cc := fmt.Sprintf(IssueErroFormat, assignee)
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
			content := fmt.Sprintf(CommentPrivateOpenEuler, issueTmp.Repo, issueTmp.CveNum)
			taskhandler.SendPrivateLetters(token, content, issueHook.Sender.UserName)
		} else if issueTmp.OpAuditFlag == 0 {
			list, revErr := models.GetSecurityReviewerList()
			if revErr == nil && len(list) > 0 {
				content := fmt.Sprintf(CommentPrivateReview, issueTmp.Repo, issueTmp.CveNum)
				ns := make([]string, len(list))
				for k, v := range list {
					ns[k] = "@" + v.NameSpace + " "
					taskhandler.SendPrivateLetters(token, content, v.NameSpace)
				}
				if len(ns) > 0 {
					cc := fmt.Sprintf(CommentReviewRemind, strings.Join(ns, ","))
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
				}
			} else {
				logs.Error(revErr)
			}
		}
	}
}

func getMaintainer(path, prSender, assignee string) string {
	maintainerList, mainOk := models.QueryRepoAllMaintainer(path)
	assList := []string{}
	if mainOk && len(maintainerList) > 0 {
		for _, v := range maintainerList {
			assList = append(assList, "@"+v.MemberName+" ")
		}
	}
	if prSender != "" && len(prSender) > 1 {
		isListBool := common.IsValueInList("@"+prSender+" ", assList)
		if !isListBool {
			assList = append(assList, "@"+prSender+" ")
		}
	}
	maintainerVaule := ""
	if len(assList) > 0 {
		maintainerVaule = strings.Join(assList, ",")
	} else {
		maintainerVaule = "@" + assignee + " "
	}
	return maintainerVaule
}

func closeIssueProc(issueHook *models.IssuePayload, issueTmp *models.IssueTemplate,
	token, owner, fixed, unFix string, cveCenter *models.VulnCenter) {
	closePrBool := true
	closeIssuePrFlag, closeOk := beego.AppConfig.Int64("cve::close_issue_privilege")
	if closeOk == nil && closeIssuePrFlag == 1 {
		closePrBool = closeIssuePrivilage(issueHook, issueTmp,
			token, owner, fixed, unFix, cveCenter)
	}
	if closePrBool {
		issueTmp.Status = 1
		cveCenter.IsExport = 0
		issueTmp.MtAuditFlag = 1
		assignee := getMaintainer(issueTmp.Repo, issueHook.Sender.UserName, issueTmp.Assignee)
		openScoreFlag := true
		if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
			issueTmp.OpAuditFlag != 1 && issueTmp.OpenEulerScore > 0 {
			//send comment to issue
			openScoreFlag = false
			sigReviewSend(issueHook, issueTmp, token, owner, fixed, unFix, assignee, cveCenter)
		}
		if openScoreFlag {
			if msg, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
				//send comment to issue
				issueTmp.IssueStatus = 1
				issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
				issueTmp.StatusName = "open"
				_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
					*cveCenter, *issueTmp)
				if issueErr == nil {
					na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
					cc := fmt.Sprintf(ContentReview, assignee) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v,", issueTmp.Repo, issueTmp.CveNum)
					taskhandler.SendPrivateLetters(token, content+msg, issueHook.Sender.UserName)
				}
			} else {
				//1. change issue status
				issueTmp.IssueStatus = 2
				//issueTmp.Status = 3
				cveCenter.IsExport = 3
				if issueTmp.MtAuditFlag == 0 {
					issueTmp.IssueStatus = 1
					issueTmp.Status = 1
					cveCenter.IsExport = 0
					issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
					issueTmp.StatusName = "open"
					_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
						*cveCenter, *issueTmp)
					if issueErr == nil {
						na := "\n**issue关闭前,请确认模板分析内容的准确性与完整性,确认无误后,请在评论区输入: /approve, 否则无法关闭当前issue.**"
						cc := fmt.Sprintf(ContentReview, assignee) + tb + na
						taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					}
				}
				issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
				issueTmp.StatusName = "open"
				issueTmp.Status = 1
				issuePrFlag := VerifyIssueAsPr(issueTmp, *cveCenter, false,
					assignee, issueHook.Sender.UserName)
				if issuePrFlag {
					issueTmp.StatusName = issueHook.Issue.StateName
					issueTmp.Status = 3
					if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
						issueTmp.IssueStatus = 2
						cveCenter.IsExport = 3
						issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(unFix, fixed)
					} else {
						issueTmp.IssueStatus = 6
						cveCenter.IsExport = 2
						issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
					}
				} else {
					issueTmp.IssueStatus = 1
					issueTmp.Status = 1
					cveCenter.IsExport = 0
				}
			}
		}
	}
}

// Entry function for handling issue status
func handleIssueStateChange(issueHook *models.IssuePayload) error {
	unFix := beego.AppConfig.String("labelUnFix")
	fixed := beego.AppConfig.String("labelFixed")
	issueTmp := models.IssueTemplate{}
	if issueHook.Issue.Repository.Path != "" && len(issueHook.Issue.Repository.Path) > 1 {
		issueTmp.IssueNum = issueHook.Iid
		issueTmp.OwnedComponent = issueHook.Issue.Repository.Path
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "owned_component")
		if issueErr != nil {
			return issueErr
		}
	} else {
		issueTmp.IssueNum = issueHook.Iid
		issueErr := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if issueErr != nil {
			return issueErr
		}
	}
	cveCenter := models.VulnCenter{CveId: issueTmp.CveId}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id")
	if cveErr != nil {
		return cveErr
	}
	token := beego.AppConfig.String("gitee::git_token")
	owner := beego.AppConfig.String("gitee::owner")
	issueTmp.StatusName = issueHook.Issue.StateName
	logs.Info("发起issue状态修改, 发起人: @", issueHook.Sender.UserName, ", 修改状态: ",
		issueHook.Issue.StateName, ", data: ", issueHook)
	switch issueHook.State {
	case IssueOpenState:
		issueTmp.Status = 1
		cveCenter.IsExport = 0
		_, _, ok := checkIssueAnalysisComplete(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
		//issueTmp.IssueStatus = 1
	case IssueProgressState:
		issueTmp.Status = 2
		cveCenter.IsExport = 0
		_, _, ok := checkIssueAnalysisComplete(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
	case IssueCloseState:
		if issueTmp.Status == 3 {
			// The issue has been closed and cannot be operated again
			logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
			return errors.New("The issue has been closed and cannot be operated again")
		}
		closeIssueProc(issueHook, &issueTmp, token, owner, fixed, unFix, &cveCenter)
	case IssueRejectState:
		issueTmp.Status = 4
		issueTmp.IssueStatus = 6
		cveCenter.IsExport = 2
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
	}
	updateBool := updateTempAndCenter(issueTmp, cveCenter, token, owner)
	if !updateBool {
		return errors.New("handle issue state hook appear error maybe some step fail")
	}
	return nil
}

// When the issue status is complete, verify whether the pr is associated
func VerifyIssueAsPr(issueTmp *models.IssueTemplate, cveCenter models.VulnCenter,
	effectFlag bool, assignee, prSend string) bool {
	sn := models.SecurityNotice{CveId: issueTmp.CveId}
	secErr := sn.Read("cve_id")
	if secErr != nil {
		logs.Error("no data has been found, issueTmp: ", issueTmp)
		return true
	}
	affectBranchsxList := []string{}
	affectedBranchs := beego.AppConfig.String("cve::affected_branchs")
	if affectedBranchs != "" && len(affectedBranchs) > 0 {
		affectBranchsxList = strings.Split(affectedBranchs, ",")
	}
	token := beego.AppConfig.String("gitee::git_token")
	owner := beego.AppConfig.String("gitee::owner")
	if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
		issueTmp.SaAuditFlag = 0
		affectProductList := strings.Split(sn.AffectProduct, "/")
		var branchMaps = make(map[string]bool)
		for _, brands := range affectProductList {
			if len(affectBranchsxList) > 0 {
				for _, affectBranch := range affectBranchsxList {
					if affectBranch == brands {
						branchMaps[brands] = false
						prList := getRepoIssueAllPR(affectBranch, token, owner, issueTmp.Repo, *issueTmp)
						if len(prList) > 0 {
							branchMaps[brands] = true
						}
					}
				}
			}
		}
		brandStr := ""
		for brand, bv := range branchMaps {
			if !bv {
				logs.Error("brand: ", brand, ", pr is not related to issue, issueTmp: ", issueTmp)
				brandStr = brandStr + brand + "/"
			}
		}
		if brandStr != "" && len(brandStr) > 1 {
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				commentBody := assignee + "\n" +
					"关闭issue前,需要将受影响的分支在合并pr时关联上当前issue编号: #" + issueTmp.IssueNum + "\n" +
					"受影响分支: " + brandStr[:len(brandStr)-1] + "\n" +
					"具体操作参考: " + "https://gitee.com/help/articles/4142" + "\n"
				taskhandler.AddCommentToIssue(commentBody, issueTmp.IssueNum, owner, issueTmp.Repo, token)
				content := issueTmp.Repo + " 仓库的CVE和安全问题的ISSUE,CVE编号: " + issueTmp.CveNum +
					",关闭issue前,需要将受影响的分支在合并pr时关联上当前issue编号: #" + issueTmp.IssueNum +
					",受影响分支: " + brandStr[:len(brandStr)-1] +
					",具体操作参考: " + "https://gitee.com/help/articles/4142."
				taskhandler.SendPrivateLetters(token, content, prSend)
			}
			return false
		}
	} else {
		if effectFlag && issueTmp.SaAuditFlag == 0 {
			unaffectedBranchList := []string{}
			if issueTmp.AffectedVersion != "" && len(issueTmp.AffectedVersion) > 1 {
				unaffectedBranchList = paraAffectBrands(issueTmp.AffectedVersion)
			}
			branchStrs := ""
			if len(unaffectedBranchList) > 0 {
				for _, brands := range unaffectedBranchList {
					if len(affectBranchsxList) > 0 {
						for _, affectBranch := range affectBranchsxList {
							if affectBranch == brands {
								branchStrs = branchStrs + brands + "/"
							}
						}
					}
				}
			}
			if branchStrs != "" && len(branchStrs) > 1 {
				branchStrs = branchStrs[:len(branchStrs)-1]
				list, err := models.GetSecurityReviewerList()
				if err != nil {
					logs.Error(err)
					issueTmp.SaAuditFlag = 1
					return true
				}
				if len(list) == 0 {
					logs.Error("list is null, issueTemp: ", issueTmp)
					issueTmp.SaAuditFlag = 1
					return true
				}
				anName := []string{}
				content := fmt.Sprintf(CommentPrivateReview, issueTmp.Repo, issueTmp.CveNum)
				for _, v := range list {
					anName = append(anName, "@"+v.NameSpace+" ")
					taskhandler.SendPrivateLetters(token, content, v.NameSpace)
				}
				if len(anName) > 0 {
					_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
						cveCenter, *issueTmp)
					if issueErr == nil {
						assignee := strings.Join(anName, ",")
						commentBody := assignee + "\n" +
							"关闭issue前,请确认分支: " + branchStrs + ": 受影响/不受影响, 如受影响,请联系maintainer: @" +
							issueTmp.Assignee + ", **进行处理后, 或者按照模板格式在评论区填写内容, 最后记得在评论区回复: /approve ,才能正常关闭issue.**"
						taskhandler.AddCommentToIssue(commentBody, issueTmp.IssueNum, owner, issueTmp.Repo, token)
					}
					return false
				} else {
					issueTmp.SaAuditFlag = 1
				}
			} else {
				issueTmp.SaAuditFlag = 1
			}
		}
	}
	return true
}

func paraAffectBrands(affectedVersion string) (unaffectedBranchList []string) {
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams != "受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams != "受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
			if len(brandList) == 1 {
				unaffectedBranchList = append(unaffectedBranchList, brandList[0])
			}
		}
	}
	return unaffectedBranchList
}

func paraAffectBrandBool(affectedVersion string) bool {
	unaffectedBranchList := []string{}
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "受影响" || prams == "不受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" || prams == "不受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func getPRRelatedBrandsAllIssue(token, owner, repo string, num int, issueNum string) bool {
	issueFlag := false
	url := fmt.Sprintf(`https://gitee.com/api/v5/repos/%s/%s/pulls/%v/issues`, owner, repo, num)
	pageSize := 20
	pageCount := 1
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error(err)
		return false
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("per_page", strconv.Itoa(pageSize))
	for {
		q.Del("page")
		q.Add("page", strconv.Itoa(pageCount))
		req.URL.RawQuery = q.Encode()
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			logs.Error(err)
			break
		}
		if resp.StatusCode == http.StatusOK {
			var il []models.HookIssue
			read, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				logs.Error(err)
				break
			}
			err = json.Unmarshal(read, &il)
			if err != nil {
				logs.Error(err)
				break
			}
			for _, v := range il {
				d, ok := isLegallyIssue(v)
				if ok {
					if issueNum == d.Number {
						issueFlag = true
						break
					}
				}
			}
			if len(il) < pageSize {
				break
			}
			pageCount++
		} else {
			resp.Body.Close()
			break
		}
	}
	return issueFlag
}

// Verify that the current issue meets the requirements
func isLegallyIssue(i models.HookIssue) (pri models.PullRequestIssue, ok bool) {
	if i.IssueType != "CVE和安全问题" || (i.State != "closed" && i.State != "已完成") {
		return
	}
	tt := strings.Trim(i.Title, " ")
	regCveNum := regexp.MustCompile(`(?mi)CVE-[\d]{1,}-([\d]{1,})$`)
	sm := util.RegexpCveNumber.FindAllStringSubmatch(i.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		val := sm[0][1]
		tt = util.GetCveNumber(util.TrimString(val))
		if tt != "" && regCveNum.Match([]byte(tt)) {
			ok = true
		}
	}
	if ok {
		pri.Id = i.Id
		pri.Number = i.Number
		pri.CveNumber = tt
		pri.Repo = i.Repository.Path
	}
	return
}

// Get the pr associated with a single warehouse
func getRepoIssueAllPR(affectBranch, token, owner, repo string, isTemp models.IssueTemplate) (prList []models.PullRequestIssue) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/issues/%v/pull_requests", owner, isTemp.IssueNum)
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error("NewRequest, url: ", url, ",err: ", err)
		return
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("repo", repo)
	req.URL.RawQuery = q.Encode()
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		logs.Error("DefaultClient, url: ", url, ",err: ", err)
		return
	}
	if resp.StatusCode == http.StatusOK {
		issuePr := make([]map[string]interface{}, 0)
		read, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			logs.Error("ReadAll, url: ", url, ",err: ", err)
			return
		}
		resp.Body.Close()
		err = json.Unmarshal(read, &issuePr)
		if err != nil {
			logs.Error("Unmarshal, url: ", url, ",err: ", err)
			return
		}
		for _, v := range issuePr {
			if _, ok := v["id"]; !ok {
				continue
			}
			pr := models.PullRequestIssue{}
			if v["state"].(string) == "merged" && v["mergeable"].(bool) {
				if v["head"].(map[string]interface{})["label"].(string) == affectBranch ||
					v["base"].(map[string]interface{})["label"].(string) == affectBranch {
					if v["head"].(map[string]interface{})["repo"].(map[string]interface{})["path"] == repo ||
						v["base"].(map[string]interface{})["repo"].(map[string]interface{})["path"] == repo {
						if v["head"].(map[string]interface{})["repo"].(map[string]interface{})["namespace"].(map[string]interface{})["path"] == owner ||
							v["base"].(map[string]interface{})["repo"].(map[string]interface{})["namespace"].(map[string]interface{})["path"] == owner {
							pr.Id = int64(v["id"].(float64))
							pr.Number = isTemp.IssueNum
							pr.CveNumber = isTemp.CveNum
							pr.Repo = repo
							prList = append(prList, pr)
						}
					}
				}
			}
		}
	} else {
		resp.Body.Close()
	}
	return
}

func isNormalCloseIssue(cveID int64, issueState int8) bool {
	if issueState == 1 {
		return false
	}
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		logs.Error(err)
		return false
	}
	if score.Ostatus != 3 {
		return false
	}
	return true
}

// update data
func updateTempAndCenter(issueTmp models.IssueTemplate, cveCenter models.VulnCenter, token, owner string) bool {
	appearErr := 0
	err := models.UpdateIssueTemplate(&issueTmp, "status", "issue_status",
		"status_name", "issue_label", "mt_audit_flag", "sa_audit_flag")
	if err != nil {
		logs.Error(err)
		appearErr += 1
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
		appearErr += 1
	}
	update = ChangeIssueLabel(token, issueTmp.Repo, issueTmp.IssueNum, owner, issueTmp.IssueLabel)
	if !update {
		logs.Error("update gitee issue label  fail ")
		appearErr++
	}
	sn := models.SecurityNotice{CveId: issueTmp.CveId}
	err = sn.Read("cve_id")
	if err != nil {
		logs.Error("err: ", err)
		return false
	}
	switch issueTmp.IssueStatus {
	case 2:
		sn.AffectStatus = "Fixed"
	case 6:
		sn.AffectStatus = "UnAffected"
	default:
		sn.AffectStatus = "UnFixed"
	}
	err = sn.Update("affect_status")
	if err != nil {
		appearErr++
		logs.Error(err)
	}
	if appearErr > 0 {
		logs.Error("handle issue state hook appear error maybe some step "+
			"fail, appearErr: ", appearErr, ",issuetmp: ", issueTmp)
		return false
	}
	return true
}

func openEulerScoreReview(issueTmp *models.IssueTemplate, cuAccount, owner, token string) bool {
	approveFlag := true
	if isReviewer(cuAccount) {
		issueTmp.OpAuditFlag = 1
		approveFlag = false
		err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
		if err != nil {
			logs.Error(err)
		} else {
			err = models.UpdateIssueTemplate(issueTmp, "op_audit_flag")
			if err != nil {
				logs.Error(err)
			}
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewApproveScore, issueTmp.Assignee, cuAccount),
				issueTmp.IssueNum, owner, issueTmp.Repo, token)
		}
	} else {
		taskhandler.AddCommentToIssue(fmt.Sprintf(CommentReviewRemindMaintainer, cuAccount),
			issueTmp.IssueNum, owner, issueTmp.Repo, token)
	}
	return approveFlag
}

func maintainerApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed, unfixed string) {
	if _, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
		return
	} else {
		issueTmp.MtAuditFlag = 1
		err := models.UpdateIssueTemplate(issueTmp, "mt_audit_flag")
		if err != nil {
			logs.Error(err)
			return
		}
		cveCenter := models.VulnCenter{CveId: issueTmp.CveId}
		err = models.GetVulnCenterByCid(&cveCenter, "cve_id")
		if err != nil {
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		assignee := getMaintainer(issueTmp.Repo, cuAccount, issueTmp.Assignee)
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false, assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容, cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("发起issue关闭,issuetmp: ", issueTmp)
			} else {
				logs.Error("issue关闭操作失败, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			//issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
		return
	}
}

func securityApprove(issueTmp *models.IssueTemplate, cuAccount, owner, token, fixed, unfixed string) {
	if _, tb, ok := checkIssueClosedAnalysisComplete(issueTmp); !ok {
		//send comment to issue
		na := "\n**请确认分析内容的准确性,待分析内容请填写完整,否则将无法关闭当前issue.**"
		cc := fmt.Sprintf(AnalysisComplete, cuAccount) + tb + na
		taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, issueTmp.Repo, token)
		return
	} else {
		if !isReviewer(cuAccount) {
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v maintainer具有通过/approve关闭issue, 请通过issue页面按钮关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			return
		}
		cveCenter := models.VulnCenter{CveId: issueTmp.CveId}
		err := models.GetVulnCenterByCid(&cveCenter, "cve_id")
		if err != nil {
			return
		}
		issueTmp.IssueLabel = unfixed
		issueTmp.StatusName = "open"
		assignee := getMaintainer(issueTmp.Repo, cuAccount, issueTmp.Assignee)
		issuePrFlag := VerifyIssueAsPr(issueTmp, cveCenter, false, assignee, cuAccount)
		if issuePrFlag {
			issueTmp.IssueLabel = fixed
			issueTmp.StatusName = "closed"
			taskhandler.AddCommentToIssue(fmt.Sprintf(`@%v 你已审核模板内容,cve-manager 将关闭issue!`,
				cuAccount), issueTmp.IssueNum, owner, issueTmp.Repo, token)
			_, issueErr := taskhandler.UpdateIssueToGit(token, owner, issueTmp.Repo,
				cveCenter, *issueTmp)
			if issueErr == nil {
				logs.Info("发起issue关闭,issuetmp: ", issueTmp)
			} else {
				logs.Error("issue关闭操作失败, issuetmp: ", issueTmp, ",issueErr: ", issueErr)
				return
			}
			issueTmp.SaAuditFlag = 1
			issueTmp.Status = 3
			if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
				issueTmp.IssueStatus = 2
				cveCenter.IsExport = 3
			} else {
				issueTmp.IssueStatus = 6
				cveCenter.IsExport = 2
			}
			updateBool := updateTempAndCenter(*issueTmp, cveCenter, token, owner)
			if !updateBool {
				return
			}
		}
		return
	}
}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	// The default timeout for receiving hooks
	logs.Info("payload.Comment: ", payload.Comment, ", Number: ", payload.Issue.Number, "id: ", payload.Issue.Id)
	issueNum := payload.Issue.Number           //issue number string
	issueId := payload.Issue.Id                // issue id int64
	cBody := payload.Comment.Body              //Comment subject
	cuAccount := payload.Comment.User.UserName //gitee domain address
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	cmdClose := beego.AppConfig.DefaultString("closeCmd", "/close")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		return
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//Review rejected Add comment @Analyst
		if !isReviewer(cuAccount) {
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum, IssueId: issueId}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if err != nil {
			logs.Error(err)
			return
		}
		if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
			issueTmp.OpenEulerScore > 0 {
			err = changeOpenEulerScoreStatus(issueTmp.CveId, 2)
			if err != nil {
				logs.Error(err)
			}
			issueTmp.OpAuditFlag = 2
			err = models.UpdateIssueTemplate(&issueTmp, "op_audit_flag")
			if err != nil {
				logs.Error(err)
			}
			accessToken := os.Getenv("GITEE_TOKEN")
			owner := beego.AppConfig.String("gitee::owner")
			path := issueTmp.Repo
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewRejectScore, issueTmp.Assignee, cuAccount),
				issueTmp.IssueNum, owner, path, accessToken)
		}
	} else if strings.HasPrefix(cBody, cmdApe) {
		issueTmp := models.IssueTemplate{IssueNum: issueNum, IssueId: issueId}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if err != nil {
			logs.Error(err)
			return
		}
		if issueTmp.Status == 3 {
			// The issue has been closed and cannot be operated again
			logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
			return
		}
		token := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		fixed := beego.AppConfig.String("labelFixed")
		unfixed := beego.AppConfig.String("labelUnFix")
		approveFlag := true
		if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.NVDScore > 0 &&
			issueTmp.OpAuditFlag != 1 && issueTmp.OpenEulerScore > 0 {
			//Approved to modify the rating status
			approveFlag = openEulerScoreReview(&issueTmp, cuAccount, owner, token)
		}
		if approveFlag {
			mtAuditFlag := false
			// Analysis command belongs to the time period
			maintainerList, mainOk := models.QueryRepoAllMaintainer(issueTmp.Repo)
			if mainOk && len(maintainerList) > 0 {
				for _, v := range maintainerList {
					if util.TrimString(v.MemberName) == cuAccount {
						mtAuditFlag = true
						break
					}
				}
			}
			if mtAuditFlag {
				maintainerApprove(&issueTmp, cuAccount, owner, token, fixed, unfixed)
			} else {
				securityApprove(&issueTmp, cuAccount, owner, token, fixed, unfixed)
			}
		}
	} else if strings.HasPrefix(cBody, cmdClose) {
		//close issue
		issueId := payload.Issue.Id
		issueTmp := models.IssueTemplate{IssueNum: issueNum, IssueId: issueId}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
		if err != nil {
			logs.Error(err)
			return
		}
		closeFlag := false
		if cuAccount == issueTmp.Assignee {
			//call the gitee api to change issue status
			c := strings.Trim(cBody, cmdClose)
			issueTmp.ErrorDescription = c
			token := beego.AppConfig.String("gitee::git_token")
			owner := beego.AppConfig.String("gitee::owner")
			// No issue closing command is provided temporarily
			if closeFlag {
				success := CloseIssue(token, issueTmp.Repo, issueNum, owner)
				if success {
					//update issue tpl
					err = models.UpdateIssueTemplate(&issueTmp, "error_description")
					if err != nil {
						logs.Error(err)
						return
					}
				}
			}
		}
	} else {
		cBody = strings.ReplaceAll(cBody, "：", ":")
		analysisComment(issueNum, cuAccount, cBody, &payload)
	}
}

func isReviewer(path string) bool {
	sr := models.SecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func analysisComment(issueNum string, cuAccount string, cBody string, payload *models.CommentPayload) {
	issueId := payload.Issue.Id
	issueTmp := models.IssueTemplate{IssueNum: issueNum, IssueId: issueId}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num", "issue_id")
	if err != nil {
		logs.Error(err)
		return
	}
	if issueTmp.Status == 3 {
		// The issue has been closed and cannot be operated again
		logs.Error("The issue has been closed and cannot be operated again,issuetmp: ", issueTmp)
		return
	}
	canVerfy := false
	issueTmp.MtAuditFlag = 1
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	path := issueTmp.Repo
	//is Analyst comment and content start with '/analysis'
	vMap := util.ExtractCommentAnalysisAllValue(cBody)
	if len(vMap) > 0 {
		canVerfy = true
		cols := make([]string, 0)
		for k, v := range vMap {
			switch k {
			case "cve_analysis":
				if v != "" && len(v) > 1 {
					issueTmp.CveAnalysis = v
				}
				cols = append(cols, k)
			case "principle_analysis":
				issueTmp.PrincipleAnalysis = v
				cols = append(cols, k)
			case "openeuler_score":
				fv, err := strconv.ParseFloat(v, 64)
				if err == nil && fv > 0 {
					if issueTmp.OpenEulerScore > 0 && issueTmp.OpenEulerScore != fv {
						issueTmp.OpAuditFlag = 0
						cols = append(cols, "op_audit_flag")
					}
					issueTmp.OpenEulerScore = fv
					cols = append(cols, k)
				}
			case "openeuler_vector":
				if v != "" && len(v) > 1 {
					issueTmp.OpenEulerVector = v
				}
				cols = append(cols, k)
			case "affected_version":
				if v != "" && len(v) > 1 {
					if paraAffectBrandBool(v) {
						issueTmp.AffectedVersion = v
					}
				}
				cols = append(cols, k)
			case "solution":
				issueTmp.Solution = v
				cols = append(cols, k)
			}
		}
		if len(cols) > 0 {
			cols = append(cols, "mt_audit_flag")
			err := models.UpdateIssueTemplate(&issueTmp, cols...)
			if err != nil {
				logs.Error(err)
			} else {
				if _, ok := vMap["openeuler_vector"]; ok {
					err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
					if err != nil {
						logs.Error(err)
					}
				}
				if _, ok := vMap["openeuler_score"]; ok {
					//更新分数到 score
					score, err := models.QueryIssueScore(issueTmp.CveId)
					if err != nil {
						logs.Error(err)
					} else {
						score.OpenEulerScore = issueTmp.OpenEulerScore
						score.Ostatus = 1
						err := models.UpdateScore(&score, "openeuler_score", "o_score_status")
						if err != nil {
							logs.Error(err)
						}
					}
				}
			}
		}
		if _, ok := vMap["issue_package"]; ok {
			// handle comment package
			err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
			if err != nil {
				logs.Error(err)
			}
		}
		// update gitee issue
		commentUpdateIssue(issueTmp)
	}
	if canVerfy {
		//Check whether the data is legal
		if msg, tb, ok := checkIssueAnalysisComplete(&issueTmp); !ok {
			//send comment to issue
			issueTmp.IssueStatus = 1
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			assignee := ""
			if cuAccount != "" && len(cuAccount) > 1 {
				assignee = cuAccount
			} else {
				assignee = issueTmp.Assignee
			}
			msg = fmt.Sprintf(CommentAnalysisCplTpl, assignee, msg)
			taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)
		} else {
			//1. change issue status
			issueTmp.IssueStatus = 3
			//2. Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
			var na string
			if issueTmp.OpenEulerScore != issueTmp.NVDScore && issueTmp.OpenEulerScore > 0 &&
				issueTmp.NVDScore > 0 && issueTmp.OpAuditFlag == 0 {
				na = "\n**因OpenEulerScore与NvdScore不一致,分析内容需审核,请等待安全组审核!**"
				//Notify the responsible person for review
				notifyAuditorReview(payload, issueTmp)
			} else {
				if issueTmp.MtAuditFlag == 0 {
					maintainerList, mainOk := models.QueryRepoAllMaintainer(issueTmp.Repo)
					assList := []string{}
					if mainOk && len(maintainerList) > 0 {
						for _, v := range maintainerList {
							assList = append(assList, "@"+v.MemberName+" ")
							content := fmt.Sprintf("%v 仓库的CVE和安全问题的ISSUE,CVE编号: %v, "+
								"已经完成了模板填写,需要您对填写的内容进行审核,审核通过才能进行后续操作.", issueTmp.Repo, issueTmp.CveNum)
							taskhandler.SendPrivateLetters(accessToken, content, v.MemberName)
						}
					}
					assignee := ""
					if len(assList) > 0 {
						assignee = strings.Join(assList, ",")
					} else {
						assignee = "@" + issueTmp.Assignee
					}
					na = "\n**请确认模板分析内容的准确性与完整性, 确认无误后,请在评论区输入: /approve, 否则无法关闭当前issue.**"
					cc := fmt.Sprintf(ContentReview, assignee) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
				} else {
					na = "\n**请确认分析内容的准确性, 确认无误后, 您可以进行后续步骤, 否则您可以继续分析.**"
					cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
					taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
				}
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			}
		}
		err := models.UpdateIssueTemplate(&issueTmp, "issue_status", "mt_audit_flag")
		if err != nil {
			logs.Error(err)
		}
	}
}

func notifyAuditorReview(payload *models.CommentPayload, issueTmp models.IssueTemplate) {
	//Notify the responsible person for review
	list, err := models.GetSecurityReviewerList()
	if err != nil {
		logs.Error(err)
		return
	}
	if len(list) == 0 {
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	content := fmt.Sprintf(ReviewPrivateLettersTpl,
		payload.Issue.Title, payload.Issue.HtmlUrl, issueTmp.NVDScore, issueTmp.OpenEulerScore)
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	ns := make([]string, len(list))
	for k, v := range list {
		ns[k] = "@" + v.NameSpace + " "
		taskhandler.SendPrivateLetters(accessToken, content, v.NameSpace)
		//add @comment
	}
	msg := fmt.Sprintf(CommentReviewTpl, strings.Join(ns, ","))
	taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)

}

func changeOpenEulerScoreStatus(cveID int64, status int8) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	score.Ostatus = status
	err = models.UpdateScore(&score, "o_score_status")
	return err
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`

	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
		return
	}
	tbContent[0] = "已分析"
	tbContent[1] = "影响性分析说明"
	tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	if i.OpenEulerScore == 0.0 {
		msg = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
		ok = false
		return
	}
	tbContent[3] = "已分析"
	tbContent[4] = "openEulerScore"
	tbContent[5] = i.OpenEulerScore

	if i.OpenEulerVector == "" || len(i.OpenEulerVector) < 1 {
		msg = fmt.Sprintf("openEulerVector没有正确填写")
		ok = false
		return
	}
	tbContent[6] = "已分析"
	tbContent[7] = "openEulerVector"
	tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						continue
					} else {
						versionfFlag = false
						break
					}
				} else {
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
			return
		}
		if versionfFlag {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		} else {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func checkIssueClosedAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析 | 内容 |
|:--:|:--:|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`

	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if util.TrimString(i.CveAnalysis) == "" || len(util.TrimString(i.CveAnalysis)) < 1 {
		tbContent[0] = "待分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		msg = fmt.Sprintf("影响性分析说明没有填写或按正确格式填写")
		ok = false
	} else {
		tbContent[0] = "已分析"
		tbContent[1] = "影响性分析说明"
		tbContent[2] = util.TrimStringNR(i.CveAnalysis)
	}
	if i.OpenEulerScore == 0.0 {
		tbContent[3] = "待分析"
		tbContent[4] = "openEulerScore"
		tbContent[5] = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
		msg = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
		ok = false
	} else {
		tbContent[3] = "已分析"
		tbContent[4] = "openEulerScore"
		tbContent[5] = i.OpenEulerScore
	}
	if util.TrimString(i.OpenEulerVector) == "" || len(util.TrimString(i.OpenEulerVector)) < 1 {
		tbContent[6] = "待分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = fmt.Sprintf("openEulerVector没有正确填写")
		msg = fmt.Sprintf("openEulerVector没有正确填写")
		ok = false
	} else {
		tbContent[6] = "已分析"
		tbContent[7] = "openEulerVector"
		tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	}
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						continue
					} else {
						versionfFlag = false
						break
					}
				} else {
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
		} else {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	path := issueTmp.Repo
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveID int64) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	if util.RegexpVectorV2.Match([]byte(vct)) {
		//update v2 vector
		avv := util.ReadVMValueV2(vMap["AV"])
		if avv != "" {
			score.OaccessVector = avv
			upFields = append(upFields, "o_access_vector")
		}
		acv := util.ReadVMValueV2(vMap["AC"])
		if acv != "" {
			score.OaccessComplexity = acv
			upFields = append(upFields, "o_access_complexity")
		}
		au := util.ReadVMValueV2(vMap["Au"])
		if au != "" {
			score.Oauthentication = au
			upFields = append(upFields, "o_authentication")
		}
		cv := util.ReadVMValueV2(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValueV2(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValueV2(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	} else {
		//update v3 vector
		avv := util.ReadVMValue(vMap["AV"])
		if avv != "" {
			score.OattackVector = avv
			upFields = append(upFields, "o_attack_vector")
		}
		acv := util.ReadVMValue(vMap["AC"])
		if acv != "" {
			score.OattackComplexity = acv
			upFields = append(upFields, "o_attack_complexity")
		}
		prv := util.ReadVMValue(vMap["PR"])
		if prv != "" {
			score.OprivilegeRequired = prv
			upFields = append(upFields, "o_privilege_required")
		}
		uiv := util.ReadVMValue(vMap["UI"])
		if uiv != "" {
			score.OuserInteraction = uiv
			upFields = append(upFields, "o_user_interaction")
		}
		sv := util.ReadVMValue(vMap["S"])
		if sv != "" {
			score.Oscope = sv
			upFields = append(upFields, "o_scope")
		}
		cv := util.ReadVMValue(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValue(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValue(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	}
	if len(upFields) > 0 {
		//Perform update
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveID int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveID)
	if err != nil {
		return err
	}
	return nil
}

//CloseIssue close gitee issue
func CloseIssue(token, repo, issueNum, owner string) bool {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/issues/%s", owner, issueNum)
	param := struct {
		AccessToken string `json:"access_token"`
		Repo        string `json:"repo"`
		State       string `json:"state"`
	}{token, repo, "closed"}
	pj, err := json.Marshal(&param)
	if err != nil {
		logs.Error(err)
		return false
	}
	return UpdateGiteIssue(url, pj)
}

//ChangeIssueLabel update  issue label
func ChangeIssueLabel(token, repo, issueNum, owner, label string) bool {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/issues/%s", owner, issueNum)
	param := struct {
		AccessToken string `json:"access_token"`
		Repo        string `json:"repo"`
		Label       string `json:"labels"`
	}{token, repo, label}
	pj, err := json.Marshal(&param)
	if err != nil {
		logs.Error(err)
		return false
	}
	return UpdateGiteIssue(url, pj)
}

//UpdateGiteIssue update gitee issue
func UpdateGiteIssue(url string, param []byte) bool {
	read := bytes.NewReader(param)
	req, err := http.NewRequest(http.MethodPatch, url, read)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer req.Body.Close()
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		return true
	}
	return false
}
