package taskhandler

import (
	"cvevulner/models"
	"cvevulner/util"
	"encoding/csv"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

//CveExcel Excel export client
type CveExcel struct {
	ExcelName            string         //excel name
	ExcelHandel          *excelize.File //excel File handle
	CveSheetIdx          int            //CVE sheet index
	CveSheetName         string         // CVE sheet Name
	SecNoticeSheetIdx    int            //Security bulletin index
	SecNoticeSheetName   string         //Security bulletin sheet name
	SecNoticePrefix      string         //Security bulletin prefix
	SecNoticeSuffixIdx   int64          //Security bulletin suffix start value
	InfProductSheetName  string         //CVE Affected products
	InfProductSheetIndex int
	PackageURLSheetName  string
	PackageURLSheetIndex int
}

type IssueAndPkg struct {
	IssueMap map[int64]models.PullRequestIssue
	IssuePkg string
	Repo     string
}

var fillLock sync.Mutex
var wgTrigger sync.WaitGroup

//GenerateCveExcel Generate Excel documents based on data.
//param snPrefix means security notice prefix.
//param snSuffix means security notice suffix append start value.
//param forceRewrite means whether to force the document to be rewritten.
func GenerateCveExcel(excelName, snPrefix string, snSuffix int64, forceRewrite bool) (err error) {
	//Query the data to be exported.
	count := models.GetCanExportVulnCenterCount()
	if count < 1 {
		return errors.New("No data to export! ")
	}
	//init excelClient
	ec := CveExcel{}
	err = ec.Init(excelName, snPrefix, snSuffix)
	if err != nil {
		return err
	}
	mode := ec.InitFileHandle(forceRewrite)
	if mode == 0 {
		ec.InitSheet()
		err = ec.FillHeader()
		if err != nil {
			logs.Error(err)
		}
	}
	ec.FillContent(count)
	//generate excel
	return ec.Save(mode)
}

//GenerateCveExcelByTrigger Generate cve&security notice excel file by trigger
func GenerateCveExcelByTrigger(excelName, snPrefix, startTime string, snSuffix int64, forceRewrite bool, pkgList []models.ExcelPackage) (err error) {
	if len(pkgList) == 0 {
		return errors.New("No data to export! ")
	}
	//init excelClient
	ec := CveExcel{}
	err = ec.Init(excelName, snPrefix, snSuffix)
	if err != nil {
		return err
	}
	mode := ec.InitFileHandle(forceRewrite)
	if mode == 0 {
		ec.InitSheet()
		err = ec.FillHeader()
		if err != nil {
			logs.Error(err)
		}
	}
	ec.FillContentTrigger(pkgList, startTime)
	return ec.Save(mode)
}

//Init  init excel client
func (ec *CveExcel) Init(excelName, snPrefix string, snSuffix int64) (err error) {
	if excelName == "" || !(strings.HasSuffix(excelName, ".xlsx") || strings.HasSuffix(excelName, "xls")) {
		err = errors.New("excel name illegal")
		return
	}
	ec.ExcelName = excelName
	ec.SecNoticePrefix = snPrefix
	ec.SecNoticeSuffixIdx = snSuffix
	ec.CveSheetIdx = 0
	ec.CveSheetName = "CVE"
	ec.SecNoticeSheetIdx = 1
	ec.SecNoticeSheetName = "安全公告"
	ec.InfProductSheetIndex = 2
	ec.InfProductSheetName = "CVE影响的产品"
	ec.PackageURLSheetIndex = 3
	ec.PackageURLSheetName = "安全公告升级包链接"
	return nil
}

//InitFileHandle Initialize the file handle.
//param forceRewrite is true it means will create a new file otherwise it means append or new.
//the return value wm is 0 for new creation, and 1 for append.
func (ec *CveExcel) InitFileHandle(forceRewrite bool) (wm int8) {
	if forceRewrite {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	s, err := os.Stat(ec.ExcelName)
	if err != nil {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	if !s.IsDir() {
		file, err := excelize.OpenFile(ec.ExcelName)
		if err != nil {
			ec.ExcelHandel = excelize.NewFile()
			return 0
		}
		ec.ExcelHandel = file
		return 1

	}
	ec.ExcelHandel = excelize.NewFile()
	return 0

}

//InitSheet init excel sheet
func (ec *CveExcel) InitSheet() {
	ec.SecNoticeSheetIdx = ec.ExcelHandel.NewSheet(ec.SecNoticeSheetName)
	ec.InfProductSheetIndex = ec.ExcelHandel.NewSheet(ec.InfProductSheetName)
	ec.PackageURLSheetIndex = ec.ExcelHandel.NewSheet(ec.PackageURLSheetName)
	sn := ec.ExcelHandel.GetSheetName(ec.CveSheetIdx)
	ec.ExcelHandel.SetSheetName(sn, ec.CveSheetName)
}

//FillHeader fill the excel sheet header
func (ec *CveExcel) FillHeader() (err error) {
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "A1", "CVE编号")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "A1", "A2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "B1", "概要")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "B1", "B2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "C1", "Cvss Score")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "C1", "D1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "c2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "D2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E1", "Attack Vector")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "E1", "F1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "F2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G1", "Attack Complexity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "G1", "H1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "H2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I1", "Privileges Required")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "I1", "J1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "J2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K1", "User Interaction")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "K1", "L1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "L2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M1", "Scope")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "M1", "N1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "N2", "OpenEuler")
	if err != nil {
		return
	}

	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O1", "Confidentiality")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "O1", "P1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "P2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q1", "Integrity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "Q1", "R1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "R2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S1", "Availability")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "S1", "T1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "T2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "U1", "评分类型")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "U1", "U2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "V1", "安全公告")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "V1", "V2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "W1", "公告时间")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "W1", "W2")
	if err != nil {
		return
	}
	//Security bulletin header generation
	sh := []interface{}{"公告编号", "CVE编号", "简介", "概要", "主题", "描述", "影响组件", "影响产品", "影响包名", "参考", "公告时间"}
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, "A1", &sh)
	if err != nil {
		return err
	}
	ih := []interface{}{"CVE编号", "影响的产品", "包", "状态"}
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, "A1", &ih)
	if err != nil {
		return err
	}
	ph := []interface{}{"包名", "包下载链接"}
	err = ec.ExcelHandel.SetSheetRow(ec.PackageURLSheetName, "A1", &ph)
	if err != nil {
		return err
	}
	return nil
}

//FillContent fill the excel content
func (ec *CveExcel) FillContent(count int64) {
	pageSize := 50
	pageCount := count / int64(pageSize)
	if count%int64(pageSize) > 0 {
		pageCount++
	}
	for i := int64(0); i < pageCount; i++ {
		off := i * int64(pageSize)
		err := ec.handleWriteContent(off, pageSize)
		if err != nil {
			logs.Error(err)
		}
	}
}

func (ec *CveExcel) FillContentTrigger(pkgList []models.ExcelPackage, startTime string) {
	pl := len(pkgList)
	pageSize := 10
	pc := pl / 10
	if pl%10 > 0 {
		pc++
	}
	cd := make(chan []IssueAndPkg)
	start := 0
	end := 0
	for i := 0; i < pc; i++ {
		start = i * pageSize
		end = (i + 1) * pageSize
		if end > pl {
			end = pl
		}
		wgTrigger.Add(1)
		go getDateByGite(pkgList[start:end], startTime, cd)
	}
	for i := 0; i < pc; i++ {
		wgTrigger.Add(1)
		go ec.handleGiteData(cd)
	}
	wgTrigger.Wait()
	logs.Error("cve_gen_finish")
}

func (ec *CveExcel) handleWriteContent(off int64, size int) (err error) {
	list, err := models.GetCanExportCveData(off, size)
	if err != nil {
		return err
	}
	lz := len(list)
	if lz > 0 {
		for _, v := range list {
			if v.Num == 1 {
				ec.setContentRow(v)
			} else if v.Num > 1 {
				//1.Obtain issue_tpl according to cve_num, if all issue_status == 2 0r issue_status == 6, then data can be exported
				list, err := models.GetIssueTplByCveNum(v.CveNum)
				if err != nil {
					logs.Error(err)
					continue
				}
				mergerList := make([]string, 0)
				canMerger := true
				for _, t := range list {
					if t.Status != 3 && t.Status != 4 {
						canMerger = false
						break
					}
					if t.IssueStatus == 2 {
						mergerList = append(mergerList, strconv.FormatInt(t.CveId, 10))
					}

				}
				//2.Find the corresponding ExcelExport data with the highest score from the template data of issue_status == 2
				if canMerger && len(mergerList) > 0 {
					canExport, err := models.GetCanExportCveDataSameNum(strings.Join(mergerList, ","))
					if err != nil {
						logs.Error(err)
					}
					ep := canExport[0]
					if len(canExport) > 1 {
						canExport = canExport[1:]
						for _, ex := range canExport {
							ep.Introduction = ep.Introduction + "\n" + ex.Introduction
							ep.Summary = ep.Summary + "\n" + ex.Summary
							ep.Theme = ep.Theme + "\n" + ex.Theme
							ep.Description = ep.Description + "\n" + ex.Description
							ep.OwnedComponent = ep.OwnedComponent + "\n" + ex.OwnedComponent
							ep.InfluenceComponent = ep.InfluenceComponent + "\n" + ex.InfluenceComponent
							ep.AffectProduct = ep.AffectProduct + "\n" + ex.AffectProduct
						}
					}
					ec.setContentRow(ep)
				}
			}
		}
	}
	return nil
}

func (ec *CveExcel) handleWriteContentSync(list []models.ExcelExport) (err error) {
	lz := len(list)
	if lz > 0 {
		for _, v := range list {
			if v.Num == 1 {
				fillLock.Lock()
				ec.setContentRow(v)
				fillLock.Unlock()
			} else if v.Num > 1 {
				//处理CVE_NUM 重复
				//1.根据cve_num 获取issue_tpl 如果所有的issue_status ==2 0r issue_status == 6 则可以导出数据
				list, err := models.GetIssueTplByCveNum(v.CveNum)
				if err != nil {
					logs.Error(err)
					continue
				}
				mergerList := make([]string, 0)
				canMerger := true
				for _, t := range list {
					if t.Status != 3 && t.Status != 4 {
						canMerger = false
						break
					}
					if t.IssueStatus == 2 {
						mergerList = append(mergerList, strconv.FormatInt(t.CveId, 10))
					}

				}
				//2.从issue_status == 2 的模板数据中找到评分最高的对应的ExcelExport数据
				if canMerger && len(mergerList) > 0 {
					canExport, err := models.GetCanExportCveDataSameNum(strings.Join(mergerList, ","))
					if err != nil {
						logs.Error(err)
					}
					ep := canExport[0]
					ep.SecID = v.SecID
					if len(canExport) > 1 {
						canExport = canExport[1:]
						m := make(map[string]struct{})
						m[ep.OwnedComponent] = struct{}{}
						for _, ex := range canExport {
							//component repeat do not append
							if _, ok := m[ex.OwnedComponent]; !ok {
								ep.Introduction = ep.Introduction + "\n" + ex.Introduction
								ep.Summary = ep.Summary + "\n" + ex.Summary
								ep.Theme = ep.Theme + "\n" + ex.Theme
								ep.Description = ep.Description + "\n" + ex.Description
								ep.InfluenceComponent = ep.InfluenceComponent + "\n" + ex.InfluenceComponent
								ep.AffectProduct = ep.AffectProduct + "\n" + ex.AffectProduct
								ep.OwnedComponent = ep.OwnedComponent + "\n" + ex.OwnedComponent
								m[ex.OwnedComponent] = struct{}{}
							}
						}
					}
					fillLock.Lock()
					ec.setContentRow(ep)
					fillLock.Unlock()
				}
			}

		}
	}
	return nil
}

func (ec *CveExcel) setContentRow(v models.ExcelExport) {
	pkg, err := models.GetCvePackageList(v.SecID)
	if err != nil {
		logs.Error(err)
	}
	if v.PublicDate == "" {
		v.PublicDate = time.Now().Format("2006-01-02")
	}
	pkgStr := getPkgStr(pkg)
	sn := []interface{}{v.OpenEulerSANum, v.CveNum, v.Introduction, v.Summary, v.Theme, v.Description, v.InfluenceComponent,
		v.AffectProduct, pkgStr, v.ReferenceLink, v.PublicDate}
	axis, searched := ec.searchValueInSheet(ec.SecNoticeSheetName, v.InfluenceComponent)
	if !searched {
		err = ec.fillSecurityNoticeSheet(sn)
		if err != nil {
			logs.Error(err)
		}
	} else {
		//merge openEuler SA notice data
		colReg := regexp.MustCompile(`[A-Z]*`)
		col := colReg.FindString(axis)
		row := strings.Trim(axis, col)
		rCN := "B" + row
		rRl := "J" + row
		vcn, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rCN)
		vcn += ";\n" + v.CveNum
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rCN, vcn)
		vrl, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rRl)
		vrl += "\n" + v.ReferenceLink
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rRl, vrl)
		rSAN := fmt.Sprintf("A%s", row)
		vSAN, cellError := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rSAN)
		if cellError == nil {
			v.OpenEulerSANum = vSAN
		}
		//merger description
		rd := "F" + row
		vd, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rd)
		dSplit := strings.Split(v.Description, "Security Fix(es):")
		if len(dSplit) > 1 {
			if !strings.Contains(vd, dSplit[0]) {
				vd = dSplit[0] + vd
			}
			vd += dSplit[1]
		}
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, vd)
		//Get the highest-rated theme
		rd = "E" + row
		theme, err := models.GetCanExportTheme(vcn, v.OwnedComponent)
		if err == nil {
			_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, theme)
		}
	}
	cve := []interface{}{v.CveNum, v.CveBrief, v.NVDScore, v.OpenEulerScore, v.NattackVector, v.OattackVector,
		v.NattackComplexity, v.OattackComplexity, v.NprivilegeRequired, v.OprivilegeRequired, v.NuserInteraction,
		v.OuserInteraction, v.Nscope, v.Oscope, v.Nconfidentiality, v.Oconfidentiality, v.Nintegrity, v.Ointegrity,
		v.Navailability, v.Oavailability, v.ScoreType, v.OpenEulerSANum, v.PublicDate}
	err = ec.fillCveSheetRow(cve)
	if err != nil {
		logs.Error(err)
	}

	ap := []interface{}{v.CveNum, v.AffectProduct, v.InfluenceComponent, v.AffectStatus}
	err = ec.fillAffectProductSheet(ap)
	if err != nil {
		logs.Error(err)
	}
	for _, v := range pkg {
		pk := []interface{}{v.PackName, v.PackUrl}
		if _, ok := ec.searchValueInSheet(ec.PackageURLSheetName, v.PackName); !ok {
			err := ec.fillPackageSheet(pk)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func getPkgStr(pkg []models.Package) string {
	pkgStr := ""
	if len(pkg) == 0 {
		return pkgStr
	}
	var ps []string
	for _, v := range pkg {
		if v.PackName != "" {
			ps = append(ps, v.PackName)
		}
	}
	return strings.Join(ps, ";\n")
}

func (ec *CveExcel) searchValueInSheet(sheetName, value string) (axis string, searched bool) {
	if value == "" {
		return
	}
	sheet, err := ec.ExcelHandel.SearchSheet(sheetName, value)
	if err != nil {
		return
	}
	if len(sheet) > 0 {
		for _, k := range sheet {
			cellValue, _ := ec.ExcelHandel.GetCellValue(sheetName, k)
			if cellValue == value {
				searched = true
				axis = k
				break
			}
		}
		return
	}
	return
}

func (ec *CveExcel) fillCveSheetRow(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.CveSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.CveSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillSecurityNoticeSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.SecNoticeSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillAffectProductSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.InfProductSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillPackageSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.PackageURLSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.PackageURLSheetName, axis, &row)
	return err
}

//Save save the excel content to file
func (ec *CveExcel) Save(md int8) error {
	if md == 0 {
		return ec.ExcelHandel.SaveAs(ec.ExcelName)
	}
	return ec.ExcelHandel.Save()

}

//ExtractPackageData extract the package data by csv file
func ExtractPackageData(lp string) (pkgList []models.ExcelPackage, err error) {
	pkgLock.Lock()
	defer pkgLock.Unlock()
	if lp == "" || path.Ext(lp) != ".CSV" {
		return pkgList, errors.New("the file path is error")
	}
	file, err := os.Open(lp)
	if err != nil {
		return pkgList, err
	}
	defer file.Close()
	reader := csv.NewReader(file)
	for {
		line, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			return pkgList, err
		}
		pkgList = append(pkgList, models.ExcelPackage{PubTime: line[0], Repo: line[1], Packages: line[2]})
	}
	return
}

func getDateByGite(pkgList []models.ExcelPackage, startTime string, c chan<- []IssueAndPkg) {
	defer wgTrigger.Done()
	token := beego.AppConfig.String("gitee::git_token")
	//token := "8457c66db66955376519059b97e33dd1"
	owner := beego.AppConfig.String("gitee::owner")
	//owner := "src-openeuler"
	st := util.TimeStrToInt(startTime, "2006-01-02")
	chData := make([]IssueAndPkg, 0)
	for _, v := range pkgList {
		rt := util.TimeStrToInt(v.PubTime, "20060102 15-04-05")
		prList := getRepoAllPR(token, owner, v.Repo, st, rt)
		//get pull request related issue
		repoIssue := make(map[int64]models.PullRequestIssue, 0)
		for _, p := range prList {
			getPRRelatedAllIssue(token, owner, v.Repo, st, rt, p.Number, repoIssue)
		}
		if len(repoIssue) > 0 {
			chData = append(chData, IssueAndPkg{IssueMap: repoIssue, IssuePkg: v.Packages, Repo: v.Repo})
		}
	}
	c <- chData
}

func (ec *CveExcel) handleGiteData(c <-chan []IssueAndPkg) {
	defer wgTrigger.Done()
	data := <-c
	var pkgList []string

	for _, v := range data {
		//parse package string to list
		pkgList = strings.Split(v.IssuePkg, " ")
		if len(pkgList) == 0 {
			continue
		}
		for _, iv := range v.IssueMap {
			tpl := models.IssueTemplate{IssueNum: iv.Number, Repo: iv.Repo}
			err := models.GetIssueTemplateByColName(&tpl, "issue_num", "repo")
			if err != nil {
				logs.Error("----",err)
				continue
			}
			err = models.ReplacePackageByCveId(pkgList, tpl.CveId)
			if err != nil {
				logs.Info(err)
				continue
			}
			//save data to excel
			el, err := models.GetCanExportExcelData(tpl.CveNum, tpl.IssueNum)
			if err != nil {
				logs.Error(err)
				return
			}
			err = ec.handleWriteContentSync(el)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func getRepoAllPR(token, owner, repo string, startTime, releaseTime int64) (prList []models.PullRequest) {
	pageSize := 20
	pageCount := 1
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/%s/pulls", owner, repo)
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error(err)
		return
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("sort", "created")
	q.Add("state", "merged")
	q.Add("per_page", strconv.Itoa(pageSize))
	q.Add("base", "openEuler-20.03-LTS") //target branch is openEuler-20.03-LTS
	for {
		q.Del("page")
		q.Add("page", strconv.Itoa(pageCount))
		req.URL.RawQuery = q.Encode()
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			logs.Error(err)
			break
		}
		if resp.StatusCode == http.StatusOK {
			pr := make([]models.PullRequest, 0)
			read, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				logs.Error(err)
				break
			}
			resp.Body.Close()
			err = json.Unmarshal(read, &pr)
			if err != nil {
				logs.Error(err)
				break
			}
			for _, v := range pr {

				ct := v.MergedAt.Local().Unix()
				if ct >= startTime && ct <= releaseTime {
					prList = append(prList, v)
				}
			}
			if len(pr) < pageSize {
				break
			}
			pageCount++
		} else {
			resp.Body.Close()
			break
		}
	}
	return
}

func getPRRelatedAllIssue(token, owner, repo string, startTime, releaseTime int64, num int, issueList map[int64]models.PullRequestIssue) {
	if issueList == nil {
		return
	}
	url := fmt.Sprintf(`https://gitee.com/api/v5/repos/%s/%s/pulls/%v/issues`, owner, repo, num)
	pageSize := 20
	pageCount := 1
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error(err)
		return
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("per_page", strconv.Itoa(pageSize))
	for {
		q.Del("page")
		q.Add("page", strconv.Itoa(pageCount))
		req.URL.RawQuery = q.Encode()
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			logs.Error(err)
			break
		}
		if resp.StatusCode == http.StatusOK {
			var il []models.HookIssue
			read, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				logs.Error(err)
				break
			}
			err = json.Unmarshal(read, &il)
			if err != nil {
				logs.Error(err)
				break
			}
			for _, v := range il {
				d, ok := isLegallyIssue(v, startTime, releaseTime)
				if ok {
					issueList[d.Id] = d
				}
			}
			if len(il) < pageSize {
				break
			}
			pageCount++
		} else {
			resp.Body.Close()
			break
		}
	}
}

func isLegallyIssue(i models.HookIssue, startTime int64, releaseTime int64) (pri models.PullRequestIssue, ok bool) {
	if i.IssueType != IssueType || i.State != "closed" {
		return
	}
	ft := i.FinishedAt.Unix()
	if startTime > ft || ft > releaseTime {
		return
	}
	tt := strings.Trim(i.Title, " ")
	regCveNum := regexp.MustCompile(`(?mi)CVE-[\d]{1,}-([\d]{1,})$`)
	/*if tt != "" && regCveNum.Match([]byte(tt)) {
		ok = true
	} else {*/
	sm := util.RegexpCveNumber.FindAllStringSubmatch(i.Body, -1)
	if len(sm) > 0 && len(sm[0]) > 0 {
		val := sm[0][1]
		tt = util.GetCveNumber(util.TrimString(val))
		if tt != "" && regCveNum.Match([]byte(tt)) {
			ok = true
		}
	}
	//}
	if ok {
		pri.Id = i.Id
		pri.Number = i.Number
		pri.CveNumber = tt
		pri.Repo = i.Repository.Path
	}
	return
}
