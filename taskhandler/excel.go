package taskhandler

import (
	"cvevulner/models"
	"cvevulner/util"
	"encoding/csv"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

//CveExcel Excel export client
type CveExcel struct {
	ExcelName            string         //excel name
	ExcelHandel          *excelize.File //excel File handle
	CveSheetIdx          int            //CVE sheet index
	CveSheetName         string         // CVE sheet Name
	SecNoticeSheetIdx    int            //Security bulletin index
	SecNoticeSheetName   string         //Security bulletin sheet name
	SecNoticePrefix      string         //Security bulletin prefix
	SecNoticeSuffixIdx   int64          //Security bulletin suffix start value
	InfProductSheetName  string         //CVE Affected products
	InfProductSheetIndex int
	PackageURLSheetName  string
	PackageURLSheetIndex int
}

type IssueAndPkg struct {
	IssueMap map[int64]models.PullRequestIssue
	IssuePkg string
	Repo     string
}

var fillLock sync.Mutex
var wgTrigger sync.WaitGroup

//GenerateCveExcel Generate Excel documents based on data.
//param snPrefix means security notice prefix.
//param snSuffix means security notice suffix append start value.
//param forceRewrite means whether to force the document to be rewritten.
func GenerateCveExcel(excelName, snPrefix string, snSuffix int64, forceRewrite bool) (err error) {
	//Query the data to be exported.
	count := models.GetCanExportVulnCenterCount()
	if count < 1 {
		return errors.New("No data to export! ")
	}
	//init excelClient
	ec := CveExcel{}
	err = ec.Init(excelName, snPrefix, snSuffix)
	if err != nil {
		return err
	}
	mode := ec.InitFileHandle(forceRewrite)
	if mode == 0 {
		ec.InitSheet()
		err = ec.FillHeader()
		if err != nil {
			logs.Error(err)
		}
	}
	ec.FillContent(count)
	//generate excel
	return ec.Save(mode)
}

//GenerateCveExcelByTrigger Generate cve&security notice excel file by trigger
func GenerateCveExcelByTrigger(affectBranch, excelName, snPrefix, startTime string, snSuffix int64,
	forceRewrite bool, pkgList []models.ExcelPackage) (err error) {
	if len(pkgList) == 0 {
		return errors.New("No data to export! ")
	}
	//init excelClient
	ec := CveExcel{}
	err = ec.Init(excelName, snPrefix, snSuffix)
	if err != nil {
		return err
	}
	mode := ec.InitFileHandle(forceRewrite)
	if mode == 0 {
		ec.InitSheet()
		err = ec.FillHeader()
		if err != nil {
			logs.Error(err)
		}
	}
	ec.FillContentTrigger(pkgList, startTime, affectBranch)
	return ec.Save(mode)
}

//Init  init excel client
func (ec *CveExcel) Init(excelName, snPrefix string, snSuffix int64) (err error) {
	if excelName == "" || !(strings.HasSuffix(excelName, ".xlsx") || strings.HasSuffix(excelName, "xls")) {
		err = errors.New("excel name illegal")
		return
	}
	ec.ExcelName = excelName
	ec.SecNoticePrefix = snPrefix
	ec.SecNoticeSuffixIdx = snSuffix
	ec.CveSheetIdx = 0
	ec.CveSheetName = "CVE"
	ec.SecNoticeSheetIdx = 1
	ec.SecNoticeSheetName = "安全公告"
	ec.InfProductSheetIndex = 2
	ec.InfProductSheetName = "CVE影响的产品"
	ec.PackageURLSheetIndex = 3
	ec.PackageURLSheetName = "安全公告升级包链接"
	return nil
}

//InitFileHandle Initialize the file handle.
//param forceRewrite is true it means will create a new file otherwise it means append or new.
//the return value wm is 0 for new creation, and 1 for append.
func (ec *CveExcel) InitFileHandle(forceRewrite bool) (wm int8) {
	if forceRewrite {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	s, err := os.Stat(ec.ExcelName)
	if err != nil {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	if !s.IsDir() {
		file, err := excelize.OpenFile(ec.ExcelName)
		if err != nil {
			ec.ExcelHandel = excelize.NewFile()
			return 0
		}
		ec.ExcelHandel = file
		return 1

	}
	ec.ExcelHandel = excelize.NewFile()
	return 0

}

//InitSheet init excel sheet
func (ec *CveExcel) InitSheet() {
	ec.SecNoticeSheetIdx = ec.ExcelHandel.NewSheet(ec.SecNoticeSheetName)
	ec.InfProductSheetIndex = ec.ExcelHandel.NewSheet(ec.InfProductSheetName)
	ec.PackageURLSheetIndex = ec.ExcelHandel.NewSheet(ec.PackageURLSheetName)
	sn := ec.ExcelHandel.GetSheetName(ec.CveSheetIdx)
	ec.ExcelHandel.SetSheetName(sn, ec.CveSheetName)
}

//FillHeader fill the excel sheet header
func (ec *CveExcel) FillHeader() (err error) {
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "A1", "CVE编号")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "A1", "A2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "B1", "概要")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "B1", "B2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "C1", "Cvss Score")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "C1", "D1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "c2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "D2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E1", "Attack Vector")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "E1", "F1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "F2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G1", "Attack Complexity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "G1", "H1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "H2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I1", "Privileges Required")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "I1", "J1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "J2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K1", "User Interaction")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "K1", "L1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "L2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M1", "Scope")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "M1", "N1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "N2", "OpenEuler")
	if err != nil {
		return
	}

	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O1", "Confidentiality")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "O1", "P1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "P2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q1", "Integrity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "Q1", "R1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "R2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S1", "Availability")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "S1", "T1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "T2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "U1", "评分类型")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "U1", "U2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "V1", "安全公告")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "V1", "V2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "W1", "公告时间")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "W1", "W2")
	if err != nil {
		return
	}
	//Security bulletin header generation
	sh := []interface{}{"公告编号", "CVE编号", "简介", "概要", "主题", "描述", "影响组件", "影响产品", "影响包名", "参考", "公告时间"}
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, "A1", &sh)
	if err != nil {
		return err
	}
	ih := []interface{}{"CVE编号", "影响的产品", "包", "状态"}
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, "A1", &ih)
	if err != nil {
		return err
	}
	ph := []interface{}{"包名", "包下载链接"}
	err = ec.ExcelHandel.SetSheetRow(ec.PackageURLSheetName, "A1", &ph)
	if err != nil {
		return err
	}
	return nil
}

//FillContent fill the excel content
func (ec *CveExcel) FillContent(count int64) {
	pageSize := 50
	pageCount := count / int64(pageSize)
	if count%int64(pageSize) > 0 {
		pageCount++
	}
	for i := int64(0); i < pageCount; i++ {
		off := i * int64(pageSize)
		err := ec.handleWriteContent(off, pageSize)
		if err != nil {
			logs.Error(err)
		}
	}
}

func (ec *CveExcel) FillContentTrigger(pkgList []models.ExcelPackage, startTime, affectBranch string) {
	pl := len(pkgList)
	pageSize := 10
	pc := pl / 10
	if pl%10 > 0 {
		pc++
	}
	var cvexml []CveXml
	var dpdates Updates
	securityNotice := make(map[string][]SecurityNoticeXml)
	packRpmx := make(map[string][]PackRpm)
	filePath := beego.AppConfig.String("xml::updateinfo_path")
	ReadXml(filePath, &dpdates)
	cd := make(chan []IssueAndPkg)
	start := 0
	end := 0
	for i := 0; i < pc; i++ {
		start = i * pageSize
		end = (i + 1) * pageSize
		if end > pl {
			end = pl
		}
		wgTrigger.Add(1)
		go getDateByGite(pkgList[start:end], startTime, cd, affectBranch)
	}
	for i := 0; i < pc; i++ {
		wgTrigger.Add(1)
		go ec.handleGiteData(cd, affectBranch, &cvexml, &dpdates, securityNotice, packRpmx)
	}
	wgTrigger.Wait()
	// write xml
	WriteXml(filePath, cvexml, &dpdates, securityNotice, packRpmx)
	logs.Info("cve_gen_finish")
}

func fileExist(fileList []string) bool {
	if len(fileList) > 0 {
		for _, filex := range fileList {
			_, isErr := os.Stat(filex)
			if isErr != nil {
				return false
			}
		}
	}
	return true
}

func delFile(fileList []string) {
	if len(fileList) > 0 {
		for _, filex := range fileList {
			err := os.Remove(filex)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func (ec *CveExcel) handleWriteContent(off int64, size int) (err error) {
	list, err := models.GetCanExportCveData(off, size)
	if err != nil {
		return err
	}
	lz := len(list)
	if lz > 0 {
		for _, v := range list {
			if v.Num == 1 {
				ec.setContentRow(v)
			} else if v.Num > 1 {
				//1.Obtain issue_tpl according to cve_num, if all issue_status == 2 0r issue_status == 6, then data can be exported
				list, err := models.GetIssueTplByCveNum(v.CveNum)
				if err != nil {
					logs.Error(err)
					continue
				}
				mergerList := make([]string, 0)
				canMerger := true
				for _, t := range list {
					if t.Status != 3 && t.Status != 4 {
						canMerger = false
						break
					}
					if t.IssueStatus == 2 {
						mergerList = append(mergerList, strconv.FormatInt(t.CveId, 10))
					}

				}
				//2.Find the corresponding ExcelExport data with the highest score from the template data of issue_status == 2
				if canMerger && len(mergerList) > 0 {
					canExport, err := models.GetCanExportCveDataSameNum(strings.Join(mergerList, ","))
					if err != nil {
						logs.Error(err)
					}
					ep := canExport[0]
					if len(canExport) > 1 {
						canExport = canExport[1:]
						for _, ex := range canExport {
							ep.Introduction = ep.Introduction + "\n" + ex.Introduction
							ep.Summary = ep.Summary + "\n" + ex.Summary
							ep.Theme = ep.Theme + "\n" + ex.Theme
							ep.Description = ep.Description + "\n" + ex.Description
							ep.OwnedComponent = ep.OwnedComponent + "\n" + ex.OwnedComponent
							ep.InfluenceComponent = ep.InfluenceComponent + "\n" + ex.InfluenceComponent
							ep.AffectProduct = ep.AffectProduct + "\n" + ex.AffectProduct
						}
					}
					ec.setContentRow(ep)
				}
			}
		}
	}
	return nil
}

func (ec *CveExcel) handleWriteContentSync(list []models.ExcelExport,
	affectBranch string, cvexml *[]CveXml, dpdates *Updates,
	securityNotice map[string][]SecurityNoticeXml, packRpmx map[string][]PackRpm) (err error) {
	lz := len(list)
	if lz > 0 {
		for _, v := range list {
			affectBool := affectBrachRep(&v, affectBranch)
			if !affectBool {
				logs.Error("Unaffected version, data: ", v)
				continue
			}
			if v.Num == 1 {
				fillLock.Lock()
				ec.setContentRow(v)
				fillLock.Unlock()
				fillLock.Lock()
				BuildXml(cvexml, &v, securityNotice, packRpmx)
				fillLock.Unlock()
			} else if v.Num > 1 {
				//处理CVE_NUM 重复
				//1.根据cve_num 获取issue_tpl 如果所有的issue_status ==2 0r issue_status == 6 则可以导出数据
				list, err := models.GetIssueTplByCveNum(v.CveNum)
				if err != nil {
					logs.Error("GetIssueTplByCveNum, err: ", err)
					continue
				}
				mergerList := make([]string, 0)
				canMerger := true
				for _, t := range list {
					if t.Status != 3 && t.Status != 4 {
						canMerger = false
						break
					}
					if t.IssueStatus == 2 {
						mergerList = append(mergerList, strconv.FormatInt(t.CveId, 10))
					}
				}
				//2.从issue_status == 2 的模板数据中找到评分最高的对应的ExcelExport数据
				if canMerger && len(mergerList) > 0 {
					canExport, err := models.GetCanExportCveDataSameNum(strings.Join(mergerList, ","))
					if err != nil {
						logs.Error("GetCanExportCveDataSameNum, err: ", err)
					}
					// Fill in the content of the xml file
					addXmlData(canExport, cvexml, affectBranch, securityNotice, packRpmx)
					// Fill in the content of the excel file
					ep := canExport[0]
					ep.SecID = v.SecID
					if ep.AffectProduct != "" && len(ep.AffectProduct) > 1 {
						if ep.AffectProduct != affectBranch {
							ep.Introduction = strings.ReplaceAll(ep.Introduction, ep.AffectProduct, affectBranch)
							ep.Theme = strings.ReplaceAll(ep.Theme, ep.AffectProduct, affectBranch)
							ep.AffectProduct = affectBranch
						}
					}
					if len(canExport) > 1 {
						canExport = canExport[1:]
						m := make(map[string]struct{})
						m[ep.OwnedComponent] = struct{}{}
						for _, ex := range canExport {
							affectBool := affectBrachRep(&ex, affectBranch)
							if !affectBool {
								logs.Error("Unaffected version, data: ", ex)
								continue
							}
							//component repeat do not append
							if _, ok := m[ex.OwnedComponent]; !ok {
								ep.Introduction = ep.Introduction + "\n" + ex.Introduction
								ep.Summary = ep.Summary + "\n" + ex.Summary
								ep.Theme = ep.Theme + "\n" + ex.Theme
								ep.Description = ep.Description + "\n" + ex.Description
								ep.InfluenceComponent = ep.InfluenceComponent + "\n" + ex.InfluenceComponent
								ep.AffectProduct = ep.AffectProduct + "\n" + ex.AffectProduct
								ep.OwnedComponent = ep.OwnedComponent + "\n" + ex.OwnedComponent
								m[ex.OwnedComponent] = struct{}{}
							}
						}
					}
					fillLock.Lock()
					ec.setContentRow(ep)
					fillLock.Unlock()
				}
			}
		}
	}
	return nil
}

func affectBrachRep(xmlp *models.ExcelExport, affectBranch string) bool {
	affectBool := false
	if xmlp.AffectProduct != "" && len(xmlp.AffectProduct) > 1 {
		if xmlp.AffectProduct != affectBranch {
			affectBranchsxList := strings.Split(xmlp.AffectProduct, "/")
			for _, ab := range affectBranchsxList {
				if ab == affectBranch {
					affectBool = true
					xmlp.Introduction = strings.ReplaceAll(xmlp.Introduction, xmlp.AffectProduct, affectBranch)
					xmlp.Theme = strings.ReplaceAll(xmlp.Theme, xmlp.AffectProduct, affectBranch)
					xmlp.AffectProduct = affectBranch
				}
			}
		} else {
			affectBool = true
		}
	}
	return affectBool
}

func addXmlData(canExport []models.ExcelExport, cvexml *[]CveXml, affectBranch string,
	securityNotice map[string][]SecurityNoticeXml, packRpmx map[string][]PackRpm) {
	for _, xmlp := range canExport {
		affectBool := affectBrachRep(&xmlp, affectBranch)
		if !affectBool {
			logs.Error("Unaffected version, data: ", xmlp)
			continue
		}
		fillLock.Lock()
		BuildXml(cvexml, &xmlp, securityNotice, packRpmx)
		fillLock.Unlock()
	}
}

func (ec *CveExcel) setContentRow(v models.ExcelExport) {
	pkg, pkgErr := models.GetCvePackageList(v.SecID)
	if pkgErr != nil {
		logs.Error(pkgErr)
	}
	if v.PublicDate == "" {
		v.PublicDate = time.Now().Format("2006-01-02")
	}
	pkgStr := getPkgStr(pkg)
	sn := []interface{}{v.OpenEulerSANum, v.CveNum, v.Introduction, v.Summary, v.Theme, v.Description, v.InfluenceComponent,
		v.AffectProduct, pkgStr, v.ReferenceLink, v.PublicDate}
	axis, searched := ec.searchValueInSheet(ec.SecNoticeSheetName, v.InfluenceComponent)
	if !searched {
		fillErr := ec.fillSecurityNoticeSheet(sn)
		if fillErr != nil {
			logs.Error(fillErr)
		}
	} else {
		//merge openEuler SA notice data
		colReg := regexp.MustCompile(`[A-Z]*`)
		col := colReg.FindString(axis)
		row := strings.Trim(axis, col)
		rCN := "B" + row
		rRl := "J" + row
		vcn, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rCN)
		vcn += ";\n" + v.CveNum
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rCN, vcn)
		vrl, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rRl)
		vrl += "\n" + v.ReferenceLink
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rRl, vrl)
		rSAN := fmt.Sprintf("A%s", row)
		vSAN, cellError := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rSAN)
		if cellError == nil {
			v.OpenEulerSANum = vSAN
		}
		//merger description
		rd := "F" + row
		vd, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rd)
		dSplit := strings.Split(v.Description, "Security Fix(es):")
		if len(dSplit) > 1 {
			if !strings.Contains(vd, dSplit[0]) {
				vd = dSplit[0] + vd
			}
			vd += dSplit[1]
		}
		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, vd)
		//Get the highest-rated theme
		rd = "E" + row
		theme, err := models.GetCanExportTheme(vcn, v.OwnedComponent)
		if err == nil {
			_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, theme)
		}
	}
	cve := []interface{}{v.CveNum, v.CveBrief, v.NVDScore, v.OpenEulerScore, v.NattackVector, v.OattackVector,
		v.NattackComplexity, v.OattackComplexity, v.NprivilegeRequired, v.OprivilegeRequired, v.NuserInteraction,
		v.OuserInteraction, v.Nscope, v.Oscope, v.Nconfidentiality, v.Oconfidentiality, v.Nintegrity, v.Ointegrity,
		v.Navailability, v.Oavailability, v.ScoreType, v.OpenEulerSANum, v.PublicDate}
	shErr := ec.fillCveSheetRow(cve)
	if shErr != nil {
		logs.Error(shErr)
	}

	ap := []interface{}{v.CveNum, v.AffectProduct, v.InfluenceComponent, v.AffectStatus}
	err := ec.fillAffectProductSheet(ap)
	if err != nil {
		logs.Error(err)
	}
	for _, v := range pkg {
		pk := []interface{}{v.PackName, v.PackUrl}
		if _, ok := ec.searchValueInSheet(ec.PackageURLSheetName, v.PackName); !ok {
			err := ec.fillPackageSheet(pk)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func getPkgStr(pkg []models.Package) string {
	pkgStr := ""
	if len(pkg) == 0 {
		return pkgStr
	}
	var ps []string
	for _, v := range pkg {
		if v.PackName != "" {
			ps = append(ps, v.PackName)
		}
	}
	return strings.Join(ps, ";\n")
}

func (ec *CveExcel) searchValueInSheet(sheetName, value string) (axis string, searched bool) {
	if value == "" {
		return
	}
	sheet, err := ec.ExcelHandel.SearchSheet(sheetName, value)
	if err != nil {
		return
	}
	if len(sheet) > 0 {
		for _, k := range sheet {
			cellValue, _ := ec.ExcelHandel.GetCellValue(sheetName, k)
			if cellValue == value {
				searched = true
				axis = k
				break
			}
		}
		return
	}
	return
}

func (ec *CveExcel) fillCveSheetRow(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.CveSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.CveSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillSecurityNoticeSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.SecNoticeSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillAffectProductSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.InfProductSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, axis, &row)
	return err
}

func (ec *CveExcel) fillPackageSheet(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.PackageURLSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.PackageURLSheetName, axis, &row)
	return err
}

//Save save the excel content to file
func (ec *CveExcel) Save(md int8) error {
	if md == 0 {
		return ec.ExcelHandel.SaveAs(ec.ExcelName)
	}
	return ec.ExcelHandel.Save()

}

//ExtractPackageData extract the package data by csv file
func ExtractPackageData(lp string) (pkgList []models.ExcelPackage, err error) {
	pkgLock.Lock()
	defer pkgLock.Unlock()
	if lp == "" || path.Ext(lp) != ".CSV" {
		return pkgList, errors.New("the file path is error")
	}
	file, err := os.Open(lp)
	if err != nil {
		return pkgList, err
	}
	defer file.Close()
	reader := csv.NewReader(file)
	for {
		line, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			return pkgList, err
		}
		pkgList = append(pkgList, models.ExcelPackage{PubTime: line[0], Repo: line[1], Packages: line[2]})
	}
	return
}

func getDateByGite(pkgList []models.ExcelPackage, startTime string, c chan<- []IssueAndPkg, affectBranch string) {
	defer wgTrigger.Done()
	token := beego.AppConfig.String("gitee::git_token")
	//token := "8457c66db66955376519059b97e33dd1"
	owner := beego.AppConfig.String("gitee::owner")
	// Time difference in different time zones
	saTimeStampZone, ok := beego.AppConfig.Int64("excel::sa_timestamp_zone")
	if ok != nil {
		saTimeStampZone = 3600 * 8
	}
	st := util.TimeStrToInt(startTime, "2006-01-02")
	chData := make([]IssueAndPkg, 0)
	for _, v := range pkgList {
		rt := util.TimeStrToInt(v.PubTime, "20060102 15-04-05") + saTimeStampZone
		// 查询当前需要处理的issue
		issueTemp, err := models.GetIssueNumber(v.Repo)
		if err != nil || issueTemp == nil {
			continue
		}
		for _, isTemp := range issueTemp {
			prList := getRepoIssueAllPR(affectBranch, token, owner, v.Repo, st, rt, isTemp)
			//get pull request related issue
			repoIssue := make(map[int64]models.PullRequestIssue, 0)
			for _, p := range prList {
				//getPRRelatedAllIssue(token, owner, v.Repo, st, rt, p.Number, repoIssue)
				repoIssue[p.Id] = p
			}
			if len(repoIssue) > 0 {
				chData = append(chData, IssueAndPkg{IssueMap: repoIssue, IssuePkg: v.Packages, Repo: v.Repo})
			}
		}
	}
	c <- chData
}

func (ec *CveExcel) handleGiteData(c <-chan []IssueAndPkg, affectBranch string, cvexml *[]CveXml,
	dpdates *Updates, securityNotice map[string][]SecurityNoticeXml, packRpmx map[string][]PackRpm) {
	defer wgTrigger.Done()
	data := <-c
	var pkgList []string
	for _, v := range data {
		//parse package string to list
		pkgList = strings.Split(v.IssuePkg, " ")
		if len(pkgList) == 0 {
			logs.Error("Data is filtered, v.IssuePkg: ", v.IssuePkg)
			continue
		}
		for _, iv := range v.IssueMap {
			tpl := models.IssueTemplate{IssueNum: iv.Number, Repo: iv.Repo, IssueId: iv.Id}
			err := models.GetIssueTemplateByColName(&tpl, "issue_num", "repo", "issue_id")
			if err != nil {
				logs.Error("GetIssueTemplateByColName, ----", err)
				continue
			}
			err = models.ReplacePackageByCveId(pkgList, tpl.CveId)
			if err != nil {
				logs.Info("ReplacePackageByCveId, err: ", err)
				continue
			}
			//save data to excel
			el, err := models.GetCanExportExcelData(tpl.CveNum, tpl.IssueNum)
			if err != nil {
				logs.Error("GetCanExportExcelData, err: ", err)
				return
			}
			err = ec.handleWriteContentSync(el, affectBranch, cvexml, dpdates, securityNotice, packRpmx)
			if err != nil {
				logs.Error("handleWriteContentSync, err: ", err)
			}
		}
	}
}

func getRepoIssueAllPR(affectBranch, token, owner, repo string, startTime,
	releaseTime int64, isTemp models.IssueTemplate) (prList []models.PullRequestIssue) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/issues/%v/pull_requests", owner, isTemp.IssueNum)
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		logs.Error("NewRequest, url: ", url, ",err: ", err)
		return
	}
	q := req.URL.Query()
	q.Add("access_token", token)
	q.Add("repo", repo)
	req.URL.RawQuery = q.Encode()
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		logs.Error("DefaultClient, url: ", url, ",err: ", err)
		return
	}
	if resp.StatusCode == http.StatusOK {
		issuePr := make([]map[string]interface{}, 0)
		read, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			logs.Error("ReadAll, url: ", url, ",err: ", err)
			return
		}
		resp.Body.Close()
		err = json.Unmarshal(read, &issuePr)
		if err != nil {
			logs.Error("Unmarshal, url: ", url, ",err: ", err)
			return
		}
		for _, v := range issuePr {
			if _, ok := v["id"]; !ok {
				continue
			}
			pr := models.PullRequestIssue{}
			if v["state"].(string) == "merged" && v["mergeable"].(bool) {
				//mt := v["closed_at"].(string).(time.Time).Local().Unix()
				closedAt := v["closed_at"].(string)
				mt := util.TimeStrToInt(closedAt[:19], "2006-01-02T15:04:05")
				mergedAt := v["merged_at"].(string)
				ct := util.TimeStrToInt(mergedAt[:19], "2006-01-02T15:04:05")
				//logs.Info("******, pr: ", v, ",mt: ", mt, ", startTime: ", startTime, ",releaseTime: ", releaseTime, ":ct:", ct)
				//ct := v["merged_at"].(string).(time.Time).Local().Unix()
				var pt int64
				if mt > 0 && ct > 0 {
					if mt > ct {
						pt = ct
					} else {
						pt = mt
					}
					if pt >= startTime && pt <= releaseTime {
						if v["head"].(map[string]interface{})["label"].(string) == affectBranch ||
							v["base"].(map[string]interface{})["label"].(string) == affectBranch {
							if v["head"].(map[string]interface{})["repo"].(map[string]interface{})["path"] == repo ||
								v["base"].(map[string]interface{})["repo"].(map[string]interface{})["path"] == repo {
								if v["head"].(map[string]interface{})["repo"].(map[string]interface{})["namespace"].(map[string]interface{})["path"] == owner ||
									v["base"].(map[string]interface{})["repo"].(map[string]interface{})["namespace"].(map[string]interface{})["path"] == owner {
									pr.Id = int64(v["id"].(float64))
									pr.Number = isTemp.IssueNum
									pr.CveNumber = isTemp.CveNum
									pr.Repo = repo
									prList = append(prList, pr)
								}
							}
						}
					}
				}
			}
		}
	} else {
		resp.Body.Close()
	}
	return
}
