package controllers

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"path/filepath"
	"regexp"
	"time"
)

//FileController file operation routing processing
type FileController struct {
	beego.Controller
}

//DownloadLastExcel Download the latest excel file
// @router /lastExcel [get]
func (f *FileController) DownloadLastExcel() {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	err := util.MakeDir(fd)
	if err != nil {
		logs.Error(err)
	}
	er := models.ExportRecord{}
	err = er.QueryLast()
	if err != nil {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//DownLoadExcelByFileCode download excel file by code
//@router /downloadExcel
func (f *FileController) DownLoadExcelByFileCode()  {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	fc := f.GetString("fileCode")
	if fc == ""{
		_ = f.Ctx.Output.Body([]byte("err: fileCode is a required parameter "))
		return
	}
	er := models.ExportRecord{FileCode: fc}
	err := er.Read("file_code")
	if err != nil {
		_ = f.Ctx.Output.Body([]byte(fmt.Sprintf("err: %v",err)))
		return
	}
	if er.FileName == ""{
		_ = f.Ctx.Output.Body([]byte("err: Can not find excel file by fileCode! "))
		return
	}
	if er.State == 0 {
		_ = f.Ctx.Output.Body([]byte("The file is being generated, please try again later!"))
		return
	}
	if er.State == 2 {
		_ = f.Ctx.Output.Body([]byte("File generation failed, please contact the administrator or regenerate!!"))
		return
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("error:file does not exist"))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//TriggerCveData touch off generate cve data excel and get cve package
//@router /triggerCveData [get]
func (f *FileController) TriggerCveData() {
	startTime := f.GetString("startTime")
	if startTime == "" {
		f.Ctx.WriteString("Error:start time cannot be empty")
		return
	}
	rt := regexp.MustCompile(`^(\d{4})-\d{2}-(\d{2})$`)
	find := rt.Match([]byte(startTime))
	if !find {
		f.Ctx.WriteString(`Error: please enter the correct start time in a format like this "yyyy-MM-dd".`)
		return
	}
	now := time.Now().Unix()
	en := fmt.Sprintf("cve与安全公告%v.xlsx", now)
	fileCode := common.EncryptMd5(en)
	//call the generate excel task by new thread
	go taskhandler.GenerateExcelTrigger(en, startTime,fileCode)
	er := models.ExportRecord{FileName: en, FileCode: fileCode, State: 0}
	err := er.Insert()
	if err != nil {
		f.Ctx.WriteString(fmt.Sprintf("error:%v", err))
	} else {
		//return the success notice to custom
		f.Ctx.WriteString(fmt.Sprintf("Success：The name of the excel file generated this time is: %s. It takes some time to generate the excel file. "+
			"You can try to call the download file interface and pass in the param fileCode=%s to be downloaded.", en, fileCode))
	}
}
