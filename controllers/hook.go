package controllers

import (
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
	"strings"
)

var (
	GiteeUserAgent  = "git-oschina-hook"          //gitee hook request flag
	XGiteeToken     = "X-Gitee-Token"             // password or sign
	XGIteeEventType = "X-Gitee-Event"             //webhook event type
	NoteHookType    = "Note Hook"                 // type of comment
	PullReqHookType = "merge_request_hooks"       // type of pull request
	PushTagHookType = "push_hooks/tag_push_hooks" // type of push or tag
	IssueHookType   = "Issue Hook"               //type of issue
)

const (
	CommentAnalysisCplTpl ="@%v %v"
	ReviewPrivateLettersTpl = `%s(%s)analysis is over,CVEScore:%v;OpenEulerScore:%v。Please review!`
	ReviewRejectScore = `@%v you submit issue score audit failed(reject by %v)，Please re-analyze and submit！`
	CommentReviewTpl = `@%v The CVE score needs to be reviewed (the review instruction /approve&/reject means agreement and rejection)。`
	IssueRejectState = "rejected"
    IssueCloseState = "closed"
    IssueProgressState = "progressing"
    IssueOpenState = "open"
)

type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

// @router / [get]
func (c *HookEventControllers) Get() {
	if ok := c.isLegitimateHookEvent(); !ok {
		logs.Info("hah:", "giteeUseAgent")
		return
	}

}

// isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	logs.Info(xToken)
	return
}

func (c *HookEventControllers) handleNoteDate() {
	//logs.Info(string(c.Ctx.Input.RequestBody))
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" {
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {
	logs.Info(string(c.Ctx.Input.RequestBody))
    issueHook := models.IssuePayload{}
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &issueHook)
	if err != nil{
		logs.Error(err)
		return
	}
	if issueHook.Action == "state_change"{
		//handle issue state change
		err = handleIssueStateChange(&issueHook)
		if err != nil {
			logs.Error(err)
		}
	}

}

func handleIssueStateChange(issueHook *models.IssuePayload) error{
	issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		return err
	}
	switch issueHook.State {
	case IssueOpenState:
		issueTmp.Status = 1
	case IssueProgressState:
		issueTmp.Status = 2
	case IssueCloseState:
		issueTmp.Status = 3
		if isNormalCloseIssue(issueTmp.CveId,issueTmp.IssueStatus){
			issueTmp.IssueStatus = 2
		}else {
			issueTmp.IssueStatus = 6
		}
	case IssueRejectState:
		issueTmp.Status = 4
		if isNormalCloseIssue(issueTmp.CveId,issueTmp.IssueStatus){
			issueTmp.IssueStatus = 2
		}else {
			issueTmp.IssueStatus = 6
		}
	}
	issueTmp.StatusName = issueHook.Issue.StateName
	err = models.UpdateIssueTemplate(&issueTmp, "status", "issue_status", "status_name")
	return err
}

func isNormalCloseIssue(cveId int64,issueState int8) bool {
	if issueState == 1{
		return false
	}
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		logs.Error(err)
		return false
	}
	if score.Ostatus != 3 {
		return false
	}
	return true
}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	issueNum := payload.Issue.Number           //issue 编号
	cBody := payload.Comment.Body              //评论主体
	cuAccount := payload.Comment.User.UserName //gitee 域地址
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		return
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//审核拒绝 添加评论 @分析人
        if !isReviewer(cuAccount){
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 2)
		if err != nil {
			logs.Error(err)
		}
		accessToken := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		//path := beego.AppConfig.String("gitee::path")
		path := issueTmp.Repo
		taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewRejectScore,issueTmp.Assignee,cuAccount),issueTmp.IssueNum,owner,path,accessToken)
	} else if strings.HasPrefix(cBody, cmdApe) {
		//审核通过 修改评分状态
        if !isReviewer(cuAccount){
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 3)
		if err != nil {
			logs.Error(err)
		}
	} else {
		analysisComment(issueNum, cuAccount, cBody,&payload)
	}

}

func isReviewer(path string) bool {
	sr := models.SecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func analysisComment(issueNum string, cuAccount string, cBody string,payload *models.CommentPayload) {
	cmdAys := beego.AppConfig.DefaultString("analysisCmd", "/analysis")
	cmdEnd := beego.AppConfig.DefaultString("endCmd", "/done")
	issueTmp := models.IssueTemplate{IssueNum: issueNum}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		logs.Error(err)
		return
	}
	if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdAys) {
		//is Analyst comment and content start with '/analysis'
		vMap := util.ParseCommentWithAllLabel(cBody)
		if len(vMap) > 0 {
			cols := make([]string, 0)
			for k, v := range vMap {
				switch k {
				case "cve_analysis":
					issueTmp.CveAnalysis = v
					cols = append(cols, k)
				case "principle_analysis":
					issueTmp.PrincipleAnalysis = v
					cols = append(cols, k)
				case "openeuler_score":
					fv, err := strconv.ParseFloat(v, 64)
					if err == nil {
						issueTmp.OpenEulerScore = fv
						cols = append(cols, k)
					}
				case "openeuler_vector":
					issueTmp.OpenEulerVector = v
					cols = append(cols, k)
				case "affected_version":
					issueTmp.AffectedVersion = v
					cols = append(cols, k)
				case "solution":
					issueTmp.Solution = v
					cols = append(cols, k)
				}
			}
			if len(cols) > 0 {
				err := models.UpdateIssueTemplate(&issueTmp, cols...)
				if err != nil {
					logs.Error(err)
				} else {
					if _, ok := vMap["openeuler_vector"]; ok {
						err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						}
					}
					if _, ok := vMap["openeuler_score"]; ok {
						//更新分数到 score
						score, err := models.QueryIssueScore(issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						} else {
							score.OpenEulerScore = issueTmp.OpenEulerScore
							score.Ostatus = 1
							err := models.UpdateScore(&score, "openeuler_score","o_score_status")
							if err != nil {
								logs.Error(err)
							}
						}
					}
				}
			}
			if _, ok := vMap["issue_package"]; ok {
				// handle comment package
				err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
				if err != nil {
					logs.Error(err)
				}
			}
		}
		// update gitee issue
		commentUpdateIssue(issueTmp)
	}
	if cuAccount == issueTmp.Assignee && strings.Contains(cBody, cmdEnd) {
		//Check whether the data is legal
        if msg,ok :=checkIssueAnalysisComplete(&issueTmp);!ok{
        	//send comment to issue
        	msg = fmt.Sprintf(CommentAnalysisCplTpl,issueTmp.Assignee,msg)
			accessToken := os.Getenv("GITEE_TOKEN")
			owner := beego.AppConfig.String("gitee::owner")
			//path := beego.AppConfig.String("gitee::path")
			path := issueTmp.Repo
			taskhandler.AddCommentToIssue(msg,issueTmp.IssueNum,owner,path,accessToken)
		}else {
			//1. change issue status
			issueTmp.IssueStatus = 3
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil{
				logs.Error(err)
			}
			//2. Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
            if issueTmp.OpenEulerScore != issueTmp.NVDScore {
            	//Notify the responsible person for review
				notifyAuditorReview(payload,issueTmp)
			}else {
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			}
		}
	}
}

func notifyAuditorReview(payload *models.CommentPayload,issueTmp models.IssueTemplate){
	//Notify the responsible person for review
	list, err := models.GetSecurityReviewerList()
	if err != nil{
		logs.Error(err)
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	content := fmt.Sprintf(ReviewPrivateLettersTpl,
		payload.Issue.Title,payload.Issue.HtmlUrl,issueTmp.NVDScore,issueTmp.OpenEulerScore)
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	for _,v := range list{
		taskhandler.SendPrivateLetters(accessToken,content,v.NameSpace)
		//add @comment
		msg := fmt.Sprintf(CommentReviewTpl,v.NameSpace)
		taskhandler.AddCommentToIssue(msg,issueTmp.IssueNum,owner,path,accessToken)
	}


}

func changeOpenEulerScoreStatus(cveId int64,status int8)  error{
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		return err
	}
	score.Ostatus = status
	err = models.UpdateScore(&score, "o_score_status")
	return  err
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg string,ok bool) {
	if i == nil {
		logs.Error("issue template is nil")
		return msg,false
	}
	ok = true
	if i.OpenEulerScore == 0.0 {
		msg = fmt.Sprintf("openEulerScore:%v",i.OpenEulerScore)
		ok = false
		return
	}
	if i.CveAnalysis == "" {
		msg = fmt.Sprintf("影响性分析说明:%v",i.CveAnalysis)
		ok = false
		return
	}
	if i.PrincipleAnalysis == "" {
		msg = fmt.Sprintf("原理分析:%v",i.PrincipleAnalysis)
		ok = false
		return
	}
	if i.OpenEulerVector == "" {
		msg = fmt.Sprintf("OpenEulerVector:%v",i.OpenEulerVector)
		ok = false
		return
	}
	if i.AffectedVersion == "" {
		msg = fmt.Sprintf("受影响的包:%v",i.OpenEulerVector)
		ok = false
		return
	}
	if i.Solution == ""{
		msg = fmt.Sprintf("规避方案或消减措施:%v",i.OpenEulerVector)
		ok = false
		return
	}
	pkg, err := models.QueryPackageByCveId(i.CveId)
	if err != nil {
		return "受影响的包：",false
	}
	if len(pkg) == 0 {
		return "受影响的包",false
	}
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveId int64) error {
	score, err := models.QueryIssueScore(cveId)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	avv := util.ReadVmValue(vMap["AV"])
	if avv != "" {
		score.OattackVector = avv
		upFields = append(upFields, "o_attack_vector")
	}
	acv := util.ReadVmValue(vMap["AC"])
	if acv != "" {
		score.OattackComplexity = acv
		upFields = append(upFields, "o_attack_complexity")
	}
	prv := util.ReadVmValue(vMap["PR"])
	if prv != "" {
		score.OprivilegeRequired = prv
		upFields = append(upFields, "o_privilege_required")
	}
	uiv := util.ReadVmValue(vMap["UI"])
	if uiv != "" {
		score.OuserInteraction = uiv
		upFields = append(upFields, "o_user_interaction")
	}
	sv := util.ReadVmValue(vMap["S"])
	if sv != "" {
		score.Oscope = sv
		upFields = append(upFields, "o_scope")
	}
	cv := util.ReadVmValue(vMap["C"])
	if cv != "" {
		score.Oconfidentiality = cv
		upFields = append(upFields, "o_confidentiality")
	}
	iv := util.ReadVmValue(vMap["I"])
	if iv != "" {
		score.Ointegrity = iv
		upFields = append(upFields, "o_integrity")
	}
	av := util.ReadVmValue(vMap["A"])
	if av != "" {
		score.Oavailability = av
		upFields = append(upFields, "o_availability")
	}
	if len(upFields) > 0 {
		//执行更新
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveId int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveId)
	if err != nil {
		return err
	}
	return nil
}
