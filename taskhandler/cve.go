package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

var GetCveDetailUrl = "http://cve.openeuler.org/cve-security-notice-server/cvedatabase/getByCveId?cveId=%s"
var lockx sync.Mutex
var ewg sync.WaitGroup

func UpdateExcelCveGroups(cveData models.OriginExcel, cveRef string, openeulerNum int, CveRes models.VulnCenter,
	goe models.GitPackageInfo) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveData.CveDesc
	CveRes.CveVersion = cveData.CveVersion
	CveRes.RepairTime = cveData.RepairTime
	CveRes.PackName = cveData.PackName
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveData.CveLevel
	CveRes.IsExport = 0
	if CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 10
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		OpenEulerId, OpEerr := models.CreateOpenEulerSA(&opensa)
		if OpEerr == nil {
			OpenEulId = OpenEulerId
		} else {
			logs.Error("更新openEulerSa数据表失败")
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		if scoreRes.NVDScore != cveData.NVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = cveData.NVDScore
			scorecode.NvectorVule = cveData.NVDVector
			scorecode.Status = 0
			scorecode.CveId = CveRes.CveId
			scoreid, err := models.CreateScoreRecord(&scorecode)
			if scoreid > 0 && err == nil {
				logs.Info("insert score_record success, id:", scoreid)
			} else {
				return false, errors.New("评分记录数据错误，暂时不处理")
			}
		}
		scoreRes.NVDScore = cveData.NVDScore
		scoreRes.NvectorVule = cveData.NVDVector
		scoreRes.OpenId = OpenEulId
		scoreRes.Nstatus = 1
		if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
			scoreRes.NaccessVector = cveData.AccessVector
			scoreRes.NaccessComplexity = cveData.AccessComplexity
			scoreRes.Nauthentication = cveData.Authentication
			scoreRes.ScoreType = "v2"
		} else {
			scoreRes.NattackVector = cveData.AttackVector
			scoreRes.NattackComplexity = cveData.AttackComplexity
			scoreRes.NprivilegeRequired = cveData.PrivilegeRequired
			scoreRes.NuserInteraction = cveData.UserInteraction
			scoreRes.Nscope = cveData.Scope
			scoreRes.ScoreType = "v3"
		}
		scoreRes.Nconfidentiality = cveData.Confidentiality
		scoreRes.Nintegrity = cveData.Integrity
		scoreRes.Navailability = cveData.Availability
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.NVDScore = cveData.NVDScore
		sc.OpenEulerScore = cveData.NVDScore
		sc.OpenId = OpenEulId
		sc.NvectorVule = cveData.NVDVector
		sc.OvectorVule = cveData.NVDVector
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
			sc.NaccessVector = cveData.AccessVector
			sc.OaccessVector = cveData.AccessVector
			sc.NaccessComplexity = cveData.AccessComplexity
			sc.OaccessComplexity = cveData.AccessComplexity
			sc.Nauthentication = cveData.Authentication
			sc.Oauthentication = cveData.Authentication
			sc.ScoreType = "v2"
		} else {
			sc.NattackVector = cveData.AttackVector
			sc.OattackVector = cveData.AttackVector
			sc.NattackComplexity = cveData.AttackComplexity
			sc.OattackComplexity = cveData.AttackComplexity
			sc.NprivilegeRequired = cveData.PrivilegeRequired
			sc.OprivilegeRequired = cveData.PrivilegeRequired
			sc.OuserInteraction = cveData.UserInteraction
			sc.NuserInteraction = cveData.UserInteraction
			sc.Oscope = cveData.Scope
			sc.Nscope = cveData.Scope
			sc.ScoreType = "v3"
		}
		sc.Nconfidentiality = cveData.Confidentiality
		sc.Oconfidentiality = cveData.Confidentiality
		sc.Nintegrity = cveData.Integrity
		sc.Ointegrity = cveData.Integrity
		sc.Navailability = cveData.Availability
		sc.Oavailability = cveData.Availability
		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("insert cve_score failed cveScV3:", sc)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = cveData.PackName
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = cveData.PackName + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = cveData.PackName
		sec.Status = 0
		sec.AffectStatus = "UnFixed"
		sec.CveId = CveRes.CveId
		sec.Summary = cveData.PackName + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveData.CveDesc
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveData.CveDesc
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice)failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveExcelGroups(cveData models.OriginExcel, cveRef string, openeulerNum int, goe models.GitPackageInfo) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveData.CveDesc
	vul.Status = 0
	vul.CveVersion = cveData.CveVersion
	vul.RepairTime = cveData.RepairTime
	vul.PackName = cveData.PackName
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveData.CveLevel
	vul.IsExport = 0
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = cveData.PackName
	sec.Status = 0
	sec.AffectStatus = "UnFixed"
	sec.Summary = cveData.PackName + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveData.CveDesc
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + cveData.CveDesc
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.NVDScore = cveData.NVDScore
	sc.OpenEulerScore = cveData.NVDScore
	sc.NvectorVule = cveData.NVDVector
	sc.OvectorVule = cveData.NVDVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
		sc.NaccessVector = cveData.AccessVector
		sc.OaccessVector = cveData.AccessVector
		sc.NaccessComplexity = cveData.AccessComplexity
		sc.OaccessComplexity = cveData.AccessComplexity
		sc.Nauthentication = cveData.Authentication
		sc.Oauthentication = cveData.Authentication
		sc.ScoreType = "v2"
	} else {
		sc.NattackVector = cveData.AttackVector
		sc.OattackVector = cveData.AttackVector
		sc.NattackComplexity = cveData.AttackComplexity
		sc.OattackComplexity = cveData.AttackComplexity
		sc.NprivilegeRequired = cveData.PrivilegeRequired
		sc.OprivilegeRequired = cveData.PrivilegeRequired
		sc.OuserInteraction = cveData.UserInteraction
		sc.NuserInteraction = cveData.UserInteraction
		sc.Oscope = cveData.Scope
		sc.Nscope = cveData.Scope
		sc.ScoreType = "v3"
	}
	sc.Nconfidentiality = cveData.Confidentiality
	sc.Oconfidentiality = cveData.Confidentiality
	sc.Nintegrity = cveData.Integrity
	sc.Ointegrity = cveData.Integrity
	sc.Navailability = cveData.Availability
	sc.Oavailability = cveData.Availability

	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveData.NVDScore
	scorecode.NvectorVule = cveData.NVDVector
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNum)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	return true, nil
}

func UpdateCveGroups(cveData models.OriginUpstream, cveRef string, openeulerNum int, CveRes models.VulnCenter,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2, pkList []string) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveDesc.EnDescription
	CveRes.CveVersion = pkList[1]
	CveRes.RepairTime = cveData.PublishedDate
	CveRes.PackName = pkList[0]
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveScV3.CveLevel
	CveRes.IsExport = 0
	if CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 10
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		OpenEulerId, OpEerr := models.CreateOpenEulerSA(&opensa)
		if OpEerr == nil {
			OpenEulId = OpenEulerId
		} else {
			logs.Error("更新openEulerSa数据表失败")
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		scoreRes.ScoreType = scopeType
		vectorString := ""
		if scopeType == "v3" {
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV3.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV3.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.CreateScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV3.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NattackVector = cveScV3.AttackVector
			scoreRes.NattackComplexity = cveScV3.AttackComplexity
			scoreRes.NprivilegeRequired = cveScV3.PrivilegesRequired
			scoreRes.NuserInteraction = cveScV3.UserInteraction
			scoreRes.Nscope = cveScV3.Scope
			scoreRes.Nconfidentiality = cveScV3.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV3.IntegrityImpact
			scoreRes.Navailability = cveScV3.AvailabilityImpact
		} else {
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV2.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV2.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.CreateScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV2.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NaccessVector = cveScV2.AccessVector
			scoreRes.NaccessComplexity = cveScV2.AccessComplexity
			scoreRes.Nconfidentiality = cveScV2.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV2.IntegrityImpact
			scoreRes.Navailability = cveScV2.AvailabilityImpact
			scoreRes.Nauthentication = cveScV2.Authentication
		}
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.OpenId = OpenEulId
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		sc.ScoreType = scopeType
		if scopeType == "v3" {
			sc.NVDScore = cveScV3.BaseScore
			sc.OpenEulerScore = cveScV3.BaseScore
			vectorString := ""
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NattackVector = cveScV3.AttackVector
			sc.OattackVector = cveScV3.AttackVector
			sc.NattackComplexity = cveScV3.AttackComplexity
			sc.OattackComplexity = cveScV3.AttackComplexity
			sc.NprivilegeRequired = cveScV3.PrivilegesRequired
			sc.OprivilegeRequired = cveScV3.PrivilegesRequired
			sc.NuserInteraction = cveScV3.UserInteraction
			sc.OuserInteraction = cveScV3.UserInteraction
			sc.Nscope = cveScV3.Scope
			sc.Oscope = cveScV3.Scope
			sc.Nconfidentiality = cveScV3.ConfidentialityImpact
			sc.Oconfidentiality = cveScV3.ConfidentialityImpact
			sc.Nintegrity = cveScV3.IntegrityImpact
			sc.Ointegrity = cveScV3.IntegrityImpact
			sc.Navailability = cveScV3.AvailabilityImpact
			sc.Oavailability = cveScV3.AvailabilityImpact
		} else {
			sc.NVDScore = cveScV2.BaseScore
			sc.OpenEulerScore = cveScV2.BaseScore
			vectorString := ""
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NaccessVector = cveScV2.AccessVector
			sc.OaccessVector = cveScV2.AccessVector
			sc.NaccessComplexity = cveScV2.AccessComplexity
			sc.OaccessComplexity = cveScV2.AccessComplexity
			sc.Nauthentication = cveScV2.Authentication
			sc.Oauthentication = cveScV2.Authentication
			sc.Nconfidentiality = cveScV2.ConfidentialityImpact
			sc.Oconfidentiality = cveScV2.ConfidentialityImpact
			sc.Nintegrity = cveScV2.IntegrityImpact
			sc.Ointegrity = cveScV2.IntegrityImpact
			sc.Navailability = cveScV2.AvailabilityImpact
			sc.Oavailability = cveScV2.AvailabilityImpact
		}
		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("insert cve_score failed cveScV3:", cveScV3)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = pkList[0]
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = pkList[0] + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = pkList[0]
		sec.Status = 0
		sec.AffectStatus = "UnFixed"
		sec.CveId = CveRes.CveId
		sec.Summary = pkList[0] + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveDesc.EnDescription
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveDesc.EnDescription
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice)failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveGroups(cveData models.OriginUpstream, cveRef string, openeulerNum int, cveDesc models.OriginUpstreamDesc,
	cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2, pkList []string) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveDesc.EnDescription
	vul.Status = 0
	vul.CveVersion = pkList[1]
	vul.RepairTime = cveData.PublishedDate
	vul.PackName = pkList[0]
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveScV3.CveLevel
	vul.IsExport = 0
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = pkList[0]
	sec.Status = 0
	sec.AffectStatus = "UnFixed"
	sec.Summary = pkList[0] + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveDesc.EnDescription
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + cveDesc.EnDescription
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.Nstatus = 0
	sc.Ostatus = 0
	if scopeType == "v3" {
		sc.NVDScore = cveScV3.BaseScore
		sc.OpenEulerScore = cveScV3.BaseScore
		vectorString := ""
		if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
			index := strings.IndexAny(cveScV3.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
				vectorString = cveScV3.VectorString[index+1:]
			} else {
				vectorString = cveScV3.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NattackVector = cveScV3.AttackVector
		sc.OattackVector = cveScV3.AttackVector
		sc.NattackComplexity = cveScV3.AttackComplexity
		sc.OattackComplexity = cveScV3.AttackComplexity
		sc.NprivilegeRequired = cveScV3.PrivilegesRequired
		sc.OprivilegeRequired = cveScV3.PrivilegesRequired
		sc.NuserInteraction = cveScV3.UserInteraction
		sc.OuserInteraction = cveScV3.UserInteraction
		sc.Nscope = cveScV3.Scope
		sc.Oscope = cveScV3.Scope
		sc.Nconfidentiality = cveScV3.ConfidentialityImpact
		sc.Oconfidentiality = cveScV3.ConfidentialityImpact
		sc.Nintegrity = cveScV3.IntegrityImpact
		sc.Ointegrity = cveScV3.IntegrityImpact
		sc.Navailability = cveScV3.AvailabilityImpact
		sc.Oavailability = cveScV3.AvailabilityImpact
	} else {
		sc.NVDScore = cveScV2.BaseScore
		sc.OpenEulerScore = cveScV2.BaseScore
		vectorString := ""
		if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
			index := strings.IndexAny(cveScV2.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
				vectorString = cveScV2.VectorString[index+1:]
			} else {
				vectorString = cveScV2.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NaccessVector = cveScV2.AccessVector
		sc.OaccessVector = cveScV2.AccessVector
		sc.NaccessComplexity = cveScV2.AccessComplexity
		sc.OaccessComplexity = cveScV2.AccessComplexity
		sc.Nauthentication = cveScV2.Authentication
		sc.Oauthentication = cveScV2.Authentication

		sc.Nconfidentiality = cveScV2.ConfidentialityImpact
		sc.Oconfidentiality = cveScV2.ConfidentialityImpact
		sc.Nintegrity = cveScV2.IntegrityImpact
		sc.Ointegrity = cveScV2.IntegrityImpact
		sc.Navailability = cveScV2.AvailabilityImpact
		sc.Oavailability = cveScV2.AvailabilityImpact
	}
	sc.ScoreType = scopeType

	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveScV3.BaseScore
	scorecode.NvectorVule = cveScV3.VectorString
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNum)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	return true, nil
}

func GenCveVuler(cveData models.OriginUpstream, cveRef string, openeulernum int) (bool, error) {
	if cveData.Ids == "" || cveData.CveNum == "" {
		logs.Error("当前数据cveNum 为空暂不处理,data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveDesc, ok := models.QueryCveDesc(cveData.CveId)
	if !ok {
		logs.Error("当前数据描述为空暂不处理, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveImpact, ok := models.QueryCveImpact(cveData.CveId)
	if !ok {
		logs.Error("cveImpact查询失败, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	scopeType := "v3"
	//var cveScV2 models.OriginUpstreamImpactScoreV2
	cveScore, ok := models.QueryCveScore(cveImpact.ImpactId, "v3")
	if !ok {
		scopeType = "v2"
	}
	cveScV3, ok := models.QueryCveCvssV3(cveScore.ScoreId)
	if !ok {
		scopeType = "v2"
		//logs.Error("cveScore, data: ", cveData, ",cveScore: ", cveScore)
		//models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		//return false, errors.New("数据错误，暂时不处理")
	}
	if cveScV3.VectorString == "" || len(cveScV3.VectorString) == 0 || cveScV3.BaseScore == 0.0{
		scopeType = "v2"
	}
	cveScoreV2, ok2 := models.QueryCveScore(cveImpact.ImpactId, "v2")
	if !ok2 {
		if scopeType == "v2" {
			logs.Error("cveScore, data: ", cveData, ",cveImpact: ", cveImpact)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	cveScV2, okV2 := models.QueryCveCvssV2(cveScoreV2.ScoreId)
	if !okV2 {
		if scopeType == "v2" {
			logs.Error("cveScore, data: ", cveData, ",cveScore: ", cveScore)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	packNameMap := map[string]string{}
	packNameList := []string{}
	if cveData.PackName != "" && len(cveData.PackName) > 0 {
		packNameList = strings.Split(cveData.PackName, ",")
		if len(packNameList) > 0 {
			for _, pk := range packNameList {
				pkList := strings.Split(pk, "==")
				if len(pkList) == 2 {
					if _, ok := packNameMap[pkList[0]]; ok {
						packNameMap[pkList[0]] += "," + pkList[1]
					} else {
						packNameMap[pkList[0]] = pkList[1]
					}
				}
			}
		}
	}
	for key, value := range packNameMap {
		if key != "" && len(key) > 1 {
			pkList := []string{}
			pkList = append(pkList, key)
			pkList = append(pkList, value)
			versionFlag := false
			var goe models.GitPackageInfo
			if value != "" && len(value) > 0 {
				versionList := strings.Split(value, ",")
				if len(versionList) > 0 {
					for _, ver := range versionList {
						if ver != "" && len(ver) > 1 {
							goe, ok = models.QueryCveOpeneulerDetaildata(key, pkList[1])
							if ok {
								versionFlag = true
								break
							} else {
								logs.Error("未查询到对应的仓库数据, data: ", cveData)
							}
						}
					}
				}
			}
			repoFlag := false
			if !versionFlag {
				gr, reok := models.QueryOriginRepo(key)
				if reok && gr.RepoId > 0 {
					repoFlag = true
				}
			}
			if !versionFlag && !repoFlag {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 4)
			}
			CveRes, err := models.QueryCveByNum(cveData.CveNum, key, value)
			if err {
				lockx.Lock()
				ok, err := UpdateCveGroups(cveData, cveRef, openeulernum, CveRes, cveDesc, cveScV3, goe, scopeType, cveScV2, pkList)
				lockx.Unlock()
				if !ok {
					logs.Error("更新cve数据失败, cveData: ", cveData, ", err: ", err)
					models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
					return false, errors.New("数据错误，暂时不处理")
				}
			} else {
				lockx.Lock()
				ok, err := InsertCveGroups(cveData, cveRef, openeulernum, cveDesc, cveScV3, goe, scopeType, cveScV2, pkList)
				lockx.Unlock()
				if !ok {
					logs.Error("插入cve数据失败, cveData: ", cveData, ", err: ", err)
					models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
					return false, errors.New("数据错误，暂时不处理")
				}
			}
		}
	}
	models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 2)
	return true, nil
}

func SyncCveVuler(cveData models.OriginExcel, cveRef string, openeulerNum int) (bool, error) {
	if cveData.CveNum == "" || len(cveData.CveNum) == 0 {
		logs.Error("当前数据cveNum 为空暂不处理,data: ", cveData)
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	goe, ok := models.QueryCveOpeneulerDetaildata(cveData.PackName, cveData.CveVersion)
	if !ok {
		logs.Error("仓库不存在，暂时不处理,data: ", cveData)
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 4)
		return false, errors.New("仓库不存在，暂时不处理")
	}
	CveRes, err := models.QueryCveByNum(cveData.CveNum, cveData.PackName, cveData.CveVersion)
	if err {
		lockx.Lock()
		ok, err := UpdateExcelCveGroups(cveData, cveRef, openeulerNum, CveRes, goe)
		lockx.Unlock()
		if !ok {
			logs.Error("更新cve数据失败, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		lockx.Lock()
		ok, err := InsertCveExcelGroups(cveData, cveRef, openeulerNum, goe)
		lockx.Unlock()
		if !ok {
			logs.Error("插入cve数据失败, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 2)
	return true, nil
}

func GetCveOriginData(prcnum, days, openeulernum int, cveRef string) (bool, error) {
	defer common.Catchs()
	//var os []models.OriginUpstream
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCve(beforeTime, prcnum)
		if err != nil || num == 0 {
			logs.Info("当前无cve原始数据处理, err: ", err,
				", 处理时间范围: beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("总共有: ", num, "条的数据需要处理, ", osx)
		ch := make(chan int, len(osx))
		for i, cveData := range osx {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveData.Ids)
			go func() {
				ok, err := GenCveVuler(cveData, cveRef, openeulernum)
				if !ok {
					logs.Error("cveData: ", cveData, "处理失败, err: ", err)
				}
				ch <- i
			}()
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func GetCveOriginExcelData(prcnum, days, openeulerNum int, cveRef string) (bool, error) {
	defer common.Catchs()
	//var os []models.OriginUpstream
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCveExcel(beforeTime, prcnum)
		if err != nil || num == 0 {
			logs.Info("当前无excel导入的cve原始数据处理, err: ", err,
				", 处理时间范围: beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("excel总共有: ", num, "条的数据需要处理, ", osx)
		ch := make(chan int, len(osx))
		for i, cveData := range osx {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveData.CveNum)
			go func() {
				ok, err := SyncCveVuler(cveData, cveRef, openeulerNum)
				if !ok {
					logs.Error("cveData: ", cveData, "处理失败, err: ", err)
				}
				ch <- i
			}()
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func InsertIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, owner string) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNumber
	vul.Description = lop.RepoDesc
	vul.Status = cveStatus
	vul.CveVersion = lop.Version
	vul.RepairTime = ""
	vul.PackName = lop.Components
	vul.CveUrl = cveRef + cveData.CveNumber
	vul.IsExport = 0
	v2, cvsError := strconv.ParseFloat(lop.CvsScore, 64)
	if cvsError != nil {
		vul.CveLevel = "Critical"
	}
	if v2 >= 9.0 {
		vul.CveLevel = "Critical"
	} else if v2 >= 7.0 && v2 <= 8.9 {
		vul.CveLevel = "High"
	} else if v2 > 4.0 && v2 <= 6.9 {
		vul.CveLevel = "Medium"
	} else if v2 <= 4.0 {
		vul.CveLevel = "Low"
	}
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNumber
	sec.InfluenceComponent = lop.Components
	sec.Status = 0
	sec.AffectStatus = "UnFixed"
	sec.Summary = lop.Components + " security update"
	sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + lop.BriefIntroduction
	sec.ReferenceLink = cveRef + cveData.CveNumber
	sec.Introduction = "An update for " + lop.Components + " is now available for " + lop.InfProduct
	//sec.Summary = "An update for " + path + " is now available for " + branchs
	sec.Theme = sec.Introduction + ";\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of medium. A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = lop.InfProduct
	var sc models.Score
	sc.CveNum = cveData.CveNumber
	nVDScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
	if nvdError == nil {
		sc.NVDScore = nVDScore
	}
	openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
	if openError == nil {
		sc.OpenEulerScore = openEulerScore
	}
	sc.NvectorVule = lop.CvsVector
	sc.OvectorVule = lop.OpVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	sc.ScoreType = "v3"
	vectorN := models.VectorValue{}
	ok := vectorN.VctToVectorValue(lop.CvsVector)
	if ok {
		sc.NattackVector = vectorN.AttackVector
		sc.NattackComplexity = vectorN.AttackComplexity
		sc.NprivilegeRequired = vectorN.PrivilegesRequired
		sc.NuserInteraction = vectorN.UserInteraction
		sc.Nscope = vectorN.Scope
		sc.Nconfidentiality = vectorN.Confidentiality
		sc.Nintegrity = vectorN.Integrity
		sc.Navailability = vectorN.Availability
	}
	vectorO := models.VectorValue{}
	okx := vectorO.VctToVectorValue(lop.OpVector)
	if okx {
		sc.OattackVector = vectorO.AttackVector
		sc.OattackComplexity = vectorO.AttackComplexity
		sc.OprivilegeRequired = vectorO.PrivilegesRequired
		sc.OuserInteraction = vectorO.UserInteraction
		sc.Oscope = vectorO.Scope
		sc.Oconfidentiality = vectorO.Confidentiality
		sc.Ointegrity = vectorO.Integrity
		sc.Oavailability = vectorO.Availability
	}

	var opensa models.OpenEulerSA
	var OpenNumData int
	//var os models.OpenSaId
	osx, opError := models.QueryOpenSaLastId()
	if opError == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulernum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulernum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = nVDScore
	scorecode.NvectorVule = lop.CvsVector
	scorecode.Status = 0
	cveid, cveError := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveError != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNumber)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = cveid
	issueTemp.CveNum = cveData.CveNumber
	issueTemp.OwnedComponent = lop.Components
	issueTemp.OwnedVersion = lop.Version
	issueTemp.NVDScore = nVDScore
	issueTemp.OpenEulerScore = openEulerScore
	issueTemp.NVDVector = lop.CvsVector
	issueTemp.OpenEulerVector = lop.OpVector
	issueTemp.CveBrief = lop.BriefIntroduction
	issueTemp.CveAnalysis = lop.Influences
	issueTemp.PrincipleAnalysis = lop.Principle
	issueTemp.AffectedVersion = lop.InfVersion
	issueTemp.Solution = lop.AvoidScheme
	issueTemp.IssueId = cveData.IssueId
	issueTemp.IssueNum = cveData.Number
	issueTemp.Assignee = cveData.IssueAssignee
	if strings.ToLower(cveData.State) == "open" {
		issueTemp.Status = 1
		issueTemp.IssueStatus = 1
	} else if strings.ToLower(cveData.State) == "progressing" {
		issueTemp.Status = 2
		issueTemp.IssueStatus = 3
	} else if strings.ToLower(cveData.State) == "closed" {
		issueTemp.Status = 3
		issueTemp.IssueStatus = 2
	} else {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
	}
	issueTemp.StatusName = cveData.State
	issueTemp.IssueLabel = "cve/Undisclosed"
	issueTemp.Owner = cveData.RepoPath
	issueTemp.Repo = lop.Repo
	if cveData.Title != "" {
		issueTemp.Title = cveData.Title
	}
	issueTemp.IssueType = cveData.IssueType
	issueTemp.CveLevel = vul.CveLevel
	// 存储issue数据
	issTempId, issError := models.CreateIssueTemplet(&issueTemp)
	if issError != nil {
		logs.Error("创建issue 模板的数据失败, cveNum: ", cveData.CveNumber, "err: ", issError)
		return false, issError
	} else {
		logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cveData.CveNumber)
	}
	if cveData.State != "" && (strings.ToLower(cveData.State) == "open" || strings.ToLower(cveData.State) == "progressing") {
		accessToken := os.Getenv("GITEE_TOKEN")
		CreateDepositHooks(accessToken, owner, cveData.RepoPath, vul, cveData.Number, cveData.IssueId)
	}
	return true, nil
}

func UpdateIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, vul models.VulnCenter, owner string) (bool, error) {
	//var vul models.VulnCenter
	vul.CveNum = cveData.CveNumber
	vul.Description = lop.RepoDesc
	vul.Status = cveStatus
	vul.CveVersion = lop.Version
	vul.RepairTime = ""
	vul.PackName = lop.Components
	vul.CveUrl = cveRef + cveData.CveNumber
	vul.IsExport = 0
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNumber
	sec.InfluenceComponent = lop.Components
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = lop.Components + " security update"
	sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + lop.BriefIntroduction
	sec.ReferenceLink = cveRef + cveData.CveNumber
	sec.Introduction = "An update for " + lop.Components + " is now available for " + lop.InfProduct
	//sec.Summary = "An update for " + path + " is now available for " + branchs
	sec.Theme = sec.Introduction + ";\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of medium. A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = lop.InfProduct
	nVDScore := 0.0
	//var err error
	var score models.Score
	var scOk bool
	score, scOk = models.QueryScoreByCveId(vul.CveId)
	if !scOk || score.Id == 0 {
		vul.Status = 2
		//var sc models.Score
		v2, cvsError := strconv.ParseFloat(lop.CvsScore, 64)
		if cvsError != nil {
			vul.CveLevel = "Critical"
		}
		if v2 >= 9.0 {
			vul.CveLevel = "Critical"
		} else if v2 >= 7.0 && v2 <= 8.9 {
			vul.CveLevel = "High"
		} else if v2 > 4.0 && v2 <= 6.9 {
			vul.CveLevel = "Medium"
		} else if v2 <= 4.0 {
			vul.CveLevel = "Low"
		}
		score.CveNum = cveData.CveNumber
		var nvdError error
		nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil {
			score.NVDScore = nVDScore
		}
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			score.OpenEulerScore = openEulerScore
		}
		score.NvectorVule = lop.CvsVector
		score.OvectorVule = lop.OpVector
		score.Nstatus = 0
		score.Ostatus = 0
		score.ScoreType = "v3"
		vectorN := models.VectorValue{}
		ok := vectorN.VctToVectorValue(lop.CvsVector)
		if ok {
			score.NattackVector = vectorN.AttackVector
			score.NattackComplexity = vectorN.AttackComplexity
			score.NprivilegeRequired = vectorN.PrivilegesRequired
			score.NuserInteraction = vectorN.UserInteraction
			score.Nscope = vectorN.Scope
			score.Nconfidentiality = vectorN.Confidentiality
			score.Nintegrity = vectorN.Integrity
			score.Navailability = vectorN.Availability
		}
		vectorO := models.VectorValue{}
		vectOk := vectorO.VctToVectorValue(lop.OpVector)
		if vectOk {
			score.OattackVector = vectorO.AttackVector
			score.OattackComplexity = vectorO.AttackComplexity
			score.OprivilegeRequired = vectorO.PrivilegesRequired
			score.OuserInteraction = vectorO.UserInteraction
			score.Oscope = vectorO.Scope
			score.Oconfidentiality = vectorO.Confidentiality
			score.Ointegrity = vectorO.Integrity
			score.Oavailability = vectorO.Availability
		}
	} else {
		v2 := score.NVDScore
		if v2 >= 9.0 {
			vul.CveLevel = "Critical"
		} else if v2 >= 7.0 && v2 <= 8.9 {
			vul.CveLevel = "High"
		} else if v2 > 4.0 && v2 <= 6.9 {
			vul.CveLevel = "Medium"
		} else if v2 <= 4.0 {
			vul.CveLevel = "Low"
		}
		score.CveNum = cveData.CveNumber
		score.Nstatus = 2
		var nvdError error
		nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil {
			if score.NVDScore != nVDScore {
				score.Nstatus = 1
				vul.Status = 1
			}
		}
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			score.OpenEulerScore = openEulerScore
		}
		//sc.NvectorVule = lop.CvsVector
		score.OvectorVule = lop.OpVector

		//sc.Ostatus = 0
		score.ScoreType = "v3"
		//vectorN := models.VectorValue{}
		//ok := vectorN.VctToVectorValue(lop.CvsVector)
		//if ok {
		//	sc.NattackVector = vectorN.AttackVector
		//	sc.NattackComplexity = vectorN.AttackComplexity
		//	sc.NprivilegeRequired = vectorN.PrivilegesRequired
		//	sc.NuserInteraction = vectorN.UserInteraction
		//	sc.Nscope = vectorN.Scope
		//	sc.Nconfidentiality = vectorN.Confidentiality
		//	sc.Nintegrity = vectorN.Integrity
		//	sc.Navailability = vectorN.Availability
		//}
		vectorO := models.VectorValue{}
		okx := vectorO.VctToVectorValue(lop.OpVector)
		if okx {
			score.OattackVector = vectorO.AttackVector
			score.OattackComplexity = vectorO.AttackComplexity
			score.OprivilegeRequired = vectorO.PrivilegesRequired
			score.OuserInteraction = vectorO.UserInteraction
			score.Oscope = vectorO.Scope
			score.Oconfidentiality = vectorO.Confidentiality
			score.Ointegrity = vectorO.Integrity
			score.Oavailability = vectorO.Availability
		}
	}
	if vul.Status == 0 {
		accessToken := os.Getenv("GITEE_TOKEN")
		CreateDepositHooks(accessToken, owner, cveData.RepoPath, vul, cveData.Number, cveData.IssueId)
	}
	//var opensa models.OpenEulerSA
	////var os models.OpenSaId
	//os, operr := models.QueryOpenSaLastId()
	//var OpenNumData int
	//if operr == nil {
	//	OpenNumList := strings.Split(os.OpenEulerSANum, "-")
	//	OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList) - 1])
	//	if err == nil {
	//		OpenNum += 100
	//	} else {
	//		OpenNum = openeulernum
	//	}
	//	OpenNumData = OpenNum
	//} else {
	//	OpenNumData = openeulernum
	//}
	//OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	//opensa.OpenEulerSANum = OpenEulerSANum

	cveError := models.UpdateCveRelat(&vul, &sec, &score)
	if cveError != nil || vul.CveId == 0 {
		logs.Error("UpdateCveRelat(&vul, &sec, &sc) failed CveNum:", cveData.CveNumber, ",err:", cveError)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	if scOk || score.Id > 0 {
		if score.NVDScore != nVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = score.NVDScore
			scorecode.NvectorVule = score.NvectorVule
			scorecode.Status = 0
			models.InsertScoreRecord(&scorecode)
		}
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = vul.CveId
	localt, okl := models.GetIssueTemplet(&issueTemp)
	if okl && localt.TemplateId > 0 {
		issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = lop.Components
		issueTemp.OwnedVersion = lop.Version
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			issueTemp.OpenEulerScore = openEulerScore
		}
		issueTemp.OpenEulerVector = lop.OpVector
		issueTemp.CveBrief = lop.BriefIntroduction
		issueTemp.CveAnalysis = lop.Influences
		issueTemp.PrincipleAnalysis = lop.Principle
		issueTemp.AffectedVersion = lop.InfVersion
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.IssueId = cveData.IssueId
		issueTemp.IssueNum = cveData.Number
		issueTemp.Assignee = cveData.IssueAssignee
		if strings.ToLower(cveData.State) == "open" {
			issueTemp.Status = 1
			issueTemp.IssueStatus = 1
		} else if strings.ToLower(cveData.State) == "progressing" {
			issueTemp.Status = 2
			issueTemp.IssueStatus = 3
		} else if strings.ToLower(cveData.State) == "closed" {
			issueTemp.Status = 3
			issueTemp.IssueStatus = 2
		} else {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
		}
		issueTemp.StatusName = cveData.State
		issueTemp.Owner = cveData.RepoPath
		issueTemp.Repo = lop.Repo
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = cveData.IssueType
		issueTemp.CveLevel = vul.CveLevel
	} else {
		issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = lop.Components
		issueTemp.OwnedVersion = lop.Version
		issueTemp.NVDScore = nVDScore
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			issueTemp.OpenEulerScore = openEulerScore
		}
		issueTemp.NVDVector = lop.CvsVector
		issueTemp.OpenEulerVector = lop.OpVector
		issueTemp.CveBrief = lop.BriefIntroduction
		issueTemp.CveAnalysis = lop.Influences
		issueTemp.PrincipleAnalysis = lop.Principle
		issueTemp.AffectedVersion = lop.InfVersion
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.IssueId = cveData.IssueId
		issueTemp.IssueNum = cveData.Number
		issueTemp.Assignee = cveData.IssueAssignee
		if strings.ToLower(cveData.State) == "open" {
			issueTemp.Status = 1
			issueTemp.IssueStatus = 1
		} else if strings.ToLower(cveData.State) == "progressing" {
			issueTemp.Status = 2
			issueTemp.IssueStatus = 3
		} else if strings.ToLower(cveData.State) == "closed" {
			issueTemp.Status = 3
			issueTemp.IssueStatus = 2
		} else {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
		}
		issueTemp.StatusName = cveData.State
		issueTemp.IssueLabel = "cve/Undisclosed"
		issueTemp.Owner = cveData.RepoPath
		issueTemp.Repo = lop.Repo
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = cveData.IssueType
		issueTemp.CveLevel = vul.CveLevel
	}
	// 存储issue数据
	issTempId, issError := models.CreateIssueTemplet(&issueTemp)
	if issError != nil {
		logs.Error("创建issue 模板的数据失败, cveNum: ", cveData.CveNumber, "err: ", issError)
		return false, issError
	} else {
		logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cveData.CveNumber)
	}
	return true, nil
}

func GenCveVulerByIssue(cveData models.GiteOriginIssue, cveRef string, openeulernum int, owner string) (bool, error) {
	hole, err := cveData.ParseToLoophole()
	if err != nil {
		logs.Error("数据解析错误,")
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 2, cveData.RepoPath)
		models.UpdateCveIssueStatusById(3, cveData.Id)
		return false, err
	}
	goe, ok := models.QueryCveOpeneulerDetaildata(cveData.RepoPath, hole.Version)
	if !ok || goe.DetailId == 0 {
		logs.Error("获取数据失败，", "Components: ", hole.Components, ",Version: ", hole.Version)
	}
	if cveData.State != "" && strings.ToLower(cveData.State) == "rejected" {
		logs.Info("处理issue状态为拒绝状态的数据：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("数据处理失败， InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 2, cveData.RepoPath)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else if cveData.State != "" && strings.ToLower(cveData.State) == "closed" {
		logs.Info("处理issue状态为关闭状态的数据：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			lock.Unlock()
			//models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 2)
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("数据处理失败， InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 3, cveData.RepoPath)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else {
		logs.Info("处理issue状态为开启、处理中状态的数据：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
			lock.Unlock()
			//models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 2)
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("数据处理失败， InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	}
}

func GetCveIssueData(prcnum, days, openeulernum int, cveRef, owner string) (bool, error) {
	defer common.Catchs()
	count := 0
	for {
		gs, num, err := models.QueryOriginCveIssue(prcnum)
		if err != nil || num == 0 {
			logs.Info("当前无cveissue原始数据处理, err: ", err,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("总共有: ", num, "条的数据需要处理, ", gs)
		ch := make(chan int, len(gs))
		for i, cveData := range gs {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveData.IssueId)
			if cveData.CveNumber == "" || len(cveData.CveNumber) == 0 {
				logs.Error("数据异常, 不处理, cveData: ", cveData)
				models.UpdateCveIssueStatusById(3, cveData.Id)
				continue
			}
			go func() {
				ok, err := GenCveVulerByIssue(cveData, cveRef, openeulernum, owner)
				if !ok {
					logs.Error("cveData: ", cveData, "处理失败, err: ", err)
				}
				ch <- i
			}()
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

//GetSecurityNotice Go to the CVE official website to obtain the cve data to determine
//whether the cve issue needs to be exported.
func GetCveSecurityNotice(cveNumber string) bool {
	resp, err := http.Get(fmt.Sprintf(GetCveDetailUrl, cveNumber))
	if err != nil {
		logs.Error(err)
		return false
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error(err)
		return false
	}
	var detail models.RespCveDetail
	err = json.Unmarshal(body, &detail)
	if err != nil {
		logs.Error(err)
		return false
	}
	if detail.Result != nil && detail.Result.Id > 0 {
		return true
	}
	return false

}

//FilterCveExported Filter exportable data
func FilterCveExported() {
	data, err := models.GetCanExportVulnCenterData()
	if err != nil {
		logs.Error(err)
		return
	}
	for _, v := range data {
		go func(center models.VulnCenter) {
			ewg.Add(1)
			defer ewg.Done()
			if GetCveSecurityNotice(center.CveNum) {
				center.IsExport = 1
				models.UpdateVulnCenter(&center, "is_export")
			}
		}(v)

	}
	ewg.Wait()
}

func GenerateExcelTask() error {
	FilterCveExported()
	tn := time.Now().Format("2006-01-02")
	fn := fmt.Sprintf("Cve数据与安全公告%s.xlsx", tn)
	err := GenerateCveExcel(fn, "openEuler", 0, true)
	if err != nil {
		return err
	}
	er := models.ExportRecord{FileName: fn}
	err = er.Insert()
	return err
}
