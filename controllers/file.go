package controllers

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

//FileController file operation routing processing
type FileController struct {
	beego.Controller
}

//DownloadLastExcel Download the latest excel file
// @router /lastExcel [get]
func (f *FileController) DownloadLastExcel() {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	err := common.CreateDir(fd)
	er := models.ExportRecord{}
	err = er.QueryLast()
	if err != nil {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("no file "))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//DownLoadExcelByFileCode download excel file by code
//@router /downloadExcel
func (f *FileController) DownLoadExcelByFileCode() {
	fd := beego.AppConfig.DefaultString("fileDir", "download")
	common.CreateDir(fd)
	fc := f.GetString("fileCode")
	if fc == "" {
		_ = f.Ctx.Output.Body([]byte("err: fileCode is a required parameter "))
		return
	}
	er := models.ExportRecord{FileCode: fc}
	err := er.Read("file_code")
	if err != nil {
		_ = f.Ctx.Output.Body([]byte(fmt.Sprintf("err: %v", err)))
		return
	}
	if er.FileName == "" {
		_ = f.Ctx.Output.Body([]byte("err: Can not find excel file by fileCode! "))
		return
	}
	if er.State == 0 {
		_ = f.Ctx.Output.Body([]byte("The file is being generated, please try again later!"))
		return
	}
	if er.State == 2 {
		_ = f.Ctx.Output.Body([]byte("File generation failed, please contact the administrator or regenerate!!"))
		return
	}
	fp := filepath.Join(fd, er.FileName)
	if ex, _ := util.IsExistPath(fp); !ex {
		_ = f.Ctx.Output.Body([]byte("error:file does not exist"))
	}
	f.Ctx.Output.Download(fp, er.FileName)
}

//TriggerCveData touch off generate cve data excel and get cve package
//@router /triggerCveData [get]
func (f *FileController) TriggerCveData() {
	timeUnix := time.Now().Unix()
	startTime := f.GetString("startTime")
	if startTime == "" {
		f.Ctx.WriteString("Error:start time cannot be empty")
		return
	}
	// proc OpenEulerSaNum
	taskhandler.UpdateUseOpenEulerSaNum()
	//It is time-consuming to generate excel, here is the current limit processing
	er := models.ExportRecord{}
	err := er.QueryLast()
	if err == nil {
		if er.State == 0 && (timeUnix-er.CreateTime < 300) {
			eng := fmt.Sprintf("There is currently a file being generated, "+
				"file information: file name %s fileCode=%s; you can use fileCode to download the file.",
				er.FileName, er.FileCode)
			cha := fmt.Sprintf("\n当前有一个文件正在生成，文件信息：文件名 %s fileCode= %s ；"+
				"你可以使用fileCode去下载文件。", er.FileName, er.FileCode)
			f.Ctx.WriteString(eng + cha)
			return
		}
	} else {
		logs.Error(err)
	}
	rt := regexp.MustCompile(`^(\d{4})-\d{2}-(\d{2})$`)
	find := rt.Match([]byte(startTime))
	if !find {
		f.Ctx.WriteString(`Error: please enter the correct start time in a format like this "yyyy-MM-dd".`)
		return
	}
	dir := beego.AppConfig.DefaultString("fileDir", "download")
	dirErr := util.MakeDir(dir)
	if dirErr != nil {
		logs.Error(dirErr)
		f.Ctx.WriteString(`Error: File execution permission error, continue processing later.`)
		return
	}
	var wgCrvf sync.WaitGroup
	componentMap := make(map[string]taskhandler.ComponentInfo)
	cvrfFileList := make(map[string][]string)
	cvrfFileMap := make(map[string]taskhandler.CvrfSa)
	affectBranchSlice := make([]string, 0)
	du := "openEuler-20.03-LTS@https://gitee.com/unsunghero/obs_pkg_rpms/raw/master/latest_rpm/openEuler-20.03-LTS.csv"
	//du := beego.AppConfig.String("excel::v_pack_20_03_url")
	du = beego.AppConfig.DefaultString("excel::v_pack_20_03_url", du)
	csvPathList := strings.Split(du, ";")
	if len(csvPathList) > 0 {
		for _, csvP := range csvPathList {
			openBranchx := strings.Split(csvP, "@")
			if len(openBranchx) == 2 {
				affectBranch := openBranchx[0]
				affectBranchSlice = append(affectBranchSlice, affectBranch)
				csvDownPath := openBranchx[1]
				now := time.Now().Unix()
				en := fmt.Sprintf("cve与安全公告%v_%v.xlsx", openBranchx[0], now)
				fileCode := common.EncryptMd5(en)
				//call the generate excel task by new thread
				er = models.ExportRecord{FileName: en, FileCode: fileCode, State: 0, CreateTime: timeUnix}
				err = er.Insert()
				if err != nil {
					f.Ctx.WriteString(fmt.Sprintf("error:%v", err))
				} else {
					// return the success notice
					// Need to be executed sequentially
					wgCrvf.Add(1)
					taskhandler.GenerateExcelTrigger(&wgCrvf, en, startTime, fileCode, affectBranch,
						csvDownPath, dir, cvrfFileList, componentMap, cvrfFileMap)
					// Return the result first, continue processing the data
					f.Ctx.WriteString(fmt.Sprintf("Success：The name of the excel file generated this time is: %s. "+
						"It takes some time to generate the excel file. "+
						"You can try to call the download file interface and pass in the param fileCode=%s to be downloaded.", en, fileCode))
				}
			}
		}
	}
	wgCrvf.Wait()
	// Generate cvrf file
	GenAndUploadCvrf(cvrfFileMap, cvrfFileList, componentMap, affectBranchSlice, dir)
}

// generate and upload cvrf.xml
func GenAndUploadCvrf(cvrfFileMap map[string]taskhandler.CvrfSa,
	cvrfFileList map[string][]string, componentMap map[string]taskhandler.ComponentInfo,
	affectBranchSlice []string, dir string) {
	//if len(cvrfFileMap) > 0 {
	//	for cvrfKey, cvrfVule := range cvrfFileMap {
	//		taskhandler.WriteCvrfXml(cvrfKey, &cvrfVule)
	//	}
	//}
	common.CreateDir(dir)
	writeCvrfSlice := make([]string, 0)
	totalFileSlice := make([]string, 0)
	if len(componentMap) > 0 {
		for comKey, comValue := range componentMap {
			if len(affectBranchSlice) > 1 {
				isEque := true
				branchInfo1 := comValue.CveNumMap[affectBranchSlice[0]].CveNumSlice
				for _, branchInfo := range affectBranchSlice[1:] {
					if !common.CompareSlice(branchInfo1, comValue.CveNumMap[branchInfo].CveNumSlice) {
						isEque = false
						break
					}
				}
				if isEque {
					cvrfFileName := componentMap[comKey].CvrfFileName
					cvrfVule := cvrfFileMap[cvrfFileName]
					md5Ok, tmpOpenEulerSANum := taskhandler.QueryCveMd5(componentMap[comKey].CveNum, componentMap[comKey].OwnedComponent,
						componentMap[comKey].OpenEulerSANum, taskhandler.FIXEDFLAGE)
					taskhandler.WriteCvrfXml(cvrfFileName, &cvrfVule)
					writeCvrfSlice = append(writeCvrfSlice, cvrfFileName)
					if md5Ok {
						UpdateOpenEulerSaNumStatus(tmpOpenEulerSANum)
						var saf models.SaFileList
						saf.FileName = "cvrf-" + tmpOpenEulerSANum + ".xml"
						models.DeleteCvrfFileName(&saf, "FileName")
					}
					for _, br := range comValue.CveNumMap {
						UpdateOpenEulerSaNumStatus(br.OpenEulerSANum)
					}
				} else {
					for _, br := range comValue.CveNumMap {
						cvrfFileName := br.CvrfFileName
						cvrfVule := cvrfFileMap[br.CvrfFileName]
						md5Ok, tmpOpenEulerSANum := taskhandler.QueryCveMd5(br.CveNumSlice, componentMap[comKey].OwnedComponent,
							br.OpenEulerSANum, taskhandler.FIXEDFLAGE)
						taskhandler.WriteCvrfXml(cvrfFileName, &cvrfVule)
						writeCvrfSlice = append(writeCvrfSlice, cvrfFileName)
						if md5Ok {
							UpdateOpenEulerSaNumStatus(tmpOpenEulerSANum)
							var saf models.SaFileList
							saf.FileName = "cvrf-" + tmpOpenEulerSANum + ".xml"
							models.DeleteCvrfFileName(&saf, "FileName")
						}
					}
					UpdateOpenEulerSaNumStatus(comValue.OpenEulerSANum)
				}
			} else {
				cvrfFileName := componentMap[comKey].CvrfFileName
				cvrfVule := cvrfFileMap[cvrfFileName]
				md5Ok, tmpOpenEulerSANum := taskhandler.QueryCveMd5(componentMap[comKey].CveNum, componentMap[comKey].OwnedComponent,
					componentMap[comKey].OpenEulerSANum, taskhandler.FIXEDFLAGE)
				taskhandler.WriteCvrfXml(cvrfFileName, &cvrfVule)
				writeCvrfSlice = append(writeCvrfSlice, cvrfFileName)
				if md5Ok {
					UpdateOpenEulerSaNumStatus(tmpOpenEulerSANum)
					var saf models.SaFileList
					saf.FileName = "cvrf-" + tmpOpenEulerSANum + ".xml"
					models.DeleteCvrfFileName(&saf, "FileName")
				}
				for _, br := range comValue.CveNumMap {
					UpdateOpenEulerSaNumStatus(br.OpenEulerSANum)
				}
			}
		}
	}
	cvrfFileList[taskhandler.CVRFFKEY] = writeCvrfSlice
	uploadCvrfFile(cvrfFileList, totalFileSlice, dir, componentMap)
}

func uploadCvrfFile(cvrfFileList map[string][]string, totalFileSlice []string, dir string,
	componentMap map[string]taskhandler.ComponentInfo) {
	uploadPath := beego.AppConfig.String("xml::cvrf_upload_path")
	// File name and data stored in database
	fileSlice, fOk := cvrfFileList[taskhandler.CVRFFKEY]
	if fOk {
		subFileSlice := make([]string, 0)
		for _, fPath := range fileSlice {
			_, fileName := filepath.Split(fPath)
			// File storage to db
			recordErr := taskhandler.RecordCrvfInfo(fPath, fileName, taskhandler.FIXEDFLAGE)
			logs.Info("recordErr: ", recordErr)
			// Upload file, pending
			uploadErr := taskhandler.PostFile(fPath, uploadPath)
			if uploadErr == nil {
				taskhandler.ProcCvrfFileName(fileName)
				subFileSlice = append(subFileSlice, fileName)
				totalFileSlice = append(totalFileSlice, fPath)
				// Upload successfully, modify file status
				if len(fileName) > 5 {
					openEulerSANum := fileName[5 : len(fileName)-4]
					taskhandler.UpdateCvrfRecord(openEulerSANum, 2)
				}
			} else {
				logs.Error(uploadErr)
			}
		}
		totalSlice := make([]string, 0)
		sfl := models.GetCvrfAllFile()
		indexFilePath := filepath.Join(dir, "index.txt")
		updateFilePath := filepath.Join(dir, "update_fixed.txt")
		curYears := strconv.Itoa(time.Now().Year())
		if len(sfl) > 0 {
			for _, l := range sfl {
				totalSlice = append(totalSlice, curYears+"/"+l.FileName)
			}
			//totalSlice = append(totalSlice, subFileSlice...)
			readErr := taskhandler.ReadWriteFile(indexFilePath, totalSlice)
			logs.Info(readErr)
		} else {
			readErr := taskhandler.ReadWriteFile(indexFilePath, subFileSlice)
			logs.Info(readErr)
		}
		taskhandler.PostFile(indexFilePath, uploadPath)
		readErr := taskhandler.ReadWriteFile(updateFilePath, subFileSlice)
		if readErr != nil {
			logs.Error(updateFilePath, readErr)
		}
		taskhandler.PostFile(updateFilePath, uploadPath)
		totalFileSlice = append(totalFileSlice, indexFilePath)
		totalFileSlice = append(totalFileSlice, updateFilePath)
		//if len(subFileSlice) > 0 {
		//	taskhandler.SendCvrfEmail(subFileSlice)
		//}
		////Delete local files
		//taskhandler.DelFile(fileSlice)
	}
	unaffFileSlice, unffOk := cvrfFileList[taskhandler.UNAFFECTCVRFKEY]
	if unffOk {
		subFileSlice := make([]string, 0)
		updateFilePath := filepath.Join(dir, "update_unaffect.txt")
		for _, fPath := range unaffFileSlice {
			taskhandler.WriteUnaffectCvrfXml(fPath, componentMap[fPath].UnaffectFile)
			_, fileName := filepath.Split(fPath)
			// File storage to db
			recordErr := taskhandler.RecordCrvfInfo(fPath, fileName, taskhandler.UNAFFECTFLAG)
			logs.Info("recordErr: ", recordErr)
			// Upload file, pending
			uploadErr := taskhandler.PostFile(fPath, uploadPath)
			if uploadErr == nil {
				subFileSlice = append(subFileSlice, fileName)
				totalFileSlice = append(totalFileSlice, fPath)
				// Upload successfully, modify file status
				if len(fileName) > 5 {
					openEulerSANum := fileName[5 : len(fileName)-4]
					taskhandler.UpdateCvrfRecord(openEulerSANum, 2)
				}
			} else {
				logs.Error(uploadErr)
			}
		}
		taskhandler.ReadWriteFile(updateFilePath, subFileSlice)
		taskhandler.PostFile(updateFilePath, uploadPath)
		totalFileSlice = append(totalFileSlice, updateFilePath)
	}
	if len(totalFileSlice) > 0 {
		//taskhandler.SendCvrfEmail(totalFileSlice)
		dir := "download"
		zipFileName := "cvrf-" + common.GetCurDate() + "_" + strconv.Itoa(time.Now().Nanosecond()) + ".zip"
		zipFileName = filepath.Join(dir, zipFileName)
		zipErr := taskhandler.ZipFiles(zipFileName, totalFileSlice, dir, dir)
		if zipErr != nil {
			logs.Error("File compression failed: err: ", zipErr)
		}
		// send email
		sendError := taskhandler.SendEmail(zipFileName, 1, "", "")
		if sendError != nil {
			logs.Error("SendEmail, sendErr: ", sendError)
			return
		}
		totalFileSlice = append(totalFileSlice, zipFileName)
	}
	// Delete local files
	taskhandler.DelFile(totalFileSlice)
	logs.Info(cvrfFileList[taskhandler.BRANCHSKEY], ",End of generating cvrf format file this time")
}

func UpdateOpenEulerSaNumStatus(openEulerSANum string) {
	var sa models.SaNumber
	curYears := strconv.Itoa(time.Now().Year())
	sa.SaYears = curYears
	sa.OpenEulerSANum = openEulerSANum
	sa.UpdateTime = common.GetCurTime()
	getErr := models.GetSaNumber(&sa, "OpenEulerSANum", "SaYears")
	if getErr == nil {
		sa.Status = 1
		models.UpdateSaNumber(&sa, "status")
	}
}
