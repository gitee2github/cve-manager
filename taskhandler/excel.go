package taskhandler

import (
	"cvevulner/models"
	"errors"
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/astaxie/beego/logs"
	"os"
	"strings"
	"time"
)

type CveExcel struct {
	ExcelName            string         //excel 名字
	ExcelHandel          *excelize.File //excel 文件句柄
	CveSheetIdx          int            //CVE sheet index
	CveSheetName         string         // CVE sheet Name
	SecNoticeSheetIdx    int            //安全公告index
	SecNoticeSheetName   string         //安全公告sheet名字
	SecNoticePrefix      string         //安全公告前缀
	SecNoticeSuffixIdx   int64          //安全公告后缀起始值
	InfProductSheetName  string         //CVE 影响的产品
	InfProductSheetIndex int
	PackageUrlSheetName  string
	PackageUrlSheetIndex int
}

//GenerateCveExcel Generate Excel documents based on data.
//param snPrefix means security notice prefix.
//param snSuffix means security notice suffix append start value.
//param forceRewrite means whether to force the document to be rewritten.
func GenerateCveExcel(excelName, snPrefix string, snSuffix int64, forceRewrite bool) (err error) {
	//Query the data to be exported.
	count := models.GetCanExportVulnCenterCount()
	if count < 1 {
		return errors.New("No data to export! ")
	}
	//init excelClient
	ec := CveExcel{}
	err = ec.Init(excelName, snPrefix, snSuffix)
	if err != nil {
		return err
	}
	mode := ec.InitFileHandle(forceRewrite)
	if mode == 0 {
		ec.InitSheet()
		err = ec.FillHeader()
		if err != nil {
			logs.Error(err)
		}
	}
	ec.FillContent(count)
	//generate excel
	return ec.Save(mode)
}

func (ec *CveExcel) Init(excelName, snPrefix string, snSuffix int64) (err error) {
	if excelName == "" || !(strings.HasSuffix(excelName, ".xlsx") || strings.HasSuffix(excelName, "xls")) {
		err = errors.New("excel name illegal")
		return
	}
	ec.ExcelName = excelName
	ec.SecNoticePrefix = snPrefix
	ec.SecNoticeSuffixIdx = snSuffix
	ec.CveSheetIdx = 0
	ec.CveSheetName = "CVE"
	ec.SecNoticeSheetIdx = 1
	ec.SecNoticeSheetName = "安全公告"
	ec.InfProductSheetIndex = 2
	ec.InfProductSheetName = "CVE影响的产品"
	ec.PackageUrlSheetIndex = 3
	ec.PackageUrlSheetName = "安全公告升级包链接"
	return nil
}

//InitFileHandle Initialize the file handle.
//param forceRewrite is true it means will create a new file otherwise it means append or new.
//the return value wm is 0 for new creation, and 1 for append.
func (ec *CveExcel) InitFileHandle(forceRewrite bool) (wm int8) {
	if forceRewrite {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	s, err := os.Stat(ec.ExcelName)
	if err != nil {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
	if !s.IsDir() {
		file, err := excelize.OpenFile(ec.ExcelName)
		if err != nil {
			ec.ExcelHandel = excelize.NewFile()
			return 0
		} else {
			ec.ExcelHandel = file
			return 1
		}
	} else {
		ec.ExcelHandel = excelize.NewFile()
		return 0
	}
}

func (ec *CveExcel) InitSheet() {
	ec.SecNoticeSheetIdx = ec.ExcelHandel.NewSheet(ec.SecNoticeSheetName)
	ec.InfProductSheetIndex = ec.ExcelHandel.NewSheet(ec.InfProductSheetName)
	ec.PackageUrlSheetIndex = ec.ExcelHandel.NewSheet(ec.PackageUrlSheetName)
	sn := ec.ExcelHandel.GetSheetName(ec.CveSheetIdx)
	ec.ExcelHandel.SetSheetName(sn, ec.CveSheetName)
}

func (ec *CveExcel) FillHeader() (err error) {
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "A1", "CVE编号")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "A1", "A2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "B1", "概要")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "B1", "B2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "C1", "Cvss Score")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "C1", "D1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "c2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "D2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E1", "Attack Vector")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "E1", "F1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "E2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "F2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G1", "Attack Complexity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "G1", "H1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "G2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "H2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I1", "Privileges Required")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "I1", "J1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "I2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "J2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K1", "User Interaction")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "K1", "L1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "K2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "L2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M1", "Scope")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "M1", "N1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "M2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "N2", "OpenEuler")
	if err != nil {
		return
	}

	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O1", "Confidentiality")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "O1", "P1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "O2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "P2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q1", "Integrity")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "Q1", "R1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "Q2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "R2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S1", "Availability")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "S1", "T1")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "S2", "NVD")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "T2", "OpenEuler")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "U1", "评分类型")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "U1", "U2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "V1", "安全公告")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "V1", "V2")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.SetCellValue(ec.CveSheetName, "W1", "公告时间")
	if err != nil {
		return
	}
	err = ec.ExcelHandel.MergeCell(ec.CveSheetName, "W1", "W2")
	if err != nil {
		return
	}
	//安全公告表头生成
	sh := []interface{}{"公告编号", "CVE编号", "简介", "概要", "主题", "描述", "影响组件", "影响产品", "影响包名", "参考", "公告时间"}
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, "A1", &sh)
	if err != nil {
		return err
	}
	ih := []interface{}{"CVE编号","影响的产品","包","状态"}
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, "A1", &ih)
	if err != nil {
		return err
	}
	ph := []interface{}{"包名","包下载链接"}
	err = ec.ExcelHandel.SetSheetRow(ec.PackageUrlSheetName, "A1", &ph)
	if err != nil {
		return err
	}
	return nil
}

func (ec *CveExcel) FillContent(count int64) {
	pageSize := 50
	pageCount := count / int64(pageSize)
	if count%int64(pageSize) > 0 {
		pageCount += 1
	}
	for i := int64(0); i < pageCount; i++ {
		off := i * int64(pageSize)
		err := ec.handleWriteContent(off, pageSize)
		if err != nil {
			logs.Error(err)
		}
	}
}

func (ec *CveExcel) handleWriteContent(off int64, size int) (err error) {
	list, err := models.GetCanExportCveData(off, size)
	if err != nil {
		return err
	}
	lz := len(list)
	if lz > 0 {
		for _, v := range list {
            pkg,err := models.GetCvePackageList(v.SecId)
            if err !=nil{
            	logs.Error(err)
			}
			if v.PublicDate == ""{
				v.PublicDate = time.Now().Format("2006-01-02")
			}
			pkgStr := getPkgStr(pkg)
			cve := []interface{}{v.CveNum, v.CveBrief, v.NVDScore, v.OpenEulerScore, v.NattackVector, v.OattackVector,
				v.NattackComplexity, v.OattackComplexity, v.NprivilegeRequired, v.OprivilegeRequired, v.NuserInteraction,
				v.OuserInteraction,v.Nscope, v.Oscope, v.Nconfidentiality, v.Oconfidentiality, v.Nintegrity, v.Ointegrity,
				v.Navailability,v.Oavailability, v.ScoreType, v.OpenEulerSANum, v.PublicDate}
			err = ec.FillCveSheetRow(cve)
			if err != nil {
				logs.Error(err)
			}
			sn := []interface{}{v.OpenEulerSANum,v.CveNum,v.Introduction,v.Summary,v.Theme,v.Description,v.InfluenceComponent,
				v.AffectProduct,pkgStr,v.ReferenceLink,v.PublicDate}
			err = ec.FillSecurityNoticeSheet(sn)
			if err != nil {
				logs.Error(err)
			}
			ap := []interface{}{v.CveNum,v.AffectProduct,v.InfluenceComponent,v.AffectStatus}
			err = ec.FillAffectProductSheet(ap)
			if err != nil {
				logs.Error(err)
			}
			for _,v := range pkg{
				pk := []interface{}{v.PackName,v.PackUrl}
				err := ec.FillPackageSheet(pk)
				if err != nil {
					logs.Error(err)
				}
			}
		}
	}
	return nil
}

func getPkgStr(pkg []models.Package) string {
	pkgStr := ""
	if len(pkg)==0 {
		return pkgStr
	}
	var  ps []string
	for _,v :=range pkg {
		if v.PackName != ""{
			ps = append(ps, v.PackName)
		}
	}
	return  strings.Join(ps,";\n")
}

func (ec *CveExcel) FillCveSheetRow(row []interface{}) (err error) {
	rows, err := ec.ExcelHandel.GetRows(ec.CveSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.CveSheetName, axis, &row)
	return err
}

func (ec *CveExcel) FillSecurityNoticeSheet(row []interface{})(err error)  {
	rows, err := ec.ExcelHandel.GetRows(ec.SecNoticeSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.SecNoticeSheetName, axis, &row)
	return err
}

func (ec *CveExcel) FillAffectProductSheet(row []interface{})(err error)  {
	rows, err := ec.ExcelHandel.GetRows(ec.InfProductSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.InfProductSheetName, axis, &row)
	return err
}

func (ec *CveExcel) FillPackageSheet(row []interface{})(err error)  {
	rows, err := ec.ExcelHandel.GetRows(ec.PackageUrlSheetName)
	if err != nil {
		return err
	}
	idx := len(rows) + 1
	axis := fmt.Sprintf("A%d", idx)
	err = ec.ExcelHandel.SetSheetRow(ec.PackageUrlSheetName, axis, &row)
	return err
}

func (ec *CveExcel) Save(md int8) error {
	if md == 0 {
		return ec.ExcelHandel.SaveAs(ec.ExcelName)
	} else {
		return ec.ExcelHandel.Save()
	}
}
