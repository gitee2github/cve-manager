package util

import (
	"fmt"
	"regexp"
	"strings"
	"sync"
)

var (
	LAC  = "LAC"  //漏洞组件标签
	LN   = "LN"   //漏洞编号标签
	LAV  = "LAV"  //漏洞版本标签
	CVS  = "CVS"  //cvss 3.0分值标签
	CVV  = "CVV"  //cvss 3.1向量标签
	LD   = "LD"   //漏洞描述标签
	IAD  = "IAD"  //影响分析说明标签
	PA   = "PA"   //原理分析标签
	OES  = "OES"  //openEuler评分标签
	OEV  = "OEV"  //openEuler向量标签
	IV   = "IV"   //影响的版本标签
	CPMM = "CPMM" //规避方案措施
	IW   = "IW"   //影响的包
)

var VectorMap map[string]map[string]string
var mutex sync.Mutex

func init() {
	//pattenStr := `/AV:[NL]/AC:[HL]/PR:[NH]/UI:N/S:U/C:[LH]/I:[HN]/A:[LNH]`
	VectorMap = make(map[string]map[string]string)
	mAv := make(map[string]string)
	mAv["N"] = "Network"
	mAv["L"] = "Local"
	VectorMap["AV"] = mAv
	mAc := make(map[string]string)
	mAc["H"] = "High"
	mAc["L"] = "Low"
	VectorMap["AC"] = mAc
	mPr := make(map[string]string)
	mPr["H"] = "High"
	mPr["N"] = "None"
	VectorMap["PR"] = mPr
	mUi := make(map[string]string)
	mUi["N"] = "None"
	VectorMap["UI"] = mUi
	mS := make(map[string]string)
	mS["U"] = "Unchanged"
	VectorMap["S"] = mS
	mC := make(map[string]string)
	mC["H"] = "High"
	mC["L"] = "Low"
	VectorMap["C"] = mC
	mI := make(map[string]string)
	mI["H"] = "High"
	mI["N"] = "None"
	VectorMap["I"] = mC
	mA := make(map[string]string)
	mA["H"] = "High"
	mA["L"] = "Low"
	mI["N"] = "None"
	VectorMap["A"] = mA
}

//ParseCommentContent extract comment content based on tags.
func ParseCommentContent(content string, label string) (res string, ok bool) {
	ret := regexp.MustCompile(genCommentRegexpStr(label))
	sm := ret.FindAllStringSubmatch(content, 1)
	if len(sm) > 0 {
		res = sm[0][1]
		ok = true
	}
	return
}

func ParseCommentVector(content string) string {
	pattenStr := `/AV:[NL]/AC:[HL]/PR:[NH]/UI:N/S:U/C:[LH]/I:[HN]/A:[LNH]`
	ret := regexp.MustCompile(pattenStr)
	sm := ret.Find([]byte(content))
	return string(sm)

}

func ReadVmValue(kstr string) (value string) {
	if kstr == "" {
		return ""
	}
	if !strings.Contains(kstr, ":") {
		return ""
	}
	kstr = TrimString(kstr)
	sKs := strings.Split(kstr, ":")
	if len(sKs) != 2 {
		return ""
	}
	mutex.Lock()
	defer mutex.Unlock()
	if _, ok := VectorMap[sKs[0]]; ok {
		value = VectorMap[sKs[0]][sKs[1]]
	}
	return
}

func VctToMap(vct string) (vctMap map[string]string, ok bool) {
	if vct == "" {
		return nil, false
	}
	sp := strings.Split(vct, "/")
	if len(sp) < 1 {
		return nil, false
	}
	vMap := make(map[string]string)
	for _, v := range sp {
		spv := strings.Split(v, ":")
		if len(spv) != 2 {
			continue
		}
		vMap[spv[0]] = v
	}
	if len(vMap) > 0 {
		return vMap, true
	} else {
		return nil, false
	}
}

func ParseCommentWithAllLabel(content string) map[string]string {
	res := make(map[string]string, 0)
	s, ok := ParseCommentContent(content, IAD)
	if ok {
		res["cve_analysis"] = s
	}
	s, ok = ParseCommentContent(content, PA)
	if ok {
		res["principle_analysis"] = s
	}
	s, ok = ParseCommentContent(content, OES)
	if ok {
		res["openeuler_score"] = TrimString(s)
	}
	s, ok = ParseCommentContent(content, OEV)
	if ok {
		vector := ParseCommentVector(s)
		if vector != "" {
			res["openeuler_vector"] = s
		}
	}
	s, ok = ParseCommentContent(content, IV)
	if ok {
		res["affected_version"] = s
	}
	s, ok = ParseCommentContent(content, CPMM)
	if ok {
		res["solution"] = s
	}
	s,ok =ParseCommentContent(content,IW)
	if ok {
		res["issue_package"]=s
	}

	return res
}

func genCommentRegexpStr(label string) string {
	return fmt.Sprintf(`\[%s\](?s:(.*?))\[/%s\]`, label, label)
}

func TrimString(str string) string {
	str = strings.Replace(str, " ", "", -1)
	str = strings.Replace(str, "\n", "", -1)
	str = strings.Replace(str, "\r", "", -1)
	return str
}
