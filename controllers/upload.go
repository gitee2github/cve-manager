package controllers

import (
	"cvevulner/common"
	"cvevulner/errcode"
	"cvevulner/models"
	"cvevulner/task"
	"encoding/json"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"strings"
)

type UserUploadController struct {
	beego.Controller
}

type ResultData struct {
	CveNum string `json:"CveNum"`
	Status int    `json:"Status"`
}

func (c *UserUploadController) RetData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
	// sysnc cve and create issue
	synErr := task.SyncCveAndIssue()
	if synErr != nil {
		logs.Error("SyncCveAndIssue, Sync cve data error, err: ", synErr)
	} else {
		logs.Info("SyncCveAndIssue, cve data has been synchronized")
	}
}

func (c *CveErrorFeedBackController) RetData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type CveErrorFeedBackController struct {
	beego.Controller
}

type CveErrorData struct {
	CveNum        string `json:"cveNum"`
	ErrorDesc     string `json:"errorDesc"`
	CveUploadTime string `json:"cveUploadTime"`
}

// @Title Get cveerrorfeedback
// @Description get cveerrorfeedback
// @Param	startDate		endDate 	string	false
// @Success 200 {object} models.uploadcve
// @Failure 403 :endDate is err
// @router / [get]
func (u *CveErrorFeedBackController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		",Header: ", req.Header, ",body: ", req.Body)
	resp := make(map[string]interface{})
	var ced []CveErrorData
	resp["errno"] = errcode.RecodeUnknowErr
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeUnknowErr)
	resp["body"] = []CveErrorData{}
	defer u.RetData(resp)
	var iw models.IpWhite
	if addr != "" {
		addrIp := strings.Split(addr, ":")
		err := models.GetIpWhite(addrIp[0], &iw)
		if err != nil {
			resp["errno"] = errcode.RecodeIpErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeIpErr)
			return
		}
	} else {
		resp["errno"] = errcode.RecodeIpErr
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeIpErr)
		return
	}
	token := u.GetString("token")
	if token == "" {
		resp["errno"] = errcode.RecodeSessionErr
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeSessionErr)
		return
	} else {
		ok := models.CheckToken(token)
		if !ok {
			resp["errno"] = errcode.RecodeRoleErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeRoleErr)
			return
		}
	}

	startDate := u.GetString("startDate")
	if startDate != "" {
		logs.Info("Query start date: ", startDate)
	}

	endDate := u.GetString("endDate")
	if endDate != "" {
		logs.Info("Query end date: ", endDate)
	} else {
		endDate = common.GetCurTime()
	}

	it, ok := models.QueryCveErrorInfo(3, startDate, endDate)
	if ok {
		for _, cveErr := range it {
			var ved CveErrorData
			ved.CveNum = cveErr.CveNum
			ved.CveUploadTime = common.TimeConverStr(cveErr.CreateTime.String()[:19])
			ved.ErrorDesc = cveErr.ErrorDescription
			ced = append(ced, ved)
		}
		resp["body"] = ced
		resp["errno"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
	} else {
		resp["errno"] = errcode.RecodeNodata
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
		return
	}
}

// @Title UserUpload
// @Description UserUpload
// @Param	body		body 	models.OriginUpstream	true		"body for user content"
// @Success 200 {int} models.OriginUpstream.CveId
// @Failure 403 body is empty
// @router / [post]
func (u *UserUploadController) Post() {
	var uploaddata common.UploadData
	var ResDataList []ResultData
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr, ",Header: ", req.Header)
	resp := make(map[string]interface{})
	resp["errno"] = errcode.RecodeUnknowErr
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeUnknowErr)
	resp["body"] = []ResultData{}
	defer u.RetData(resp)
	json.Unmarshal(u.Ctx.Input.RequestBody, &uploaddata)
	logs.Info("Cve upload request parameters: ", string(u.Ctx.Input.RequestBody))
	var iw models.IpWhite
	if addr != "" {
		addrIp := strings.Split(addr, ":")
		err := models.GetIpWhite(addrIp[0], &iw)
		if err != nil {
			resp["errno"] = errcode.RecodeIpErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeIpErr)
			return
		}
	} else {
		resp["errno"] = errcode.RecodeIpErr
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeIpErr)
		return
	}
	//Judge whether it is legal
	if uploaddata.Token == "" {
		resp["errno"] = errcode.RecodeSessionErr
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeSessionErr)
		resp["body"] = []ResultData{}
		logs.Error("token request parameter is empty!")
		return
	} else {
		// Check token
		ok := models.CheckToken(uploaddata.Token)
		if !ok {
			resp["errno"] = errcode.RecodeSessionErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeSessionErr)
			resp["body"] = []ResultData{}
			logs.Error("token verification failed!")
			return
		}
	}
	if uploaddata.CveData == nil || len(uploaddata.CveData) == 0 {
		resp["errno"] = errcode.RecodeNodata
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
		resp["body"] = []ResultData{}
		logs.Error("cve data is empty")
		return
	}
	for _, CveDataDict := range uploaddata.CveData {
		defer common.Catchs()
		logs.Info("Each request parameter: ", CveDataDict)
		var ResData ResultData
		ids := CveDataDict.Ids
		if len(ids) < 1 {
			ResData.CveNum = ids
			ResData.Status = 1
			ResDataList = append(ResDataList, ResData)
			logs.Error("ids is null, cveDataDict:", CveDataDict)
			continue
		}
		cveNum := CveDataDict.CveNum
		if len(cveNum) < 2 {
			ResData.CveNum = cveNum
			ResData.Status = 1
			ResDataList = append(ResDataList, ResData)
			logs.Error("CveNum is null, cveDataDict:", CveDataDict)
			continue
		}
		updateType := CveDataDict.UpdateType
		cvePackName := ""
		if len(CveDataDict.CvePackName) > 0 {
			cvePackName = strings.Join(CveDataDict.CvePackName, ",")
		}
		packName := ""
		if len(CveDataDict.PackName) > 1 {
			packName = strings.Join(CveDataDict.PackName, ",")
		} else {
			ResData.CveNum = cveNum
			ResData.Status = 1
			ResDataList = append(ResDataList, ResData)
			logs.Error("PackName is null, cveDataDict:", CveDataDict)
			continue
		}
		title := CveDataDict.Title
		affectProduct := ""
		if len(CveDataDict.AffectProduct) > 1 {
			affectProduct = strings.Join(CveDataDict.AffectProduct, ",")
		} else {
			affectProduct = packName
		}
		cnnvdID := CveDataDict.CnnvdID
		cnvdID := CveDataDict.CnvdID
		publishedDate := CveDataDict.PublishedDate
		vulStatus := CveDataDict.VulStatus
		version := CveDataDict.Version
		if version == "" {
			version = packName
		}
		var orCve models.OriginUpstream
		if ids != "" {
			ids = common.DeletePreAndSufSpace(ids)
		}
		orCve.Ids = ids
		if cveNum != "" {
			cveNum = common.DeletePreAndSufSpace(cveNum)
		}
		orCve.CveNum = cveNum
		orCve.Version = version
		orCve.UpdateType = updateType
		orCve.CvePackName = cvePackName
		orCve.Credibility = CveDataDict.Credibility
		if packName != "" {
			packName = common.DeletePreAndSufSpace(packName)
		}
		orCve.PackName = packName
		orCve.Title = title
		if affectProduct == "" {
			orCve.AffectProduct = packName
		}
		orCve.CnnvdID = cnnvdID
		orCve.CnvdID = cnvdID
		orCve.IsExit = 0
		orCve.PublishedDate = publishedDate
		packNameList := []string{}
		if packName != "" && len(packName) > 0 {
			packNameList = strings.Split(packName, ",")
		}
		if len(packNameList) > 0 {
			for _, pk := range packNameList {
				pkList := strings.Split(pk, "==")
				if len(pkList) == 2 {
					var gits models.GitOpenEuler
					gits.PackageName = pkList[0]
					gits.Version = pkList[1]
					gits.Status = 1
					ok := models.QueryCveOpeneulerdata(&gits)
					if ok {
						orCve.IsExit = 1
						logs.Info("The data corresponding to src-openEuler is: ", gits)
						break
					} else {
						opy := models.OpenGussYaml{PackageName: pkList[0], Version: pkList[1]}
						openErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
						if openErr == nil && opy.Id > 0 {
							orCve.IsExit = 1
							break
						}
					}
				}
			}
		}
		orCve.VulStatus = vulStatus
		if strings.ToLower(updateType) == "delete" {
			orCve.Status = 3
		} else if strings.ToLower(updateType) == "update" {
			orCve.Status = 1
		} else {
			orCve.Status = 0
		}
		orCve.CreateTime = common.GetCurTime()
		orCve.UpdateTime = common.GetCurTime()
		var od models.OriginUpstreamDesc
		od.EnDescription = CveDataDict.Description.EnDesc
		od.ZhDescription = CveDataDict.Description.ZhDesc
		var ous models.OriginUpstreamConfig
		ous.Nodes = " "
		var osi models.OriginUpstreamImpact
		osi.Impact = " "
		var osp models.OriginUpstreamPoc
		osp.Url = CveDataDict.Poc.Url
		osp.Date = CveDataDict.Poc.Date
		osp.Dbindex = CveDataDict.Poc.Dbindex
		osp.Desc = CveDataDict.Poc.Desc
		osp.Path = CveDataDict.Poc.Path
		osp.Source = CveDataDict.Poc.Source
		var ose models.OriginUpstreamEvent
		ose.Date = CveDataDict.Event.Date
		ose.Url = CveDataDict.Event.Url
		ose.Description = CveDataDict.Event.Description
		ose.Title = CveDataDict.Event.Title
		var osv models.OriginUpstreamVulType
		osv.ZhDesc = CveDataDict.VulType.Zh
		osv.EnDesc = CveDataDict.VulType.En
		osv.Cwe = CveDataDict.VulType.Cwe
		var osf models.OriginUpstreamFixSuggest
		osf.Detail = CveDataDict.FixSuggest.Detail
		dbCve, ok := models.QueryCveOriginByIds(ids)
		if ok {
			if orCve.Status != 3 {
				orCve.Status = 1
			}
			orCve.UpdateTime = common.GetCurTime()
			if orCve.Status == 3 {
				orCve.DeleteTime = common.GetCurTime()
			}
			logs.Info("The currently inserted data already exists: ", dbCve)
		}
		_, err := models.CreateOriginCve(CveDataDict, &orCve, &od, &ous, &osi, &osp, &ose, &osv, &osf)
		if err == nil {
			logs.Info("Cve original data is successfully created CveNum: ", CveDataDict.Ids)
			ResData.CveNum = CveDataDict.Ids
			ResData.Status = 0
			ResDataList = append(ResDataList, ResData)
		} else {
			logs.Info("cve creation failed CveNum: ", CveDataDict.Ids)
			ResData.CveNum = CveDataDict.Ids
			ResData.Status = 1
			ResDataList = append(ResDataList, ResData)
		}
	}
	resp["errno"] = errcode.RecodeOk
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
	resp["body"] = ResDataList
	return
}
