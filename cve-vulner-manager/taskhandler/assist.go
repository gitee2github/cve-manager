package taskhandler

import (
	"cvevulner/util"
	"encoding/json"
	"errors"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"os"
	"strings"
)

func GetOautToken(gt GiteeToken) {
	url := "https://gitee.com/oauth/token"
	var req util.RequestInfo
	req.URL = url
	req.Data = make(map[string]string)
	req.Data["grant_type"] = gt.GrantType
	req.Data["username"] = gt.UserName
	req.Data["password"] = gt.Password
	req.Data["client_id"] = gt.ClientID
	req.Data["client_secret"] = gt.ClientSecret
	req.Data["scope"] = gt.Scope
	resp, err := util.PostURLEncoded(req)
	if err != nil {
		logs.Error("Failed to obtain token,url: ", url,
			",Request parameter: ", gt, ", err:", err)
		return
	}
	var respDict map[string]interface{}
	err = json.Unmarshal(resp, &respDict)
	if err != nil {
		logs.Error(err)
		return
	}
	if _, ok := respDict["access_token"]; !ok {
		logs.Error("Failed to obtain token, err: ", ok, ", url: ", url)
		return
	}
	GitToken := respDict["access_token"].(string)
	os.Setenv("GITEE_TOKEN", GitToken)
}

func GetCollaboratorInfo(accessToken string, owner string, path string) (string, error) {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/collaborators?access_token=" + accessToken
		collabor, err := util.HTTPGet(url)
		if err == nil && collabor != nil {
			for _, value := range collabor {
				if _, ok := value["id"]; !ok {
					logs.Error("collaborators, err: ", ok, "url: ", url)
					continue
				}
				assignee := ""
				flag := false
				for mapKey, mapValue := range value {
					if mapKey == "login" {
						assignee = mapValue.(string)
					}
					if mapKey == "permissions" {
						mapValuex := mapValue.(map[string]interface{})
						for perKey, perValue := range mapValuex {
							if perKey == "admin" && perValue.(bool) == true {
								flag = true
							}
						}
					}
				}
				if assignee != "" && flag {
					return assignee, nil
				}
			}
		} else {
			logs.Error("Failed to obtain repo owner, owner:", owner, ",path:", path, ",err: ", err)
			return "", err
		}
	}
	return "", errors.New("参数错误")
}

func GetBranchesInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	BrandVerSlice := make([]string, 0)
	if organizationID == 3 {
		mindsporeVersion := beego.AppConfig.String("mindspore::mindspore_version")
		if len(mindsporeVersion) > 0 {
			BrandVerSlice = strings.Split(mindsporeVersion, ",")
		}
	} else if organizationID == 2 {
		gaussVersion := beego.AppConfig.String("opengauss::gauss_version")
		if len(gaussVersion) > 0 {
			BrandVerSlice = strings.Split(gaussVersion, ",")
		}
		path = beego.AppConfig.String("opengauss::openGauss-server")
	} else {
		eulerVersion := beego.AppConfig.String("cve::affected_branchs")
		if len(eulerVersion) > 0 {
			BrandVerSlice = strings.Split(eulerVersion, ",")
		}
	}
	branchNameList := []string{}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/branches?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("branches, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					for _, gv := range BrandVerSlice {
						if gv == mapValue {
							branchNameList = append(branchNameList, mapValue)
						}
					}
				}
			}
		} else {
			logs.Error("Failed to get branch name, "+
				"err: ", err, ",owner: ", owner, ",path: ", path)
			return branchNameList, err
		}
	}
	return branchNameList, nil
}

func GetTagsInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	tagsList := []string{}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/tags?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("branches, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					tagsList = append(tagsList, mapValue)
				}
			}
		} else {
			logs.Error("Failed to get tags name, "+
				"err: ", err, ",owner: ", owner, ",path: ", path)
			return tagsList, err
		}
	}
	return tagsList, nil
}
