package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"github.com/astaxie/beego/logs"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"
)


func GetYamlTables(url string) (string, error) {
	compURL := url + "/lifeCycle/tables"
	body, err := util.HTTPGetCom(compURL)
	if err == nil && body != nil {
		var respBody map[string]interface{}
		err = json.Unmarshal(body, &respBody)
		if err != nil {
			logs.Error(err)
			return "", err
		}
		logs.Info(respBody)
		if respBody["code"].(string) == "2001" {
			for i, values := range respBody["data"].([]interface{}) {
				var gt models.GitPackageTable
				gt.TableName = values.(string)
				tableID, err := models.CreateYamlTable(&gt)
				if tableID > 0 {
					logs.Info("第 ", i, "条数据, table: ", values, "插入成功, table_id: ", tableID)
				} else {
					logs.Error("第 ", i, "条数据, table: ", values, "插入失败, err: ", err)
					return "", err
				}
			}
		} else {
			return "", errors.New("数据格式错误")
		}
	}
	return "", nil
}

var lock sync.Mutex

//GetYamlByGit
func GetYamlByGit(url string) (string, error) {
	defer common.Catchs()
	var gt []models.GitPackageTable
	page := 1
	size := 20
	num, err := models.GetYamlTable(&gt)
	if err != nil {
		logs.Error("查询表失败,无法获取yaml, err: ", err)
		return "", err
	}
	logs.Info("总共有: ", num, "表的数据需要获取, ", gt)
	compURL1 := url + "/packages"
	var ch = make(chan int, len(gt))
	for i, tableValue := range gt {
		logs.Info("查询第 ", i, "tableName: ", tableValue.TableName, "开始...")
		go func(tv models.GitPackageTable, idx int) {
			ok, err := GetYaml(url, compURL1, page, size, tv, &ch)
			if err == nil {
				logs.Info("当前数据处理成功,i: ", idx)
			} else {
				logs.Error("当前数据处理失败, ok: ", ok, ",i: ", idx, ", err: ", err)
			}
		}(tableValue, i)
	}
	for i := 0; i < len(gt); i++ {
		<-ch
	}
	close(ch)
	return "", nil
}

func GetYaml(url, compURL1 string, page, size int, tableValue models.GitPackageTable, ch *chan int) (string, error) {
	defer common.Catchs()
	var tc GitTablePackCount
	tc.TableName = tableValue.TableName
	tc.Page = 0
	tc.Size = 0
	tc.Page = page
	tc.Size = size
	compURL2 := compURL1 + "?table_name=" + tableValue.TableName
	for ; ; {
		compURL := compURL2 +
			"&page_num=" + strconv.Itoa(tc.Page) + "&page_size=" + strconv.Itoa(size)
		body, err := util.HTTPGetCom(compURL)
		var respBody map[string]interface{}
		if err == nil && body != nil {
			err = json.Unmarshal(body, &respBody)
			if err != nil {
				logs.Error(err)
				return "", err
			}
		} else {
			logs.Error("http 请求失败， url: ", compURL)
			return "", err
		}
		logs.Info("start: ", tc)
		if respBody["code"].(string) == "2001" {
			curCount := 0
			if respBody == nil || respBody["data"] == nil || len(respBody["data"].([]interface{})) == 0 {
				logs.Error("数据为空， url: ", compURL)
				return "", err
			}
			for i, values := range respBody["data"].([]interface{}) {
				tc.Count = tc.Count + 1
				logs.Info("第：", tc.Page, "页, 到： ", tc.Size, "条, tableName: ", tc.TableName,
					",已处理到第count： ", tc.Count, "条, yaml values: ", values)
				if values == nil || values == "" || len(values.(map[string]interface{})) == 0 {
					logs.Error("第：", tc.Page, "页, 到： ", tc.Size, "条, tableName: ", tc.TableName,
						",已处理到第count： ", tc.Count, "条, yaml values: ", values, ", 处理失败")
					curCount = curCount + 1
					continue
				}
				valuesX := values.(map[string]interface{})
				lock.Lock()
				ok, err := ProcPackDetail(url, valuesX, tableValue, i)
				lock.Unlock()
				logs.Info("ok: ", ok, ", err: ", err)
				curCount = curCount + 1
			}
			totalPage := 0
			switch respBody["total_page"].(type) {
			case string:
				totalPage, _ = strconv.Atoi(respBody["total_page"].(string))
			case int:
				totalPage = respBody["total_page"].(int)
			case int64:
				totalPage = int(respBody["total_page"].(int64))
			case float64:
				totalPage = int(int64(respBody["total_page"].(float64)))
			default:
				totalPage = 1
			}
			totalCount := 0
			switch respBody["total_count"].(type) {
			case string:
				totalCount, _ = strconv.Atoi(respBody["total_count"].(string))
			case int:
				totalCount = respBody["total_count"].(int)
			case int64:
				totalCount = int(respBody["total_count"].(int64))
			case float64:
				totalCount = int(int64(respBody["total_count"].(float64)))
			default:
				totalCount = 1
			}
			if tc.Page > totalPage || tc.Size >= totalCount {
				logs.Info("已处理完成：tableName: ", tc.TableName, "数据获取完成， "+
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compURL)
				break
			} else {
				logs.Info("当前： tableName: ", tc.TableName, "数据获取完成， "+
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compURL)
				lock.Lock()
				tc.Page = tc.Page + page
				tc.Size = tc.Size + curCount
				lock.Unlock()
				logs.Info("增加后： tableName: ", tc.TableName, "数据获取完成， "+
					"总页数(page_num)：", totalPage, ", 总条数(page_size)：", totalCount, "\n",
					",当前页数Page：", tc.Page, ",当前条数size: ", tc.Size, ",url: ", compURL)
			}
			logs.Info("start: ", tc)
		} else {
			logs.Error("网络请求失败，url:", compURL)
			continue
		}
	}
	*ch <- 1
	return "", nil
}

func ProcPackDetail(url string, value map[string]interface{}, tableValue models.GitPackageTable, i int) (string, error) {
	values := value
	var ge models.GitOpenEuler
	GitOpenEulerData(values, &ge, tableValue)
	// Query cpe data
	var pc models.PackageCpe
	pcError := models.GetCpePackName(&pc, ge.PackageName)
	if pcError == nil && pc.Id > 0 {
		ge.CpePackName = pc.CpePackName
	}
	logs.Info("正在处理的 packageName: ", ge.PackageName)
	ok, _ := models.GetSingleYaml(&ge)
	if ok {
		logs.Info("第 ", i, "条数据, PackageName: ", ge.PackageName, "已经存在,不需要再次插入")
		gpinfo, okinfo := models.QueryCveOpeneulerDetaildataByName(ge.PackageName, ge.Version)
		if !okinfo && gpinfo.DetailId == 0 {
			_, pierr := GetPackageInfo(url, tableValue, ge)
			if pierr != nil {
				logs.Error("获取包详情失败, url: ", url, ", PackageName: ", ge.PackageName, ",version: ", ge.Version, ",err: ", pierr)
				return ge.PackageName, pierr
			}
		}
		return ge.PackageName, nil
	}
	gitID, typeX, err := models.CreateYaml(&ge, tableValue)
	if gitID > 0 && err == nil {
		logs.Info("第 ", i, "条数据, PackageName: ", ge.PackageName, typeX, "成功, git_id: ", gitID)
	} else {
		logs.Error("第 ", i, "条数据, PackageName: ", ge.PackageName, typeX, "失败, err: ", err)
		if strings.ContainsAny(string(err.Error()), "Duplicate entry") {
			ok, _ := models.GetSingleYaml(&ge)
			if ok {
				logs.Info("第 ", i, "条数据, PackageName: ", ge.PackageName, "已经存在,不需要再次插入")
				gpinfo, okinfo := models.QueryCveOpeneulerDetaildataByName(ge.PackageName, ge.Version)
				if !okinfo && gpinfo.DetailId == 0 {
					_, pierr := GetPackageInfo(url, tableValue, ge)
					if pierr != nil {
						logs.Error("获取包详情失败, url: ", url, ", PackageName: ", ge.PackageName, ",version: ", ge.Version, ",err: ", pierr)
						return ge.PackageName, pierr
					}
				}
				return ge.PackageName, nil
			}
		}
		return "", err
	}
	if typeX == "insert" && gitID > 0 {
		_, pierr := GetPackageInfo(url, tableValue, ge)
		if pierr != nil {
			logs.Error("获取包详情失败, url: ", url, ", PackageName: ", ge.PackageName, ",version: ", ge.Version, ",err: ", pierr)
			return ge.PackageName, pierr
		}
	}
	return "", nil
}

func GetPackageInfo(urls string, tableValue models.GitPackageTable, ge models.GitOpenEuler) (string, error) {
	scpURL := urls + "/packages/packageInfo" + "?table_name=" + tableValue.TableName + "&pkg_name=" + ge.PackageName
	logs.Info("PackageName: ", ge.PackageName, "获取packageInfo， 请求参数: ", scpURL)
	var urlS url.URL
	q := urlS.Query()
	q.Add("table_name", tableValue.TableName)
	q.Add("pkg_name", ge.PackageName)
	params := q.Encode()
	req, _ := http.NewRequest("GET", urls, nil)
	req.URL = &url.URL{
		Scheme:   req.URL.Scheme,
		Host:     req.URL.Host,
		RawQuery: params,
		Path:     "/pkgmanage/packages/packageInfo",
	}

	req.URL.EscapedPath()
	body, err := util.HTTPGetCom(req.URL.String())
	var respBody map[string]interface{}
	if err == nil && body != nil {
		err = json.Unmarshal(body, &respBody)
		if err != nil {
			logs.Error(err)
			return "", err
		}
	} else {
		logs.Error("http 请求失败， scpURL: ", scpURL)
		return "", err
	}
	logs.Info(respBody)
	if respBody["code"].(string) == "2001" {
		if respBody["data"] == nil || respBody["data"] == "" {
			logs.Error("获取包详情失败, scpURL: ", scpURL)
			return "", errors.New("数据错误")
		}
		var gp models.GitPackageInfo
		GitOpenEulerInfoData(respBody["data"].(map[string]interface{}), &gp, ge)
		detailid, typex, err := models.CreateYamlDetail(&gp, ge)
		if detailid > 0 && typex == "insert" && err == nil {
			subdata := respBody["data"].(map[string]interface{})
			if subdata["subpack"] == nil {
				return "", err
			}
			if subdata == nil || subdata["subpack"] == nil || len(subdata["subpack"].([]interface{})) == 0 {
				return "", errors.New("数据错误")
			}
			subpack := subdata["subpack"].([]interface{})
			for _, packValuex := range subpack {
				logs.Info("yaml packValuex: ", packValuex)
				if packValuex == nil || packValuex == "" || len(packValuex.(map[string]interface{})) == 0 {
					continue
				}
				packValue := packValuex.(map[string]interface{})
				var gb models.GitSubPack
				gb.DetailId = gp.DetailId
				switch packValue["id"].(type) {
				case string:
					gb.Ids, _ = strconv.ParseInt(packValue["id"].(string), 10, 64)
				case int:
					gb.Ids = packValue["id"].(int64)
				case int64:
					gb.Ids = packValue["id"].(int64)
				case float64:
					gb.Ids = int64(packValue["id"].(float64))
				default:
					gb.Ids = 0
				}
				if packValue["name"] == nil {
					gb.SubPackName = ""
				} else {
					gb.SubPackName = packValue["name"].(string)
				}
				SubID, typex, err := models.CreateYamlSubPack(&gb)
				if SubID > 0 && typex == "insert" && err == nil {
					if packValue["provides"] != nil && len(packValue["provides"].([]interface{})) > 0 {
						provides := packValue["provides"].([]interface{})
						for _, provValuex := range provides {
							logs.Info("yaml provValuex: ", provValuex)
							if provValuex == nil || provValuex == "" || len(provValuex.(map[string]interface{})) == 0 {
								continue
							}
							provValue := provValuex.(map[string]interface{})
							var gs models.GitSubPackProvides
							gs.SubId = SubID
							switch provValue["id"].(type) {
							case string:
								gs.Ids, _ = strconv.ParseInt(provValue["id"].(string), 10, 64)
							case int:
								gs.Ids = provValue["id"].(int64)
							case int64:
								gs.Ids = provValue["id"].(int64)
							case float64:
								gs.Ids = int64(provValue["id"].(float64))
							default:
								gs.Ids = 0
							}
							if provValue["name"] == nil {
								gs.ProvideName = ""
							} else {
								gs.ProvideName = provValue["name"].(string)
							}
							gs.Requiredby = ""
							ProvideID, typexx, err := models.CreateYamlSubPackProvides(&gs)
							if ProvideID > 0 && typexx == "insert" && err == nil {
								if provValue["requiredby"] != nil && len(provValue["requiredby"].([]interface{})) > 0 {
									requiredby := provValue["requiredby"].([]interface{})
									for _, reqValue := range requiredby {
										if reqValue != nil && reqValue.(string) != "" {
											var gr models.GitSubPackRequiredby
											gr.ProvideId = gs.ProvideId
											gr.Requiredby = reqValue.(string)
											ID, typexy, err := models.CreateYamlSubPackRequiredb(&gr)
											logs.Info("CreateYamlSubPackRequiredb", ID, typexy, err)
										}
									}
								}
							}
						}
					}
					if packValue["requires"] != nil && len(packValue["requires"].([]interface{})) > 0 {
						requires := packValue["requires"].([]interface{})
						for _, reqValuexx := range requires {
							logs.Info("reqValuexx: ", reqValuexx)
							if reqValuexx == nil || reqValuexx == "" || len(reqValuexx.(map[string]interface{})) == 0 {
								continue
							}
							reqValuex := reqValuexx.(map[string]interface{})
							reqStr := ""
							if reqValuex["providedby"] != nil && len(reqValuex["providedby"].([]interface{})) > 0 {
								providedby := reqValuex["providedby"].([]interface{})
								for _, reqValue := range providedby {
									if reqValue != nil && reqValue.(string) != "" {
										reqStr = reqStr + reqValue.(string) + ","
									}
								}
							}
							if reqStr != "" {
								reqStr = reqStr[:len(reqStr)-1]
							}
							var gs models.GitSubPackRequire
							gs.SubId = SubID
							switch reqValuex["id"].(type) {
							case string:
								gs.Ids, _ = strconv.ParseInt(reqValuex["id"].(string), 10, 64)
							case int:
								gs.Ids = reqValuex["id"].(int64)
							case int64:
								gs.Ids = reqValuex["id"].(int64)
							case float64:
								gs.Ids = int64(reqValuex["id"].(float64))
							default:
								gs.Ids = 0
							}
							if reqValuex["name"] == nil {
								gs.RequireName = ""
							} else {
								gs.RequireName = reqValuex["name"].(string)
							}
							gs.Providedby = reqStr
							RequireID, typexx, err := models.CreateYamlSubPackRequires(&gs)
							logs.Info("CreateYamlSubPackRequires", RequireID, typexx, err)
						}
					}
				}
			}
		}
	}
	return "", nil
}
