package task

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

var mutex sync.Mutex

//GetGiteeToken Get Code Cloud API TOKEN
func GetGiteeToken() error {
	defer common.Catchs()
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("GetGiteeToken, config init error:", err)
		return err
	}
	clientID := BConfig.String("gitee::client_id")
	if clientID == "" {
		logs.Error("GetGiteeToken, config gitee::clientID ,error: invalid value")
		return errors.New("value is nil")
	}
	clientSecret := beego.AppConfig.String("gitee::client_secret")
	if clientSecret == "" {
		logs.Error("GetGiteeToken, config gitee::clientSecret, error: invalid value")
		return errors.New("value is nil")
	}
	Email := BConfig.String("gitee::email")
	if Email == "" {
		logs.Error("GetGiteeToken, config gitee::email, error: value is nil")
		return errors.New("value is nil")
	}
	password := BConfig.String("gitee::password")
	if password == "" {
		logs.Error("GetGiteeToken, config gitee::password, error: value is nil")
		return errors.New("value is nil")
	}
	Scope := BConfig.String("gitee::scope")
	if Scope == "" {
		logs.Error("GetGiteeToken, config gitee::scope, error: value is nil")
		return errors.New("value is nil")
	}
	logs.Info(clientID, clientSecret, password)
	var gt taskhandler.GiteeToken
	gt.GrantType = "password"
	gt.UserName = Email
	gt.Password = password
	gt.ClientID = clientID
	gt.ClientSecret = clientSecret
	gt.Scope = Scope
	taskhandler.GetOautToken(gt)
	return nil
}

// Assemble issue record data
func GenIssueRecordData(icr *models.IssueCreateRecord, issueValue models.VulnCenter, sc models.Score, status int8) {
	icr.CveId = issueValue.CveId
	icr.CveNum = issueValue.CveNum
	icr.Description = issueValue.Description
	icr.CveLevel = issueValue.CveLevel
	icr.Status = status
	icr.CveVersion = issueValue.CveVersion
	icr.RepairTime = issueValue.RepairTime
	icr.PackName = issueValue.PackName
	icr.NVDScore = sc.NVDScore
	icr.NvectorVule = sc.NvectorVule
	icr.CreateTime = common.GetCurTime()
}

func ErrorCveStatistics(errDesc string, issueValue models.VulnCenter, status int8) {
	if issueValue.OrganizationID != 2 {
		sc, err := models.QueryIssueScore(issueValue.CveId)
		if err != nil || sc.Id == 0 {
			logs.Error("ErrorCveStatistics, Failed to get Score, err: ", err, ", cveId: ", issueValue.CveId)
			return
		}
		icr := models.IssueCreateRecord{ErrorDescription: errDesc}
		GenIssueRecordData(&icr, issueValue, sc, status)
		issueRecordId, issReErr := models.CreateIssueRecord(&icr)
		if issReErr == nil && issueRecordId > 0 {
			logs.Info("Issue record data created successfully, id:", issueRecordId)
		} else {
			logs.Error("ErrorCveStatistics, Failed to create issue record data, err: ", issReErr)
		}
	}
}

func addUnlimitedIssue(beforeTime string, prcnum int, years, toolYears, manYears int) error {
	accessToken := os.Getenv("GITEE_TOKEN")
	if accessToken == "" || len(accessToken) < 1 {
		logs.Error("addUnlimitedIssue, issue token Get failed, current time: ", common.GetCurTime())
		return errors.New("Failed to get token in environment variable")
	}
	owner := beego.AppConfig.String("gitee::owner")
	gaussOwner := beego.AppConfig.String("opengauss::gauss_owner")
	gitGaussToken := beego.AppConfig.String("opengauss::git_gauss_token")
	for ; ; {
		cveData, err := models.QueryIssue(beforeTime, prcnum)
		if err == nil && len(cveData) > 0 {
			logs.Info(cveData)
			ss := rand.Int31n(10)
			time.Sleep(time.Second * time.Duration(ss))
		} else {
			logs.Info("addUnlimitedIssue, No cve data can be used, current time: ", common.GetCurTime(), ", err: ", err)
			return err
		}
		for index, issueValue := range cveData {
			logs.Info("addUnlimitedIssue, Currently processing：", index, ",cve data, cveNum: ", issueValue.CveNum)
			// add mutex
			lockErr := models.LockUpdateIssueStatus(issueValue.CveId, issueValue.CveNum, 15)
			if !lockErr {
				logs.Error("addUnlimitedIssue, The current cve is processing, continue to process the next data, "+
					"err: ", lockErr, ",data: ", issueValue)
				continue
			}
			se := models.SpecError{CveNum: issueValue.CveNum, Owner: owner, PackName: issueValue.PackName, Status: 1}
			seError := models.GetIssueSpecErrByColName(&se, "CveNum", "Owner", "PackName", "Status")
			if seError == nil && se.Id > 0 {
				models.UpdateIssueStatus(issueValue, 5)
				logs.Info("addUnlimitedIssue, The current issue does not need to be processed, "+
					"it has been processed, cveData: ", issueValue)
				ErrorCveStatistics("CVE已经归档无需处理", issueValue, 1)
				continue
			}
			if issueValue.OrganizationID == 1 {
				// Determine whether the issue has been processed
				goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
				if oks {
					if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
						goi.State == "已完成" || goi.State == "已拒绝" || goi.IssueState == "已挂起" {
						models.UpdateIssueStatus(issueValue, 2)
						logs.Info("addUnlimitedIssue, The cve data has already been submitted to the issue, "+
							"no need to submit repeatedly, cveData: ", issueValue)
						ErrorCveStatistics("CVE已创建过issue, 且已归档", issueValue, 1)
						continue
					}
				}
			}
			// Import cve as data after 2018
			cveNumList := strings.Split(issueValue.CveNum, "-")
			if cveNumList != nil && len(cveNumList) > 1 {
				cveYears, yearErr := strconv.Atoi(cveNumList[1])
				if yearErr == nil {
					if issueValue.DataSource == 1 {
						years = toolYears
					} else if issueValue.DataSource == 3 {
						years = manYears
					}
					if cveYears <= years {
						models.UpdateIssueStatus(issueValue, 4)
						logs.Info("addUnlimitedIssue, cve: ", issueValue.CveNum, ",Need to be greater than： ",
							years, ",Otherwise, there is no need to submit an issue on git, cveData: ", issueValue)
						if issueValue.OrganizationID != 2 {
							ErrorCveStatistics("CVE年限受限", issueValue, 2)
						}
						continue
					}
				}
			}
			if issueValue.OrganizationID == 1 {
				// Determine whether cve has been processed
				issueExist, _ := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
				if issueExist {
					models.UpdateIssueStatus(issueValue, 2)
					logs.Info("addUnlimitedIssue, The cve data has been displayed on the official website, "+
						"no need to submit an issue on git, cveData: ", issueValue)
					ErrorCveStatistics("CVE已经在官网展示, 已修复", issueValue, 1)
					continue
				}
			}
			// Process each piece of cve data
			if issueValue.Status == 0 {
				issueValue.Status = 2
				mutex.Lock()
				err := ProcIssue(issueValue, accessToken, owner, gaussOwner, gitGaussToken)
				mutex.Unlock()
				if err != nil {
					logs.Error("addUnlimitedIssue, Failed to create issue, cvenum: ",
						issueValue.CveNum, "err,err: ", err)
					errDesc := fmt.Sprintf("%v", err)
					if issueValue.OrganizationID != 2 {
						ErrorCveStatistics(errDesc, issueValue, 2)
					}
					continue
				}
			} else {
				issueValue.Status = 2
				mutex.Lock()
				err := ProcUpdateIssue(issueValue, accessToken, owner)
				mutex.Unlock()
				if err != nil {
					logs.Error("addUnlimitedIssue, Failed to update issue, cvenum: ",
						issueValue.CveNum, "err,err: ", err)
					errDesc := fmt.Sprintf("%v", err)
					if issueValue.OrganizationID != 2 {
						ErrorCveStatistics(errDesc, issueValue, 2)
					}
					continue
				}
			}
			// Collect issue record data
			if issueValue.OrganizationID != 2 {
				ErrorCveStatistics("success", issueValue, 1)
			}
		}
	}
}

func addLimitedIssue(beforeTime string, prcnum int, years, toolYears, manYears int) error {
	accessToken := os.Getenv("GITEE_TOKEN")
	if accessToken == "" || len(accessToken) < 1 {
		logs.Error("addLimitedIssue, Issue token acquisition failed, "+
			"current time: ", common.GetCurTime())
		return errors.New("Failed to get token in environment variable")
	}
	owner := beego.AppConfig.String("gitee::owner")
	gaussOwner := beego.AppConfig.String("opengauss::gauss_owner")
	gitGaussToken := beego.AppConfig.String("opengauss::git_gauss_token")
	issueWhiteData, issueErr := models.QueryIssueWhitelist(0)
	if issueErr == nil && len(issueWhiteData) > 0 {
		for _, issues := range issueWhiteData {
			if issues.Status == 2 {
				logs.Error("addLimitedIssue, Removed from whitelist, repo: ", issues.PackageName)
				continue
			}
			for ; ; {
				cveData, err := models.QueryIssueByPackName(issues.PackageName, beforeTime, prcnum)
				if err == nil && len(cveData) > 0 {
					logs.Info(cveData)
					ss := rand.Int31n(10)
					time.Sleep(time.Second * time.Duration(ss))
				} else {
					logs.Info("addLimitedIssue, No cve data can be used, "+
						"current time: ", common.GetCurTime(), ", err: ", err)
					break
				}
				for index, issueValue := range cveData {
					logs.Info("addLimitedIssue, Currently processing section: ", index,
						", Cve data, cveNum: ", issueValue.CveNum)
					// add mutex
					lockErr := models.LockUpdateIssueStatus(issueValue.CveId, issueValue.CveNum, 15)
					if !lockErr {
						logs.Error("addLimitedIssue, The current cve is processing, continue to"+
							" process the next data, err: ", lockErr, ",data: ", issueValue)
						continue
					}
					se := models.SpecError{CveNum: issueValue.CveNum, Owner: owner,
						PackName: issueValue.PackName, Status: 1}
					seError := models.GetIssueSpecErrByColName(&se, "CveNum", "Owner", "PackName", "Status")
					if seError == nil && se.Id > 0 {
						models.UpdateIssueStatus(issueValue, 5)
						logs.Info("addLimitedIssue, The current issue does not need to be processed,"+
							" it has been processed, cveData: ", issueValue)
						ErrorCveStatistics("CVE已经归档无需处理", issueValue, 1)
						continue
					}
					// Determine whether the issue has been processed
					goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
					if oks {
						if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
							goi.State == "已完成" || goi.State == "已拒绝" || goi.IssueState == "已挂起" {
							models.UpdateIssueStatus(issueValue, 2)
							logs.Info("addLimitedIssue, The cve data has already been submitted to the issue, "+
								"no need to submit repeatedly, cveData: ", issueValue)
							ErrorCveStatistics("CVE已创建过issue, 且已归档", issueValue, 1)
							continue
						}
					}
					// Import cve as data after 2018
					cveNumList := strings.Split(issueValue.CveNum, "-")
					if cveNumList != nil && len(cveNumList) > 1 {
						cveYears, yearErr := strconv.Atoi(cveNumList[1])
						if yearErr == nil {
							if issueValue.DataSource == 1 {
								years = toolYears
							} else if issueValue.DataSource == 3 {
								years = manYears
							}
							if cveYears <= years {
								models.UpdateIssueStatus(issueValue, 4)
								logs.Info("addLimitedIssue, cve: ", issueValue.CveNum, ",Need to be greater than: ",
									years, ", Otherwise there is no need to submit an issue on git, cveData: ", issueValue)
								if issueValue.OrganizationID != 2 {
									ErrorCveStatistics("CVE年限受限", issueValue, 2)
								}
								continue
							}
						}
					}
					// Determine whether cve has been processed
					issueExist, _ := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
					if issueExist {
						models.UpdateIssueStatus(issueValue, 2)
						logs.Info("addLimitedIssue, The cve data has been displayed on the official website, "+
							"no need to submit an issue on git, cveData: ", issueValue)
						ErrorCveStatistics("CVE已经在官网展示, 已修复", issueValue, 1)
						continue
					}
					// Process each piece of cve data
					if issueValue.Status == 0 {
						mutex.Lock()
						err := ProcIssue(issueValue, accessToken, owner, gaussOwner, gitGaussToken)
						mutex.Unlock()
						if err != nil {
							logs.Error("addLimitedIssue, Failed to create issue, cvenum: ",
								issueValue.CveNum, ",err: ", err)
							errDesc := fmt.Sprintf("%v", err)
							ErrorCveStatistics(errDesc, issueValue, 2)
							continue
						}
					} else {
						mutex.Lock()
						err := ProcUpdateIssue(issueValue, accessToken, owner)
						mutex.Unlock()
						if err != nil {
							logs.Error("addLimitedIssue, Failed to modify the issue, cvenum: ",
								issueValue.CveNum, "err,err: ", err)
							errDesc := fmt.Sprintf("%v", err)
							ErrorCveStatistics(errDesc, issueValue, 2)
							continue
						}
					}
					// Collect issue record data
					if issueValue.OrganizationID != 2 {
						ErrorCveStatistics("success", issueValue, 1)
					}
				}
			}
		}
	} else {
		logs.Error(issueErr)
		return issueErr
	}
	return nil
}

//CreateIssue Create issue
func CreateIssue() error {
	defer common.Catchs()
	logs.Info("The issue task of creating cve begins. . .")
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("CreateIssue, config init, error:", err)
		return err
	}
	days, ok := BConfig.Int("crontab::days")
	if ok != nil {
		logs.Error("CreateIssue, config crontab::days, error:", ok)
		return ok
	}
	years, ok := BConfig.Int("cve::cve_number")
	if ok != nil {
		logs.Error("CreateIssue, config cve::years, error:", ok)
		return ok
	}
	manYears, ok := BConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("CreateIssue, config cve::manYears, error:", ok)
		return ok
	}
	toolYears, ok := BConfig.Int("cve::cve_number_t")
	if ok != nil {
		logs.Error("CreateIssue, config cve::toolYears, error:", ok)
		return ok
	}
	prcnum, ok := BConfig.Int("crontab::prcnum")
	if ok != nil {
		logs.Error("CreateIssue, config crontab::prcnum, error:", ok)
		return ok
	}
	issueWhitelist, ok := BConfig.Int("cve::issue_whitelist")
	if ok != nil {
		logs.Error("CreateIssue, config cve::issue_whitelist, error: ", ok)
		return ok
	}
	beforeTime := common.GetBeforeTime(days)
	if issueWhitelist == 1 {
		limitErr := addLimitedIssue(beforeTime, prcnum, years, toolYears, manYears)
		logs.Info("CreateIssue, addLimitedIssue, err: ", limitErr)
		logs.Info("The execution of the issue task of creating cve ends. . .")
		return limitErr
	} else {
		unlimitErr := addUnlimitedIssue(beforeTime, prcnum, years, toolYears, manYears)
		logs.Info("CreateIssue, addUnlimitedIssue, err: ", unlimitErr)
		logs.Info("The execution of the issue task of creating cve ends. . .")
		return unlimitErr
	}
}

//ProcUpdateIssue Update issue
func ProcUpdateIssue(issueValue models.VulnCenter, accessToken, owner string) error {
	path := issueValue.PackName
	// Query and modify score
	sr, err := models.QueryIssueScoreRecord(issueValue.CveId, 0)
	if err != nil {
		logs.Error("ProcUpdateIssue, Failed to query score records, cveId: ",
			issueValue.CveId, ", err: ", err)
		sc, err := models.QueryIssueScore(issueValue.CveId)
		if err != nil {
			logs.Error("ProcUpdateIssue, Failed to get Score, err: ",
				err, ", cveId: ", issueValue.CveId)
			return errors.New("NVD评分缺失")
		}
		sr.NVDScore = sc.NVDScore
		sr.NvectorVule = sc.NvectorVule
	}
	// Query issue template
	var it models.IssueTemplate
	it.CveNum = issueValue.CveNum
	it.OwnedVersion = issueValue.CveVersion
	it.OwnedComponent = issueValue.PackName
	it.CveId = issueValue.CveId
	templateErr := models.GetIssueTemplateByColName(&it, "CveNum", "OwnedVersion", "OwnedComponent", "CveId")
	if templateErr == nil && it.TemplateId > 0 {
		it.NVDScore = sr.NVDScore
		it.NVDVector = sr.NvectorVule
		it.CveBrief = issueValue.Description
		it.CveLevel = issueValue.CveLevel
		if (it.Assignee == "" || len(it.Assignee) < 2) && issueValue.OrganizationID != 2 {
			repoMainTainer, ok := models.QueryRepoMaintainer(issueValue.PackName)
			if !ok || repoMainTainer == "" || len(repoMainTainer) < 1 {
				assignee, assErr := taskhandler.GetCollaboratorInfo(accessToken, owner, path)
				if assignee != "" && len(assignee) > 1 {
					it.Assignee = assignee
					//return err
				} else {
					logs.Error("ProcUpdateIssue, Get the repo: owner:", owner,
						", path:", path, ", Analyst failed, ", "assErr:", assErr,
						", cveid: ", issueValue.CveId, ", Create an issue without a maintainer")
				}
			} else {
				it.Assignee = repoMainTainer
			}
		}
		// Judgment of necessary fields
		if it.NVDScore <= 0 || len(issueValue.Description) < 2 || len(issueValue.CveNum) < 2 ||
			len(issueValue.PackName) < 2 || len(issueValue.CveVersion) < 1 {
			logs.Error("ProcUpdateIssue, Field is empty: NVDScore: ", it.NVDScore, ",Description: ",
				issueValue.Description, ",CveNum:", issueValue.CveNum, ",PackName: ",
				issueValue.PackName, ",CveVersion: ", issueValue.CveVersion)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 6)
			return errors.New("CVE的描述和NVD信息缺失")
		}
		_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path,
			issueValue, it)
		if err != nil && err.Error() != "Recreate issue" {
			logs.Error("ProcUpdateIssue, Failed to update issue template, "+
				"cveId: ", issueValue.CveId, "err: ", err)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 3)
			return err
		}
		// Update issue status
		models.UpdateIssueStatus(issueValue, 2)
		// Update score status
		models.UpdateIssueScore(issueValue, 2)
		templetID, err := models.CreateIssueTemplate(&it)
		if err != nil {
			logs.Error("ProcUpdateIssue, Failed to modify issue template, "+
				"cveId: ", issueValue.CveId, ",err: ", err)
			//return err
		}
		models.UpdateIssueScoreRe(issueValue, 1)
		logs.Info("ProcUpdateIssue, Successfully updated the issue template, "+
			"cveId: ", issueValue.CveId, ", templetID: ", templetID)
	}
	return nil
}

//ProcIssue Deal with issue
func ProcIssue(issueValue models.VulnCenter,
	accessToken, owner, gaussOwner, gitGaussToken string) error {
	assignee := ""
	path := issueValue.PackName
	brandArry := []string{}
	if issueValue.OrganizationID != 2 {
		sn, err := models.QueryIssueSecurity(issueValue.CveId, issueValue.CveNum)
		if err == nil && len(sn.CveNum) > 0 {
			logs.Info("ProcIssue, QueryIssueSecurity, Query safety information: ", sn)
			// Get issue handler
			repoMainTainer, ok := models.QueryRepoMaintainer(issueValue.PackName)
			if !ok || repoMainTainer == "" || len(repoMainTainer) < 1 {
				assignee, err = taskhandler.GetCollaboratorInfo(accessToken, owner, path)
				if assignee == "" {
					logs.Error("ProcIssue, Get the repo： owner:", owner, ",path:", path, ",Analyst failed",
						", cveid: ", issueValue.CveId, ",Create an issue without a maintainer", ", err:", err)
				}
			} else {
				assignee = repoMainTainer
			}
		} else {
			logs.Error("ProcIssue, Failed to obtain security", ", cveId: ", issueValue.CveId, ", err: ", err)
			return errors.New("CVE描述缺失")
		}
		sc, err := models.QueryIssueScore(issueValue.CveId)
		if err != nil {
			logs.Error("ProcIssue, Failed to get Score, err: ", err, ", cveId: ", issueValue.CveId)
			return errors.New("NVD评分缺失")
		}
		branchList := []string{}
		errBrands := errors.New("")
		// Get branch information
		branchList, errBrands = taskhandler.GetBranchesInfo(accessToken, owner, path)
		if branchList == nil || len(branchList) == 0 {
			logs.Error("ProcIssue, Failed to obtain branch information,CveNum: ", issueValue.CveNum,
				", path: ", path, ", err: ", errBrands)
		}
		if len(branchList) > 0 {
			brandArry = []string{}
			for _, branch := range branchList {
				brandArry = append(brandArry, branch)
			}
		}
		legalFlag := false
		if issueValue.DataSource == 4 {
			if len(issueValue.CveNum) < 2 || len(issueValue.PackName) < 2 || len(issueValue.CveVersion) < 1 {
				legalFlag = true
			}
		} else if issueValue.DataSource == 3 {
			if len(issueValue.Description) < 2 || len(issueValue.CveNum) < 2 ||
				len(issueValue.PackName) < 2 || len(issueValue.CveVersion) < 1 {
				legalFlag = true
			}
		} else {
			if sc.NVDScore <= 0 || len(issueValue.Description) < 2 || len(issueValue.CveNum) < 2 ||
				len(issueValue.PackName) < 2 || len(issueValue.CveVersion) < 1 {
				legalFlag = true
			}
		}
		// Judgment of necessary fields
		if legalFlag {
			logs.Error("ProcIssue, Field is empty: NVDScore: ", sc.NVDScore, ",Description: ",
				issueValue.Description, ",CveNum:", issueValue.CveNum, ",PackName: ",
				issueValue.PackName, ",CveVersion: ", issueValue.CveVersion)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 6)
			return errors.New("CVE的描述和NVD信息缺失")
		}
		resp, err := taskhandler.CreateIssueToGit(accessToken, owner, path, assignee, issueValue, sc, brandArry)
		if err != nil && err.Error() != "Recreate issue" {
			logs.Error("ProcIssue, Failed to create issue, err: ", err, ",resp: ", resp, ",cveId: ", issueValue.CveId)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 3)
			return err
		}
	} else {
		sc, err := models.QueryIssueScore(issueValue.CveId)
		if err != nil {
			logs.Error("ProcIssue, Failed to get Score, err: ", err, ", cveId: ", issueValue.CveId)
			return err
		}
		// Judgment of necessary fields
		if sc.NVDScore <= 0 || len(issueValue.Description) < 2 || len(issueValue.CveNum) < 2 ||
			len(issueValue.PackName) < 2 || len(issueValue.CveVersion) < 1 {
			logs.Error("ProcIssue, Field is empty: NVDScore: ", sc.NVDScore, ",Description: ",
				issueValue.Description, ",CveNum:", issueValue.CveNum, ",PackName: ",
				issueValue.PackName, ",CveVersion: ", issueValue.CveVersion)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 6)
			return errors.New("Field is empty")
		}
		path = "security"
		resp, err := taskhandler.CreateIssueToGit(gitGaussToken, gaussOwner, path, assignee, issueValue, sc, brandArry)
		if err != nil && err.Error() != "Recreate issue" {
			logs.Error("ProcIssue, Failed to create issue, err: ", err,
				",resp: ", resp, ",cveId: ", issueValue.CveId)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 3)
			return err
		}
	}
	return nil
}
