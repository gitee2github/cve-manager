package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

var GetCveDetailUrl = "https://openeuler.org/api-cve/cve-security-notice-server/cvedatabase/getByCveId?cveId=%s"

var (
	pkgLock sync.Mutex
	lockx   sync.Mutex
	dbLock  sync.Mutex
)
var ewg sync.WaitGroup

func UpdateExcelCveGroups(cveData models.OriginExcel,
	cveRef string, openeulerNum int, CveRes models.VulnCenter,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveData.CveDesc
	CveRes.CveVersion = cveData.CveVersion
	CveRes.RepairTime = cveData.RepairTime
	CveRes.PackName = cveData.PackName
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveData.CveLevel
	CveRes.OrganizationID = organizationID
	if CveRes.DataSource == 1 {
		CveRes.DataSource = 3
	}
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	if (CveRes.DataSource == 4 || CveRes.DataSource == 3) &&
		CveRes.Status != 0 && CveRes.Status != 1 {
		issueTmp := models.IssueTemplate{CveId: CveRes.CveId,
			OwnedComponent: CveRes.PackName, OwnedVersion: CveRes.CveVersion}
		err := models.GetIssueTemplateByColName(&issueTmp, "CveId", "OwnedComponent", "OwnedVersion")
		if err != nil {
			if CveRes.DataSource == 3 {
				CveRes.Status = 0
				CveRes.IsExport = 0
			}
			logs.Error(err)
		} else {
			if issueTmp.Status < 3 {
				CveRes.Status = 1
				CveRes.IsExport = 0
			}
		}
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("UpdateExcelCveGroups, Failed to update openEulerSa data table, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		if scoreRes.NVDScore != cveData.NVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = cveData.NVDScore
			scorecode.NvectorVule = cveData.NVDVector
			scorecode.Status = 0
			scorecode.CveId = CveRes.CveId
			scoreid, err := models.CreateScoreRecord(&scorecode)
			if scoreid > 0 && err == nil {
				logs.Info("insert score_record success, id:", scoreid)
			} else {
				return false, errors.New("评分记录数据错误，暂时不处理")
			}
		}
		scoreRes.NVDScore = cveData.NVDScore
		scoreRes.NvectorVule = cveData.NVDVector
		scoreRes.OpenId = OpenEulId
		scoreRes.Nstatus = 1
		if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
			scoreRes.NaccessVector = cveData.AccessVector
			scoreRes.NaccessComplexity = cveData.AccessComplexity
			scoreRes.Nauthentication = cveData.Authentication
			scoreRes.ScoreType = "v2"
		} else {
			scoreRes.NattackVector = cveData.AttackVector
			scoreRes.NattackComplexity = cveData.AttackComplexity
			scoreRes.NprivilegeRequired = cveData.PrivilegeRequired
			scoreRes.NuserInteraction = cveData.UserInteraction
			scoreRes.Nscope = cveData.Scope
			scoreRes.ScoreType = "v3"
		}
		scoreRes.Nconfidentiality = cveData.Confidentiality
		scoreRes.Nintegrity = cveData.Integrity
		scoreRes.Navailability = cveData.Availability
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.NVDScore = cveData.NVDScore
		sc.OpenEulerScore = cveData.NVDScore
		sc.OpenId = OpenEulId
		sc.NvectorVule = cveData.NVDVector
		sc.OvectorVule = cveData.NVDVector
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		if strings.ToLower(cveData.ScoreType) == "v2" ||
			strings.ToLower(cveData.ScoreType) == "v2.0" {
			sc.NaccessVector = cveData.AccessVector
			sc.OaccessVector = cveData.AccessVector
			sc.NaccessComplexity = cveData.AccessComplexity
			sc.OaccessComplexity = cveData.AccessComplexity
			sc.Nauthentication = cveData.Authentication
			sc.Oauthentication = cveData.Authentication
			sc.ScoreType = "v2"
		} else {
			sc.NattackVector = cveData.AttackVector
			sc.OattackVector = cveData.AttackVector
			sc.NattackComplexity = cveData.AttackComplexity
			sc.OattackComplexity = cveData.AttackComplexity
			sc.NprivilegeRequired = cveData.PrivilegeRequired
			sc.OprivilegeRequired = cveData.PrivilegeRequired
			sc.OuserInteraction = cveData.UserInteraction
			sc.NuserInteraction = cveData.UserInteraction
			sc.Oscope = cveData.Scope
			sc.Nscope = cveData.Scope
			sc.ScoreType = "v3"
		}
		sc.Nconfidentiality = cveData.Confidentiality
		sc.Oconfidentiality = cveData.Confidentiality
		sc.Nintegrity = cveData.Integrity
		sc.Ointegrity = cveData.Integrity
		sc.Navailability = cveData.Availability
		sc.Oavailability = cveData.Availability
		scid, scErr := models.CreateScore(&sc)
		if scErr != nil {
			logs.Error("UpdateExcelCveGroups, insert cve_score failed cveScV3: ", sc, ",scerr: ", scErr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = cveData.PackName
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = cveData.PackName + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = cveData.PackName
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = cveData.PackName + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat, update failed, CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat1, update failed,  CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveExcelGroups(cveData models.OriginExcel, cveRef string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveData.CveDesc
	vul.Status = 0
	vul.CveVersion = cveData.CveVersion
	vul.RepairTime = cveData.RepairTime
	vul.PackName = cveData.PackName
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveData.CveLevel
	vul.DataSource = 3
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = cveData.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.PackName + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" +
			"Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.NVDScore = cveData.NVDScore
	sc.OpenEulerScore = cveData.NVDScore
	sc.NvectorVule = cveData.NVDVector
	sc.OvectorVule = cveData.NVDVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	if strings.ToLower(cveData.ScoreType) == "v2" ||
		strings.ToLower(cveData.ScoreType) == "v2.0" {
		sc.NaccessVector = cveData.AccessVector
		sc.OaccessVector = cveData.AccessVector
		sc.NaccessComplexity = cveData.AccessComplexity
		sc.OaccessComplexity = cveData.AccessComplexity
		sc.Nauthentication = cveData.Authentication
		sc.Oauthentication = cveData.Authentication
		sc.ScoreType = "v2"
	} else {
		sc.NattackVector = cveData.AttackVector
		sc.OattackVector = cveData.AttackVector
		sc.NattackComplexity = cveData.AttackComplexity
		sc.OattackComplexity = cveData.AttackComplexity
		sc.NprivilegeRequired = cveData.PrivilegeRequired
		sc.OprivilegeRequired = cveData.PrivilegeRequired
		sc.OuserInteraction = cveData.UserInteraction
		sc.NuserInteraction = cveData.UserInteraction
		sc.Oscope = cveData.Scope
		sc.Nscope = cveData.Scope
		sc.ScoreType = "v3"
	}
	sc.Nconfidentiality = cveData.Confidentiality
	sc.Oconfidentiality = cveData.Confidentiality
	sc.Nintegrity = cveData.Integrity
	sc.Ointegrity = cveData.Integrity
	sc.Navailability = cveData.Availability
	sc.Oavailability = cveData.Availability

	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveData.NVDScore
	scorecode.NvectorVule = cveData.NVDVector
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("InsertCveExcelGroups, CreateCveRelat, "+
			"insert failed, CveNum:", cveData.CveNum, ", cveerr: ", cveerr)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	return true, nil
}

func UpdateCveGroups(cveData models.OriginUpstream, cveRef string, openeulerNum int, CveRes models.VulnCenter,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2, pkList []string, organizationID int8) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveDesc.EnDescription
	CveRes.CveVersion = pkList[1]
	CveRes.RepairTime = cveData.PublishedDate
	CveRes.PackName = pkList[0]
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveScV3.CveLevel
	CveRes.OrganizationID = organizationID
	//CveRes.DataSource = 1
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("InsertCveExcelGroups, CreateOpenEulerSA, Update failed, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		scoreRes.ScoreType = scopeType
		vectorString := ""
		if scopeType == "v3" {
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV3.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV3.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.CreateScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV3.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NattackVector = cveScV3.AttackVector
			scoreRes.NattackComplexity = cveScV3.AttackComplexity
			scoreRes.NprivilegeRequired = cveScV3.PrivilegesRequired
			scoreRes.NuserInteraction = cveScV3.UserInteraction
			scoreRes.Nscope = cveScV3.Scope
			scoreRes.Nconfidentiality = cveScV3.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV3.IntegrityImpact
			scoreRes.Navailability = cveScV3.AvailabilityImpact
		} else {
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV2.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV2.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.CreateScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV2.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NaccessVector = cveScV2.AccessVector
			scoreRes.NaccessComplexity = cveScV2.AccessComplexity
			scoreRes.Nconfidentiality = cveScV2.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV2.IntegrityImpact
			scoreRes.Navailability = cveScV2.AvailabilityImpact
			scoreRes.Nauthentication = cveScV2.Authentication
		}
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.OpenId = OpenEulId
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		sc.ScoreType = scopeType
		if scopeType == "v3" {
			sc.NVDScore = cveScV3.BaseScore
			sc.OpenEulerScore = cveScV3.BaseScore
			vectorString := ""
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NattackVector = cveScV3.AttackVector
			sc.OattackVector = cveScV3.AttackVector
			sc.NattackComplexity = cveScV3.AttackComplexity
			sc.OattackComplexity = cveScV3.AttackComplexity
			sc.NprivilegeRequired = cveScV3.PrivilegesRequired
			sc.OprivilegeRequired = cveScV3.PrivilegesRequired
			sc.NuserInteraction = cveScV3.UserInteraction
			sc.OuserInteraction = cveScV3.UserInteraction
			sc.Nscope = cveScV3.Scope
			sc.Oscope = cveScV3.Scope
			sc.Nconfidentiality = cveScV3.ConfidentialityImpact
			sc.Oconfidentiality = cveScV3.ConfidentialityImpact
			sc.Nintegrity = cveScV3.IntegrityImpact
			sc.Ointegrity = cveScV3.IntegrityImpact
			sc.Navailability = cveScV3.AvailabilityImpact
			sc.Oavailability = cveScV3.AvailabilityImpact
		} else {
			sc.NVDScore = cveScV2.BaseScore
			sc.OpenEulerScore = cveScV2.BaseScore
			vectorString := ""
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NaccessVector = cveScV2.AccessVector
			sc.OaccessVector = cveScV2.AccessVector
			sc.NaccessComplexity = cveScV2.AccessComplexity
			sc.OaccessComplexity = cveScV2.AccessComplexity
			sc.Nauthentication = cveScV2.Authentication
			sc.Oauthentication = cveScV2.Authentication
			sc.Nconfidentiality = cveScV2.ConfidentialityImpact
			sc.Oconfidentiality = cveScV2.ConfidentialityImpact
			sc.Nintegrity = cveScV2.IntegrityImpact
			sc.Ointegrity = cveScV2.IntegrityImpact
			sc.Navailability = cveScV2.AvailabilityImpact
			sc.Oavailability = cveScV2.AvailabilityImpact
		}
		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("InsertCveExcelGroups, CreateScore, "+
				"insert failed, cveScV3:", cveScV3, ",scerr: ", scerr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.CveId = CveRes.CveId
		SecNOtice.InfluenceComponent = pkList[0]
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = pkList[0] + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = pkList[0]
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = pkList[0] + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("InsertCveExcelGroups, CreateSecurityNotice, "+
				"insert failed, CveNum:", cveData.CveNum, ",secerr: ", secerr)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat1, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveGroups(cveData models.OriginUpstream, cveRef string,
	openeulerNum int, cveDesc models.OriginUpstreamDesc,
	cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2,
	pkList []string, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveDesc.EnDescription
	vul.Status = 0
	vul.CveVersion = pkList[1]
	vul.RepairTime = cveData.PublishedDate
	vul.PackName = pkList[0]
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveScV3.CveLevel
	vul.DataSource = 1
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = pkList[0]
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = pkList[0] + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
			RemoveSubstring(cveDesc.EnDescription, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveDesc.EnDescription, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.Nstatus = 0
	sc.Ostatus = 0
	if scopeType == "v3" {
		sc.NVDScore = cveScV3.BaseScore
		sc.OpenEulerScore = cveScV3.BaseScore
		vectorString := ""
		if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
			index := strings.IndexAny(cveScV3.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
				vectorString = cveScV3.VectorString[index+1:]
			} else {
				vectorString = cveScV3.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NattackVector = cveScV3.AttackVector
		sc.OattackVector = cveScV3.AttackVector
		sc.NattackComplexity = cveScV3.AttackComplexity
		sc.OattackComplexity = cveScV3.AttackComplexity
		sc.NprivilegeRequired = cveScV3.PrivilegesRequired
		sc.OprivilegeRequired = cveScV3.PrivilegesRequired
		sc.NuserInteraction = cveScV3.UserInteraction
		sc.OuserInteraction = cveScV3.UserInteraction
		sc.Nscope = cveScV3.Scope
		sc.Oscope = cveScV3.Scope
		sc.Nconfidentiality = cveScV3.ConfidentialityImpact
		sc.Oconfidentiality = cveScV3.ConfidentialityImpact
		sc.Nintegrity = cveScV3.IntegrityImpact
		sc.Ointegrity = cveScV3.IntegrityImpact
		sc.Navailability = cveScV3.AvailabilityImpact
		sc.Oavailability = cveScV3.AvailabilityImpact
	} else {
		sc.NVDScore = cveScV2.BaseScore
		sc.OpenEulerScore = cveScV2.BaseScore
		vectorString := ""
		if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
			index := strings.IndexAny(cveScV2.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
				vectorString = cveScV2.VectorString[index+1:]
			} else {
				vectorString = cveScV2.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NaccessVector = cveScV2.AccessVector
		sc.OaccessVector = cveScV2.AccessVector
		sc.NaccessComplexity = cveScV2.AccessComplexity
		sc.OaccessComplexity = cveScV2.AccessComplexity
		sc.Nauthentication = cveScV2.Authentication
		sc.Oauthentication = cveScV2.Authentication

		sc.Nconfidentiality = cveScV2.ConfidentialityImpact
		sc.Oconfidentiality = cveScV2.ConfidentialityImpact
		sc.Nintegrity = cveScV2.IntegrityImpact
		sc.Ointegrity = cveScV2.IntegrityImpact
		sc.Navailability = cveScV2.AvailabilityImpact
		sc.Oavailability = cveScV2.AvailabilityImpact
	}
	sc.ScoreType = scopeType
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveScV3.BaseScore
	scorecode.NvectorVule = cveScV3.VectorString
	scorecode.Status = 0
	cveId, cveErr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveErr != nil || cveId <= 0 {
		logs.Error("InsertCveGroups, CreateCveRelat, insert failed, "+
			"CveNum:", cveData.CveNum, ",cveErr: ", cveErr)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	return true, nil
}

// Synchronize the data returned by the Chinese Academy of Sciences
func GenCveVuler(cveData models.OriginUpstream, cveRef string, openeulernum int) (bool, error) {
	if cveData.Ids == "" || cveData.CveNum == "" {
		logs.Error("GenCveVuler, The current data cveNum is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("GenCveVuler, config init error:", err)
		return false, err
	}
	years, confOk := BConfig.Int("cve::cve_number_t")
	if confOk != nil {
		logs.Error("GenCveVuler, config cve::cve_number_t, error:", confOk)
		return false, errors.New("数据错误，暂时不处理")
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= years {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 5)
				logs.Error("GenCveVuler, cve: ", cveData.CveNum, ",Need to be greater than: ", years,
					", Otherwise there is no need to submit an issue on git, cveData: ", cveData)
				return false, errors.New("数据错误，暂时不处理")
			}
		}
	}
	cveDesc, ok := models.QueryCveDesc(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveDesc, The current data description is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveImpact, ok := models.QueryCveImpact(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveImpact, Data query failed, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	scopeType := "v3"
	//var cveScV2 models.OriginUpstreamImpactScoreV2
	cveScore, ok := models.QueryCveScore(cveImpact.ImpactId, "v3")
	if !ok {
		scopeType = "v2"
	}
	cveScV3, ok := models.QueryCveCvssV3(cveScore.ScoreId)
	if !ok {
		scopeType = "v2"
	}
	if cveScV3.VectorString == "" || len(cveScV3.VectorString) == 0 || cveScV3.BaseScore == 0.0 {
		scopeType = "v2"
	}
	cveScoreV2, ok2 := models.QueryCveScore(cveImpact.ImpactId, "v2")
	if !ok2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveScore3, data: ", cveData, ",cveImpact: ", cveImpact)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	cveScV2, okV2 := models.QueryCveCvssV2(cveScoreV2.ScoreId)
	if !okV2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveCvssV2, data: ", cveData, ",cveScore: ", cveScore)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	packNameMap := map[string]string{}
	packNameList := []string{}
	if cveData.PackName != "" && len(cveData.PackName) > 0 {
		packNameList = strings.Split(cveData.PackName, ",")
		if len(packNameList) > 0 {
			for _, pk := range packNameList {
				pkList := strings.Split(pk, "==")
				if len(pkList) == 2 {
					if _, ok := packNameMap[pkList[0]]; ok {
						if !strings.Contains(packNameMap[pkList[0]], pkList[1]) {
							packNameMap[pkList[0]] += "," + pkList[1]
						}
					} else {
						packNameMap[pkList[0]] = pkList[1]
					}
				}
			}
		}
	}
	for key, value := range packNameMap {
		if key != "" && len(key) > 1 {
			pkList := []string{}
			pkList = append(pkList, key)
			//pkList = append(pkList, value)
			versionFlag := false
			gaussFlag := false
			var goe models.GitPackageInfo
			openGausVersion := make([]string, 0)
			openEulerVersion := make([]string, 0)
			if value != "" && len(value) > 0 {
				versionList := strings.Split(value, ",")
				if len(versionList) > 0 {
					for _, ver := range versionList {
						if ver != "" && len(ver) > 1 {
							opy := models.OpenGussYaml{PackageName: key, Version: ver}
							openErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
							if openErr == nil && opy.Id > 0 {
								openGausVersion = append(openGausVersion, ver)
								gaussFlag = true
							}
							goe, ok = models.QueryCveOpeneulerDetaildataByName(key, ver)
							if ok {
								versionFlag = true
								openEulerVersion = append(openEulerVersion, ver)
							} else {
								logs.Error("GenCveVuler, The corresponding warehouse data is not queried, data: ", cveData)
							}
						}
					}
				}
			}
			repoFlag := false
			gr, reok := models.QueryOriginRepo(key)
			if reok && gr.RepoId > 0 {
				repoFlag = true
			}
			if !versionFlag || !repoFlag {
				if !gaussFlag {
					models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 4)
					logs.Error("GenCveVuler, The version information corresponds to the error, ",
						cveData.PackName, cveData.Version, cveData.CveId)
					return false, errors.New("数据错误，暂时不处理")
				}
			}
			organizationID := int8(1)
			orgId := int8(1)
			if versionFlag && gaussFlag {
				organizationID = 3
			} else if !versionFlag && gaussFlag {
				organizationID = 3
				orgId = 2
			} else if versionFlag && !gaussFlag {
				organizationID = 2
			}
			for ix := orgId; ix < organizationID; ix++ {
				CveRes, err := models.QueryCveByNum(cveData.CveNum, key, value, ix)
				if err {
					retVersion := AddCveVersion(ix, openGausVersion,
						openEulerVersion, CveRes.CveVersion)
					pkList = append(pkList, retVersion)
					lockx.Lock()
					ok, err := UpdateCveGroups(cveData, cveRef, openeulernum, CveRes, cveDesc, cveScV3, goe,
						scopeType, cveScV2, pkList, ix)
					lockx.Unlock()
					if !ok {
						logs.Error("GenCveVuler, UpdateCveGroups, cveData: ", cveData, ", err: ", err)
						models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
						return false, errors.New("数据错误，暂时不处理")
					}
				} else {
					retVersion := AddCveVersion(ix, openGausVersion,
						openEulerVersion, "")
					pkList = append(pkList, retVersion)
					lockx.Lock()
					ok, err := InsertCveGroups(cveData, cveRef, openeulernum, cveDesc, cveScV3, goe,
						scopeType, cveScV2, pkList, ix)
					lockx.Unlock()
					if !ok {
						logs.Error("GenCveVuler, InsertCveGroups, cveData: ", cveData, ", err: ", err)
						models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
						return false, errors.New("数据错误，暂时不处理")
					}
				}
			}
		}
	}
	models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 2)
	return true, nil
}

func AddCveVersion(organizationID int8, openGausVersion []string,
	openEulerVersion []string, cveVersion string) (retVersion string) {
	retVersion = cveVersion
	if organizationID == 2 {
		for _, versx := range openGausVersion {
			if retVersion != "" && len(retVersion) > 0 {
				if !strings.Contains(retVersion, versx) {
					retVersion = retVersion + "," + versx
				}
			} else {
				retVersion = versx
			}
		}
	} else {
		for _, versx := range openEulerVersion {
			if retVersion != "" && len(retVersion) > 0 {
				if !strings.Contains(retVersion, versx) {
					retVersion = retVersion + "," + versx
				}
			} else {
				retVersion = versx
			}
		}
	}
	return retVersion
}

func SyncCveVuler(cveData models.OriginExcel, cveRef string, openeulerNum, manYears int) (bool, error) {
	if cveData.CveNum == "" || len(cveData.CveNum) == 0 {
		logs.Error("SyncCveVuler, The current data cveNum is empty and "+
			"will not be processed temporarily, data: ", cveData)
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	organizationID := int8(1)
	orgId := int8(1)
	opy := models.OpenGussYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	openErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
	if openErr == nil && opy.Id > 0 {
		organizationID = 2
	}
	var god models.GitOpenEuler
	god.PackageName = cveData.PackName
	god.Version = cveData.CveVersion
	god.Status = 1
	ok := models.QueryCveOpeneulerdata(&god)
	if !ok {
		if organizationID == 1 {
			logs.Error("The repo and version correspond to errors, data: ", cveData)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 4)
			return false, errors.New("The repo and version correspond to errors and" +
				" will not be processed temporarily")
		}
	} else {
		if organizationID == 2 {
			organizationID = 3
		}
		logs.Info("QueryCveOpeneulerdata, god: ", god)
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= manYears {
				logs.Error("limited cve years, cveData: ", cveData, ", err: ", cveYears, manYears)
				models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 7)
				return false, errors.New("limited cve years")
			}
		}
	}
	if organizationID == 3 {
		orgId = 1
	} else if organizationID == 2 {
		organizationID = 3
		orgId = 2
	} else if organizationID == 1 {
		organizationID = 2
		orgId = 1
	}
	goe, ok := models.QueryCveOpeneulerDetaildataByName(cveData.PackName, cveData.CveVersion)
	if !ok {
		logs.Error("SyncCveVuler, The repo exists, but the yaml data source does not exist,"+
			" repo: ", cveData.PackName, cveData.CveVersion)
	}

	for ix := orgId; ix < organizationID; ix++ {
		CveRes, err := models.QueryCveByNum(cveData.CveNum, cveData.PackName, cveData.CveVersion, ix)
		if err {
			retVersion := AddCveVersion(ix, []string{cveData.CveVersion},
				[]string{cveData.CveVersion}, CveRes.CveVersion)
			cveData.CveVersion = retVersion
			lockx.Lock()
			ok, err := UpdateExcelCveGroups(cveData, cveRef, openeulerNum, CveRes, goe, ix)
			lockx.Unlock()
			if !ok {
				logs.Error("SyncCveVuler, UpdateExcelCveGroups, cveData: ", cveData, ", err: ", err)
				models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
				return false, errors.New("数据错误，暂时不处理")
			}
		} else {
			retVersion := AddCveVersion(ix, []string{cveData.CveVersion},
				[]string{cveData.CveVersion}, "")
			cveData.CveVersion = retVersion
			lockx.Lock()
			ok, err := InsertCveExcelGroups(cveData, cveRef, openeulerNum, goe, ix)
			lockx.Unlock()
			if !ok {
				logs.Error("SyncCveVuler, InsertCveExcelGroups, cveData: ", cveData, ", err: ", err)
				models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
				return false, errors.New("数据错误，暂时不处理")
			}
		}
	}
	models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 2)
	return true, nil
}

func GetCveOriginData(prcnum, days, openeulernum, credibilityLevel int, cveRef string) (bool, error) {
	defer common.Catchs()
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCve(beforeTime, prcnum, credibilityLevel)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing, err: ", err,
				", Processing time range > beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			// Add mutex
			lockOk := models.LockUpdateOriginStatus(common.GetCurTime(), cveOrg.PackName,
				cveOrg.Version, cveOrg.CveId, 15)
			if !lockOk {
				logs.Error("Current data is being processed: PackName: ",
					cveOrg.PackName, cveOrg.Version, cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx int, cveData models.OriginUpstream, locOpenEulernum int, locCveRef string) {
				ok, err := GenCveVuler(cveData, locCveRef, locOpenEulernum)
				if !ok {
					logs.Error("GenCveVuler, cveData: ", cveData, "Processing failed, err: ", err)
				}
				ch <- idx
			}(i, cveOrg, openeulernum, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func GetCveOriginExcelData(prcnum, days, openeulerNum int, cveRef string) (bool, error) {
	defer common.Catchs()
	manYears, ok := beego.AppConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("config cve::manYears error:", ok)
		return false, ok
	}
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCveExcel(beforeTime, prcnum)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing imported by excel, err: ", err,
				", beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("Excel has a total of: ", num, "Articles of data need to be processed,", osx)
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			logs.Info("The current normal analysis: ", count, "Pieces of data, i:", i, ", cvenum: ", cveOrg.CveNum)
			// add mutex
			lockOk := models.LockUpdateOriginExcelStatus(common.GetCurTime(), cveOrg.CveId, 15)
			if !lockOk {
				logs.Error("Current data is being processed, cveNum: ", cveOrg.CveNum, ",cveId: ", cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx, manYears, locOpeneulerNum int, cveData models.OriginExcel, locCveRef string) {
				ok, err := SyncCveVuler(cveData, locCveRef, openeulerNum, manYears)
				if !ok {
					logs.Error("SyncCveVuler, err: ", err, "cveData: ", cveData)
				}
				ch <- idx
			}(i, manYears, openeulerNum, cveOrg, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func InsertIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, owner string) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNumber
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	vul.Description = RemoveSubstring(lop.BriefIntroduction, specCharList)
	vul.Status = cveStatus
	retVersion := AddCveVersion(1, []string{},
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), "")
	vul.CveVersion = retVersion
	vul.RepairTime = ""
	vul.PackName = cveData.RepoPath
	vul.CveUrl = cveRef + cveData.CveNumber
	vul.IsExport = 0
	vul.DataSource = 4
	vul.OrganizationID = 1
	v2, cvsError := strconv.ParseFloat(lop.CvsScore, 64)
	if cvsError != nil {
		vul.CveLevel = "Critical"
	}
	vul.CveLevel = openEulerScoreProc(v2)
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNumber
	sec.InfluenceComponent = cveData.RepoPath
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.RepoPath + " security update"
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
		RemoveSubstring(lop.BriefIntroduction, specCharList)
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	opScoreLeve := ""
	opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
	if opError != nil {
		opScoreLeve = "Critical"
	} else {
		opScoreLeve = openEulerScoreProc(opScore)
	}
	sec.ReferenceLink = cveRef + cveData.CveNumber
	affectBrands := ""
	if lop.InfVersion != "" && len(lop.InfVersion) > 1 {
		affectBrands = AddAffectBrands(lop.InfVersion)
	} else {
		affectBrands = lop.InfProduct
	}
	sec.Introduction = "An update for " + cveData.RepoPath + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	var sc models.Score
	sc.CveNum = cveData.CveNumber
	nVDScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
	if nvdError == nil {
		sc.NVDScore = nVDScore
	}
	openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
	if openError == nil {
		sc.OpenEulerScore = openEulerScore
	}
	sc.NvectorVule = lop.CvsVector
	sc.OvectorVule = lop.OpVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	sc.ScoreType = lop.ScoreType
	if sc.ScoreType == "v3" {
		vectorN := models.VectorValue{}
		ok := vectorN.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NattackVector = vectorN.AttackVector
			sc.NattackComplexity = vectorN.AttackComplexity
			sc.NprivilegeRequired = vectorN.PrivilegesRequired
			sc.NuserInteraction = vectorN.UserInteraction
			sc.Nscope = vectorN.Scope
			sc.Nconfidentiality = vectorN.Confidentiality
			sc.Nintegrity = vectorN.Integrity
			sc.Navailability = vectorN.Availability
		}
		vectorO := models.VectorValue{}
		vectOk := vectorO.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OattackVector = vectorO.AttackVector
			sc.OattackComplexity = vectorO.AttackComplexity
			sc.OprivilegeRequired = vectorO.PrivilegesRequired
			sc.OuserInteraction = vectorO.UserInteraction
			sc.Oscope = vectorO.Scope
			sc.Oconfidentiality = vectorO.Confidentiality
			sc.Ointegrity = vectorO.Integrity
			sc.Oavailability = vectorO.Availability
		}
	}
	if sc.ScoreType == "v2" {
		vectorN2 := models.VectorValueV2{}
		ok := vectorN2.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NaccessVector = vectorN2.AccessVector
			sc.NaccessComplexity = vectorN2.AccessComplexity
			sc.Navailability = vectorN2.Availability
			sc.Nconfidentiality = vectorN2.Confidentiality
			sc.Nintegrity = vectorN2.IntegrityImpact
			sc.Nauthentication = vectorN2.Authentication
		}
		vectorO2 := models.VectorValueV2{}
		vectOk := vectorO2.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OaccessVector = vectorO2.AccessVector
			sc.OaccessComplexity = vectorO2.AccessComplexity
			sc.Oavailability = vectorO2.Availability
			sc.Oconfidentiality = vectorO2.Confidentiality
			sc.Ointegrity = vectorO2.IntegrityImpact
			sc.Oauthentication = vectorO2.Authentication
		}
	}
	var opensa models.OpenEulerSA
	var OpenNumData int
	//var os models.OpenSaId
	osx, opError := models.QueryOpenSaLastId()
	if opError == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulernum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulernum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = nVDScore
	scorecode.NvectorVule = lop.CvsVector
	scorecode.Status = 0
	cveid, cveError := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveError != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNumber)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	vul.CveId = cveid
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum, PackName: cveData.RepoPath}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = cveid
	issueTemp.CveNum = vul.CveNum
	err := models.GetIssueTemplateByColName(&issueTemp, "cve_id", "cve_num")
	if err != nil {
		logs.Info("no issueTemp: ", err)
	}
	issueTemp.CveNum = cveData.CveNumber
	issueTemp.OwnedComponent = cveData.RepoPath
	issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
	issueTemp.NVDScore = nVDScore
	issueTemp.OpenEulerScore = openEulerScore
	issueTemp.NVDVector = lop.CvsVector
	issueTemp.OpenEulerVector = lop.OpVector
	issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
	issueTemp.CveAnalysis = lop.Influences
	issueTemp.PrincipleAnalysis = lop.Principle
	issueTemp.AffectedVersion = lop.InfVersion
	issueTemp.Solution = lop.AvoidScheme
	issueTemp.IssueId = cveData.IssueId
	issueTemp.IssueNum = cveData.Number
	issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
	issueTemp.StatusName = cveData.State
	issueTemp.Assignee = cveData.IssueAssignee
	if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" || cveData.State == "开启的" {
		issueTemp.Status = 1
		issueTemp.IssueStatus = 1
		issueTemp.StatusName = "open"
	} else if strings.ToLower(cveData.State) == "progressing" ||
		strings.ToLower(cveData.State) == "started" || cveData.State == "进行中" {
		issueTemp.Status = 2
		issueTemp.IssueStatus = 3
		issueTemp.StatusName = "progressing"
	} else if strings.ToLower(cveData.State) == "closed" || cveData.State == "已完成" {
		issueTemp.Status = 3
		issueTemp.IssueStatus = 2
		vul.IsExport = 3
		cveCenter.IsExport = 3
		issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
	} else if strings.ToLower(cveData.State) == "rejected" || cveData.State == "已拒绝" {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
		issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
	} else if strings.ToLower(cveData.State) == "suspended" || cveData.State == "已挂起" {
		issueTemp.Status = 5
		issueTemp.IssueStatus = 6
		issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
	} else {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
	}
	issueTemp.Owner = owner
	issueTemp.Repo = lop.Repo
	if cveData.Title != "" {
		issueTemp.Title = cveData.Title
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	issueTemp.IssueType = CIssueType
	issueTemp.CveLevel = vul.CveLevel
	issueTemp.MtAuditFlag = 1
	issueTemp.SaAuditFlag = 1
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("创建issue 模板的数据失败, cveNum: ", cveData.CveNumber, "err: ", issError)
		return false, issError
	} else {
		logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cveData.CveNumber)
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	hookError := CreateDepositHooks(accessToken, owner, cveData.RepoPath, vul, cveData.Number, cveData.IssueId)
	logs.Info(hookError)
	return true, nil
}

func UpdateIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, vul models.VulnCenter, owner string) (bool, error) {
	//var vul models.VulnCenter
	if vul.CveNum == "" || len(vul.CveNum) < 1 {
		vul.CveNum = cveData.CveNumber
	}
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	if vul.Description == "" || len(vul.Description) < 1 {
		vul.Description = RemoveSubstring(lop.BriefIntroduction, specCharList)
	}
	vul.Status = cveStatus
	retVersion := AddCveVersion(1, []string{},
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), vul.CveVersion)
	vul.CveVersion = retVersion
	//if vul.CveVersion == "" || len(vul.CveVersion) < 1 {
	//	vul.CveVersion = RemoveSubstring(lop.Version, specCharList)
	//}
	vul.RepairTime = ""
	if vul.PackName == "" || len(vul.PackName) < 1 {
		vul.PackName = cveData.RepoPath
	}
	if vul.CveUrl == "" || len(vul.CveUrl) < 1 {
		vul.CveUrl = cveRef + cveData.CveNumber
	}
	//vul.IsExport = 0
	//vul.DataSource = 4
	var sec models.SecurityNotice
	sec.CveId = vul.CveId
	sec.CveNum = vul.CveNum
	sec.InfluenceComponent = vul.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = vul.PackName + " security update"
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" + vul.Description
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	sec.ReferenceLink = vul.CveUrl
	var issueTemps models.IssueTemplate
	issueTemps.CveId = vul.CveId
	issueTemps.CveNum = vul.CveNum
	models.GetIssueTemplateByColName(&issueTemps, "cve_id", "cve_num")
	opScoreLeve := ""
	opScore := float64(0)
	if issueTemps.OpenEulerScore > 0 {
		opScore = issueTemps.OpenEulerScore
		opScoreLeve = openEulerScoreProc(opScore)
	} else {
		opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
		if opError != nil {
			opScoreLeve = "Critical"
		} else {
			opScoreLeve = openEulerScoreProc(opScore)
		}
	}
	if issueTemps.NVDVector != "" && len(issueTemps.NVDVector) > 1 {
		lop.CvsVector = issueTemps.NVDVector
	}
	if issueTemps.OpenEulerVector != "" && len(issueTemps.OpenEulerVector) > 1 {
		lop.OpVector = issueTemps.OpenEulerVector
	}
	vul.CveLevel = opScoreLeve
	affectBrands := ""
	if issueTemps.AffectedVersion != "" && len(issueTemps.AffectedVersion) > 1 {
		affectBrands = AddAffectBrands(issueTemps.AffectedVersion)
	} else {
		if lop.InfVersion != "" && len(lop.InfVersion) > 1 {
			affectBrands = AddAffectBrands(lop.InfVersion)
		}
	}
	sec.Introduction = "An update for " + vul.PackName + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	nVDScore := 0.0
	if issueTemps.NVDScore > 0 {
		nVDScore = issueTemps.NVDScore
	}
	//var err error
	var score models.Score
	score.CveId = vul.CveId
	var scOk bool
	score, scOk = models.QueryScoreByCveId(vul.CveId)
	if !scOk || score.Id == 0 {
		//var sc models.Score
		score.CveNum = vul.CveNum
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				score.NVDScore = nVDScore
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
			}
		}
		score.NvectorVule = lop.CvsVector
		score.OvectorVule = lop.OpVector
		score.Nstatus = 0
		score.Ostatus = 0
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorN := models.VectorValue{}
			ok := vectorN.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NattackVector = vectorN.AttackVector
				score.NattackComplexity = vectorN.AttackComplexity
				score.NprivilegeRequired = vectorN.PrivilegesRequired
				score.NuserInteraction = vectorN.UserInteraction
				score.Nscope = vectorN.Scope
				score.Nconfidentiality = vectorN.Confidentiality
				score.Nintegrity = vectorN.Integrity
				score.Navailability = vectorN.Availability
			}
			vectorO := models.VectorValue{}
			vectOk := vectorO.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorN2 := models.VectorValueV2{}
			ok := vectorN2.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NaccessVector = vectorN2.AccessVector
				score.NaccessComplexity = vectorN2.AccessComplexity
				score.Navailability = vectorN2.Availability
				score.Nconfidentiality = vectorN2.Confidentiality
				score.Nintegrity = vectorN2.IntegrityImpact
				score.Nauthentication = vectorN2.Authentication
			}
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}

	} else {
		v2 := score.NVDScore
		vul.CveLevel = openEulerScoreProc(v2)
		score.CveNum = vul.CveNum
		score.Nstatus = 2
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
			score.Nstatus = 3
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				if score.NVDScore != nVDScore {
					score.Nstatus = 3
					score.NVDScore = nVDScore
				}
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
			score.Ostatus = 3
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
				score.Ostatus = 3
			}
		}
		score.OvectorVule = lop.OpVector
		score.NvectorVule = lop.CvsVector
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorO := models.VectorValue{}
			okx := vectorO.VctToVectorValue(lop.OpVector)
			if okx {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}
	}
	if vul.Status == 0 || vul.Status == 1 || vul.Status == 3 {
		accessToken := os.Getenv("GITEE_TOKEN")
		hookError := CreateDepositHooks(accessToken, owner, vul.PackName, vul, cveData.Number, cveData.IssueId)
		logs.Info(hookError)
	}
	if vul.Status == 3 {
		vul.Status = 2
	}
	if vul.Status == 4 {
		vul.Status = 1
	}
	osa, osaError := models.QueryOpenSaById(vul.CveId)
	if osaError == nil && osa.OpenId > 0 {
		sec.OpenId = osa.OpenId
		score.OpenId = osa.OpenId
	} else {
		var opensa models.OpenEulerSA
		var OpenNumData int
		//var os models.OpenSaId
		osx, opError := models.QueryOpenSaLastId()
		if opError == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulernum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulernum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = vul.CveId
		openId, openError := models.CreateOpenEulerSA(&opensa)
		if openError != nil && openId == 0 {
			logs.Error("生成openSA失败，openSA: ", opensa, ", error: ", openError)
			return false, errors.New("数据插入失败，暂时不处理")
		}
		sec.OpenId = openId
		score.OpenId = openId
	}
	cveError := models.UpdateCveRelat(&vul, &sec, &score)
	if cveError != nil || vul.CveId == 0 {
		logs.Error("UpdateCveRelat(&vul, &sec, &sc) failed CveNum:", cveData.CveNumber, ",err:", cveError)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	if scOk || score.Id > 0 {
		if score.NVDScore != nVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = score.NVDScore
			scorecode.NvectorVule = score.NvectorVule
			scorecode.Status = 0
			scorecode.CveId = vul.CveId
			scRecordId, scError := models.InsertScoreRecord(&scorecode)
			logs.Info(scRecordId, scError)
		}
	}
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum, PackName: cveData.RepoPath}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = vul.CveId
	issueTemp.CveNum = vul.CveNum
	templateErr := models.GetIssueTemplateByColName(&issueTemp, "cve_id", "cve_num")
	if templateErr == nil && issueTemp.TemplateId > 0 {
		//issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = cveData.RepoPath
		//issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil && openEulerScore > 0 && issueTemp.OpenEulerScore == 0 {
			issueTemp.OpenEulerScore = openEulerScore
		}
		if issueTemp.NVDVector == "" || len(issueTemp.NVDVector) < 1 {
			issueTemp.NVDVector = lop.CvsVector
		}
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil && nvdScore > 0 && issueTemp.NVDScore == 0 {
			issueTemp.NVDScore = nvdScore
		}
		if lop.OpVector != "" && len(lop.OpVector) > 1 || len(issueTemp.OpenEulerVector) < 2 {
			issueTemp.OpenEulerVector = lop.OpVector
		}
		if issueTemp.CveBrief == "" || len(issueTemp.CveBrief) < 2 {
			issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		}
		if lop.Influences != "" && len(lop.Influences) > 1 && len(issueTemp.CveAnalysis) < 2 {
			issueTemp.CveAnalysis = lop.Influences
		}
		issueTemp.PrincipleAnalysis = lop.Principle
		if paraAffectBrandBool(lop.InfVersion) {
			issueTemp.AffectedVersion = lop.InfVersion
		}
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.Assignee = cveData.IssueAssignee
		statusName := issueTemp.StatusName
		if issueTemp.IssueId != cveData.IssueId || issueTemp.IssueNum != cveData.Number {
			if issueTemp.Status > 3 {
				issueTemp.IssueId = cveData.IssueId
				issueTemp.IssueNum = cveData.Number
				issueTemp.StatusName = cveData.State
				statusName = cveData.State
			}
		} else {
			issueTemp.StatusName = cveData.State
			statusName = cveData.State
		}
		if strings.ToLower(statusName) == "open" || statusName == "待办的" || statusName == "开启的" {
			issueTemp.Status = 1
			issueTemp.IssueStatus = 1
			issueTemp.StatusName = "open"
		} else if strings.ToLower(statusName) == "progressing" ||
			strings.ToLower(statusName) == "started" || statusName == "进行中" {
			issueTemp.Status = 2
			issueTemp.IssueStatus = 3
			issueTemp.StatusName = "progressing"
		} else if strings.ToLower(statusName) == "closed" || statusName == "已完成" {
			issueTemp.Status = 3
			issueTemp.IssueStatus = 2
			issueTemp.MtAuditFlag = 1
			cveCenter.IsExport = 3
		} else if strings.ToLower(statusName) == "rejected" || statusName == "已拒绝" {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
		} else if strings.ToLower(statusName) == "suspended" || statusName == "已挂起" {
			issueTemp.Status = 5
			issueTemp.IssueStatus = 6
		} else {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
		}
		issueTemp.Owner = owner
		issueTemp.Repo = lop.Repo
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	} else {
		issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = cveData.RepoPath
		issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		issueTemp.NVDScore = nVDScore
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			issueTemp.OpenEulerScore = openEulerScore
		}
		issueTemp.NVDVector = lop.CvsVector
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil {
			issueTemp.NVDScore = nvdScore
		}
		issueTemp.NVDVector = lop.CvsVector
		issueTemp.OpenEulerVector = lop.OpVector
		issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		issueTemp.CveAnalysis = RemoveSubstring(lop.Influences, specCharList)
		issueTemp.PrincipleAnalysis = lop.Principle
		issueTemp.AffectedVersion = lop.InfVersion
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.IssueId = cveData.IssueId
		issueTemp.IssueNum = cveData.Number
		issueTemp.StatusName = cveData.State
		issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
		issueTemp.Assignee = cveData.IssueAssignee
		if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" || cveData.State == "开启的" {
			issueTemp.Status = 1
			issueTemp.IssueStatus = 1
			issueTemp.StatusName = "open"
		} else if strings.ToLower(cveData.State) == "progressing" ||
			strings.ToLower(cveData.State) == "started" || cveData.State == "进行中" {
			issueTemp.Status = 2
			issueTemp.IssueStatus = 3
			issueTemp.StatusName = "progressing"
		} else if strings.ToLower(cveData.State) == "closed" || cveData.State == "已完成" {
			issueTemp.Status = 3
			issueTemp.IssueStatus = 2
			cveCenter.IsExport = 3
			issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		} else if strings.ToLower(cveData.State) == "rejected" || cveData.State == "已拒绝" {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		} else if strings.ToLower(cveData.State) == "suspended" || cveData.State == "已挂起" {
			issueTemp.Status = 5
			issueTemp.IssueStatus = 6
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
		} else {
			issueTemp.Status = 4
			issueTemp.IssueStatus = 6
		}
		issueTemp.Owner = owner
		issueTemp.Repo = lop.Repo
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	// Store issue data
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("创建issue 模板的数据失败, cveNum: ", cveData.CveNumber, "err: ", issError)
		return false, issError
	} else {
		logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cveData.CveNumber)
	}
	return true, nil
}

func paraAffectBrandBool(affectedVersion string) bool {
	unaffectedBranchList := []string{}
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "受影响" || prams == "不受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" || prams == "不受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func GenCveVulerByIssue(cveData models.GiteOriginIssue, cveRef string, openeulernum int, owner string) (bool, error) {
	defer common.Catchs()
	lock.Lock()
	hole, err := cveData.ParseToLoophole()
	lock.Unlock()
	organizationID := int8(1)
	if err != nil {
		logs.Error("Data parsing error, err: ", err, ", cveData: ", cveData)
		//models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, 2, cveData.RepoPath)
		models.UpdateCveIssueStatusById(3, cveData.Id)
		return false, err
	}
	goe, ok := models.QueryCveOpeneulerDetaildataByName(cveData.RepoPath, hole.Version)
	if !ok || goe.DetailId == 0 {
		logs.Error("Failed to get data, ", "Components: ", hole.Components, ",Version: ", hole.Version)
	}
	if cveData.State != "" && (strings.ToLower(cveData.State) == "rejected" || cveData.State == "已拒绝") {
		logs.Info("Process data whose issue status is rejected：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else if cveData.State != "" && (strings.ToLower(cveData.State) == "closed" || cveData.State == "已完成") {
		logs.Info("Process data whose issue status is closed：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 3, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else {
		logs.Info("Process data whose issue status is open and processing：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Version, organizationID)
		if ok && len(cvd.CveNum) > 1 {
			if cvd.Status == 0 {
				if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
					strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
					strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				} else {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 3, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				}
			} else if cvd.Status == 1 {
				if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
					strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
					strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 4, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				} else {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				}
			} else {
				lock.Lock()
				upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
				lock.Unlock()
				logs.Info(upOk, upError)
			}
		} else {
			if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
				strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
				strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			} else {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			}
		}
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	}
}

func GetCveIssueData(prcnum, days, openeulernum int, cveRef, owner string) (bool, error) {
	defer common.Catchs()
	count := 0
	for {
		gs, num, err := models.QueryOriginCveIssue(prcnum)
		if err != nil || num == 0 {
			logs.Info("当前无cveissue原始数据处理, err: ", err,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("总共有: ", num, "条的数据需要处理, ", gs)
		ch := make(chan int, len(gs))
		for i, cveOrg := range gs {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveOrg.IssueId)
			// add mutex
			lockOk := models.LockUpdateCveIssueStatus(15, cveOrg.Id)
			if !lockOk {
				logs.Error("Data is being processed, id: ", cveOrg.Id, ",cveOrg: ", cveOrg)
				ch <- i
				continue
			}
			if cveOrg.CveNumber == "" || len(cveOrg.CveNumber) == 0 {
				logs.Error("数据异常, 不处理, cveData: ", cveOrg)
				models.UpdateCveIssueStatusById(3, cveOrg.Id)
				ch <- i
				continue
			}
			go func(idx, openeulernum int, cveData models.GiteOriginIssue, locCveRef, locOwner string) {
				ok, err := GenCveVulerByIssue(cveData, locCveRef, openeulernum, locOwner)
				if !ok {
					logs.Error("GenCveVulerByIssue, cveData: ", cveData, "处理失败, err: ", err)
					models.UpdateCveIssueStatusById(3, cveData.Id)
				}
				ch <- idx
			}(i, openeulernum, cveOrg, cveRef, owner)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

//GetSecurityNotice Go to the CVE official website to obtain the cve data to determine
//whether the cve issue needs to be exported.
func GetCveSecurityNotice(cveNumber string) (bool, models.RespCveDetail) {
	var detail models.RespCveDetail
	var urlS url.URL
	q := urlS.Query()
	q.Add("cveId", cveNumber)
	params := q.Encode()
	req, _ := http.NewRequest("GET", "https://openeuler.org", nil)
	req.URL = &url.URL{
		Scheme:   req.URL.Scheme,
		Host:     req.URL.Host,
		RawQuery: params,
		Path:     "/api-cve/cve-security-notice-server/cvedatabase/getByCveId",
	}

	req.URL.EscapedPath()
	resp, err := http.Get(req.URL.String())
	if err != nil {
		logs.Error("Get, url: ", req.URL.String(), err)
		return false, detail
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error("ReadAll, url: ", req.URL.String(), err)
		return false, detail
	}
	err = json.Unmarshal(body, &detail)
	if err != nil {
		logs.Error("Unmarshal, url: ", req.URL.String(), err)
		return false, detail
	}

	if detail.Result != nil && detail.Result.Id > 0 {
		return true, detail
	}
	return false, detail
}

//FilterCveExported Filter exportable data
func FilterCveExported() {
	logs.Info("Start by removing cve data that has already released SA...")
	data, err := models.GetCanExportVulnCenterData()
	if err != nil {
		logs.Error(err)
		return
	}
	for _, v := range data {
		go func(center models.VulnCenter) {
			ewg.Add(1)
			defer ewg.Done()
			issueExist, _ := GetCveSecurityNotice(center.CveNum)
			if issueExist {
				dbLock.Lock()
				center.IsExport = 1
				models.UpdateVulnCenter(&center, "is_export")
				dbLock.Unlock()
			} else {
				if center.IsExport == 2 {
					dbLock.Lock()
					center.IsExport = 3
					models.UpdateVulnCenter(&center, "is_export")
					dbLock.Unlock()
				}
			}
		}(v)

	}
	ewg.Wait()
	logs.Info("Excluding the cve data that has been released SA ends...")
}

func GenerateExcelTask() error {
	FilterCveExported()
	return nil
}

func GenerateExcelTask1() error {
	FilterCveExported()
	tn := time.Now().Format("2006-01-02")
	dir := beego.AppConfig.DefaultString("fileDir", "download")
	err := util.MakeDir(dir)
	if err != nil {
		return err
	}
	fn := filepath.Join(dir, fmt.Sprintf("Cve数据与安全公告%s.xlsx", tn))
	err = GenerateCveExcel(fn, "openEuler", 0, true)
	if err != nil {
		return err
	}
	er := models.ExportRecord{FileName: fn, FileCode: common.EncryptMd5(fn), State: 1}
	err = er.Insert()
	return err
}

//GenerateExcelTrigger generate cve&security notice excel file by pr merge and influence package release.
func GenerateExcelTrigger(wgCrvf *sync.WaitGroup, fileName, startTime, fileCode, affectBranch,
	csvDownPath, dir string, cvrfFileList map[string][]string,
	componentMap map[string]ComponentInfo, cvfrFileMap map[string]CvrfSa) {
	defer wgCrvf.Done()
	logs.Info(affectBranch, ", GenerateExcelTrigger start....")
	xmlFileName := beego.AppConfig.String("xml::updateinfo_path")
	xmfilePath := filepath.Join(dir, affectBranch+"_"+xmlFileName)
	var cvexml []CveXml
	var dpdates Updates
	securityNotice := make(map[string][]SecurityNoticeXml)
	packRpmx := make(map[string][]PackRpm)
	ReadXml(xmfilePath, &dpdates)
	fr := models.ExportRecord{FileName: fileName}
	err := fr.Read("file_name")
	if err != nil {
		logs.Error("sddds", err)
		return
	}
	fileName = filepath.Join(dir, fileName)
	localPath := filepath.Join(dir, affectBranch+"_release-package.CSV")
	err = downloadPackageFile(localPath, csvDownPath, affectBranch)
	if err != nil {
		logs.Error(err)
		fr.State = 2
		_ = fr.Update("state")
		return
	}
	pkgList, err := ExtractPackageData(localPath)
	if err != nil {
		logs.Error(err)
		fr.State = 2
	} else {
		su := time.Now().Format("2006-01-02")
		snPrefix := "openEuler-" + su
		snSuffix := int64(1001)
		err = GenerateCveExcelByTrigger(affectBranch, fileName, snPrefix, startTime,
			snSuffix, true, pkgList, cvrfFileList,
			componentMap, cvfrFileMap, &cvexml, &dpdates,
			securityNotice, packRpmx)
		if err != nil {
			logs.Error(err)
			fr.State = 2
		}
		fr.State = 1
	}
	_ = fr.Update("state")
	// write xml
	WriteXml(xmfilePath, cvexml, &dpdates, securityNotice, packRpmx)
	// zip file
	zipFileList := []string{fileName, xmfilePath}
	//zipFileList := []string{"download/cve与安全公告openEuler-20.03-LTS_1607081986.xlsx", "download/updateinfo.xml"}
	if isExist := fileExist(zipFileList); isExist {
		zipFileName := affectBranch + "_" + common.GetCurDate() + "_" + strconv.Itoa(time.Now().Nanosecond()) + ".zip"
		zipFileName = filepath.Join(dir, zipFileName)
		zipErr := ZipFiles(zipFileName, zipFileList, dir, dir)
		if zipErr != nil {
			logs.Error("File compression failed: err: ", zipErr)
		}
		// send email
		sendError := SendEmail(zipFileName, 0, "", "")
		if sendError != nil {
			logs.Error("SendEmail, sendErr: ", sendError)
			return
		}
		zipFileList = append(zipFileList, zipFileName)
	}
	// Clear file
	DelFile(zipFileList)
	logs.Info(affectBranch, ", GenerateExcelTrigger: end")
}

func downloadPackageFile(localPath, url, affectBranch string) error {
	logs.Info("The csv file currently being downloaded is: ", url)
	pkgLock.Lock()
	err := GiteeDownCsv(localPath, affectBranch)
	pkgLock.Unlock()
	return err
}

func GiteeDownCsv(localPath, branch string) (error) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := "unsunghero"
	repo := "obs_pkg_rpms"
	path := fmt.Sprintf("latest_rpm/%v.csv", branch)
	gitUrl := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/%v/contents/%v?access_token=%v", owner, repo, path, accessToken)
	resp, err := http.Get(gitUrl)
	if err != nil {
		logs.Error("get error, url:", gitUrl, "error: ", err)
		return err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error(err)
		return err
	}
	//logs.Info("body: \n", string(body), "url: ", gitUrl)
	var contents map[string]interface{}
	err = json.Unmarshal(body, &contents)
	if err != nil {
		logs.Error(err)
		return err
	}
	f, ferr := os.Create(localPath)
	if ferr != nil {
		logs.Error(ferr)
		return ferr
	}
	fileType := contents["type"].(string)
	encoding := contents["encoding"].(string)
	content := contents["content"].(string)
	if fileType == "file" && encoding == "base64" {
		data, baseErr := base64.StdEncoding.DecodeString(content)
		if baseErr == nil {
			f.Write(data)
		}
	} else {
		f.WriteString(content)
	}
	return nil
}
