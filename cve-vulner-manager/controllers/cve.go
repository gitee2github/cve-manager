package controllers

import (
	"cvevulner/errcode"
	"cvevulner/models"
	"cvevulner/taskhandler"

	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
)

type CveIssueInfoController struct {
	beego.Controller
}

func (c *CveIssueInfoController) RetData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type CveIssueInfoData struct {
	IssueNum       string  `json:"issue_id"`
	CveNum         string  `json:"CVE_num"`
	OpeneulerScore float64 `json:"openeuler_score"`
	NvdScore       float64 `json:"NVD_score"`
	Branch         string  `json:"milestone"`
}

// @Title Get cveissueinfo
// @Description get cve
// @Param	status	int	true (0,1,2)
// @Success 200 {object} CveIssueInfoData
// @Failure 403 :status is err
// @router / [get]
func (u *CveIssueInfoController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		", Header: ", req.Header, ", body: ", req.Body)
	resp := make(map[string]interface{})
	var ird []CveIssueInfoData
	resp["code"] = errcode.RecodeNodata
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
	resp["body"] = []CveIssueInfoData{}
	resp["total"] = 0
	//defer u.RetData(resp)
	milestone := u.GetString("milestone", "")
	count := models.QueryIssueCount(milestone)
	if count > 0 {
		resp["total"] = count
		resp["code"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		currentPage, err := u.GetInt("currentPage", 1)
		if err != nil {
			logs.Error("err: ", err, ", currentPage: ", currentPage)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetData(resp)
			return
		}
		pageSize, err := u.GetInt("pageSize", 100)
		if err != nil {
			logs.Error("err: ", err, ", pageSize: ", pageSize)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetData(resp)
			return
		}
		issueData, issueErr := models.QueryCveIssueByBranch(currentPage, pageSize, milestone)
		if issueErr == nil && len(issueData) > 0 {
			for _, issues := range issueData {
				var irda CveIssueInfoData
				irda.CveNum = issues.CveNum
				irda.IssueNum = issues.IssueNum
				irda.OpeneulerScore = issues.OpeneulerScore
				irda.NvdScore = issues.NvdScore
				irda.Branch = issues.AffectProduct
				ird = append(ird, irda)
			}
			resp["body"] = ird
			resp["code"] = errcode.RecodeOk
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
			u.RetData(resp)
		} else {
			resp["code"] = errcode.RecodeNodata
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
			u.RetData(resp)
			return
		}
	}
}

type CveAllIssueController struct {
	beego.Controller
}

func (c *CveAllIssueController) RetCveData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type CveAllIssueoData struct {
	IssueNum            string  `json:"issue_id"`
	CveNum              string  `json:"CVE_num"`
	OpeneulerScore      float64 `json:"openeuler_score"`
	NvdScore            float64 `json:"NVD_score"`
	Branch              string  `json:"milestone"`
	CveLevel            string  `json:"CVE_level"`
	PlanClosedTime      string  `json:"plan_closed_time"`
	CvePublicTime       string  `json:"CVE_public_time"`
	CveVtopicPublicTime string  `json:"CVE_vtopic_public_time"`
	CveVtopicRecTime    string  `json:"CVE_vtopic_rec_time"`
	RpmPublicTime       string  `json:"rpm_public_time"`
	SaPublicTime        string  `json:"SA_public_time"`
}

// @Title Obtain all cve data and provide operation kanban for use
// @Description get issue
// @Param	pageSize 1,currentPage 10, updatetime nil
// @Success 200 {object} CveAllIssueoData
// @Failure 403 :status is err
// @router / [get]
func (u *CveAllIssueController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		", Header: ", req.Header, ", body: ", req.Body)
	resp := make(map[string]interface{})
	var cid []CveAllIssueoData
	resp["code"] = errcode.RecodeNodata
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
	resp["body"] = []CveAllIssueoData{}
	resp["total"] = 0
	//defer u.RetCveData(resp)
	communityFlag, flagErr := u.GetInt("communityFlag", 0)
	if flagErr != nil {
		communityFlag = 0
	}
	startTime := u.GetString("startTime", "")
	count := models.QueryCveAllIssueCount(communityFlag, startTime)
	if count > 0 {
		resp["total"] = count
		resp["code"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		currentPage, err := u.GetInt("currentPage", 1)
		if err != nil {
			logs.Error("err: ", err, ", currentPage: ", currentPage)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetCveData(resp)
			return
		}
		pageSize, err := u.GetInt("pageSize", 100)
		if err != nil {
			logs.Error("err: ", err, ", pageSize: ", pageSize)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetCveData(resp)
			return
		}
		issueData, issueErr := models.QueryCveAllIssueData(currentPage, pageSize, communityFlag, startTime)
		if issueErr == nil && len(issueData) > 0 {
			for _, issues := range issueData {
				var irda CveAllIssueoData
				irda.CveNum = issues.CveNum
				irda.IssueNum = issues.IssueNum
				irda.OpeneulerScore = issues.OpeneulerScore
				irda.NvdScore = issues.NvdScore
				irda.Branch = issues.AffectedVersion
				irda.CveLevel = issues.CveLevel
				irda.CveVtopicPublicTime = issues.FirstPerTime
				irda.CveVtopicRecTime = issues.FirstGetTime
				irda.PlanClosedTime = taskhandler.CvePlanCloseTime(issues.CreateTime, issues.CveLevel,false, false)
				if len(issues.CpublicTime) > 10 {
					irda.CvePublicTime = issues.CpublicTime[:10]
				} else {
					irda.CvePublicTime = issues.CpublicTime
				}
				if len(issues.RpmReleaseTime) > 2 {
					irda.RpmPublicTime = issues.RpmReleaseTime
				} else {
					irda.RpmPublicTime = issues.SaReleaseTime
				}
				irda.SaPublicTime = issues.SaReleaseTime
				cid = append(cid, irda)
			}
			resp["body"] = cid
			resp["code"] = errcode.RecodeOk
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
			u.RetCveData(resp)
		} else {
			resp["code"] = errcode.RecodeNodata
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
			u.RetCveData(resp)
			return
		}
	}
}

type KanbanCveAllIssueController struct {
	beego.Controller
}

func (c *KanbanCveAllIssueController) RetCveData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type KanbanCveAllIssueoData struct {
	IssueNum            string  `json:"issue_id"`
	CveNum              string  `json:"CVE_num"`
	OpeneulerScore      float64 `json:"openeuler_score"`
	NvdScore            float64 `json:"NVD_score"`
	Branch              string  `json:"milestone"`
	CveLevel            string  `json:"CVE_level"`
	PlanClosedTime      string  `json:"plan_closed_time"`
	CvePublicTime       string  `json:"CVE_public_time"`
	CveVtopicPublicTime string  `json:"CVE_vtopic_public_time"`
	CveVtopicRecTime    string  `json:"CVE_vtopic_rec_time"`
	RpmPublicTime       string  `json:"rpm_public_time"`
	SaPublicTime        string  `json:"SA_public_time"`
}

// @Title Obtain all cve data and provide operation kanban for use
// @Description get issue
// @Param	pageSize 1,currentPage 10, updatetime nil
// @Success 200 {object} CveAllIssueoData
// @Failure 403 :status is err
// @router / [get]
func (u *KanbanCveAllIssueController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		", Header: ", req.Header, ", body: ", req.Body)
	resp := make(map[string]interface{})
	var cid []CveAllIssueoData
	resp["code"] = errcode.RecodeNodata
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
	resp["body"] = []CveAllIssueoData{}
	resp["total"] = 0
	//defer u.RetCveData(resp)
	communityFlag, flagErr := u.GetInt("communityFlag", 0)
	if flagErr != nil {
		communityFlag = 0
	}
	count := models.QueryCveOrgIssueCount(communityFlag)
	if count > 0 {
		resp["total"] = count
		resp["code"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		currentPage, err := u.GetInt("currentPage", 1)
		if err != nil {
			logs.Error("err: ", err, ", currentPage: ", currentPage)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetCveData(resp)
			return
		}
		pageSize, err := u.GetInt("pageSize", 100)
		if err != nil {
			logs.Error("err: ", err, ", pageSize: ", pageSize)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			u.RetCveData(resp)
			return
		}
		issueData := models.QueryCveOrgIssueData(currentPage, pageSize, communityFlag)
		if len(issueData) > 0 {
			for _, org := range issueData {
				var irda CveAllIssueoData
				irda.CveNum = org.CveNumber
				irda.IssueNum = org.Number
				issues, isErr := models.QueryCveSingleIssueData(communityFlag, org.RepoPath, org.CveNumber, org.Number)
				if isErr != nil {
					cid = append(cid, irda)
				} else {
					irda.OpeneulerScore = issues.OpeneulerScore
					irda.NvdScore = issues.NvdScore
					irda.Branch = issues.AffectedVersion
					if issues.OpeneulerScore >= 0 {
						irda.CveLevel = models.OpenEulerScoreProc(issues.OpeneulerScore)
					}
					irda.CveVtopicPublicTime = issues.FirstPerTime
					irda.CveVtopicRecTime = issues.FirstGetTime
					irda.PlanClosedTime = taskhandler.CvePlanCloseTime(issues.CreateTime, issues.CveLevel,false, false)
					if len(issues.CpublicTime) > 10 {
						irda.CvePublicTime = issues.CpublicTime[:10]
					} else {
						irda.CvePublicTime = issues.CpublicTime
					}
					if len(issues.RpmReleaseTime) > 2 {
						irda.RpmPublicTime = issues.RpmReleaseTime
					} else {
						irda.RpmPublicTime = issues.SaReleaseTime
					}
					irda.SaPublicTime = issues.SaReleaseTime
					cid = append(cid, irda)
				}
			}
			resp["body"] = cid
			resp["code"] = errcode.RecodeOk
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
			u.RetCveData(resp)
		} else {
			resp["code"] = errcode.RecodeNodata
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
			u.RetCveData(resp)
			return
		}
	}
}
