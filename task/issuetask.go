package task

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"errors"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
	"strings"
	"sync"
)

//GetGiteeToken Get Code Cloud API TOKEN
func GetGiteeToken() error {
	defer common.Catchs()
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	clientID := BConfig.String("gitee::client_id")
	if clientID == "" {
		logs.Error("config gitee::clientID error: invalid value is ", clientID)
		return errors.New("value is nil")
	}
	clientSecret := beego.AppConfig.String("gitee::client_secret")
	if clientSecret == "" {
		logs.Error("config gitee::clientSecret error: invalid value is ", clientSecret)
		return errors.New("value is nil")
	}
	Email := BConfig.String("gitee::email")
	if Email == "" {
		logs.Error("config gitee::email error: value is nil")
		return errors.New("value is nil")
	}
	password := BConfig.String("gitee::password")
	if password == "" {
		logs.Error("config gitee::password error: value is nil")
		return errors.New("value is nil")
	}
	Scope := BConfig.String("gitee::scope")
	if Scope == "" {
		logs.Error("config gitee::scope error: value is nil")
		return errors.New("value is nil")
	}
	logs.Info(clientID, clientSecret, password)
	var gt taskhandler.GiteeToken
	gt.GrantType = "password"
	gt.UserName = Email
	gt.Password = password
	gt.ClientID = clientID
	gt.ClientSecret = clientSecret
	gt.Scope = Scope
	taskhandler.GetOautToken(gt)
	return nil
}

// Assemble issue record data
func GenIssueRecordData(icr *models.IssueCreateRecord, issueValue models.VulnCenter, sc models.Score, status int8) {
	icr.CveId = issueValue.CveId
	icr.CveNum = issueValue.CveNum
	icr.Description = issueValue.Description
	icr.CveLevel = issueValue.CveLevel
	icr.Status = status
	icr.CveVersion = issueValue.CveVersion
	icr.RepairTime = issueValue.RepairTime
	icr.PackName = issueValue.PackName
	icr.NVDScore = sc.NVDScore
	icr.NvectorVule = sc.NvectorVule
	icr.CreateTime = common.GetCurTime()
}

var mutex sync.Mutex

func addUnlimitedIssue(beforeTime string, prcnum int, years, toolYears, manYears int) error {
	accessToken := os.Getenv("GITEE_TOKEN")
	if accessToken == "" || len(accessToken) < 1 {
		logs.Error("issue token Get failed, current time: ", common.GetCurTime())
		return errors.New("Failed to get token in environment variable")
	}
	owner := beego.AppConfig.String("gitee::owner")
	path := beego.AppConfig.String("gitee::path")
	for ; ; {
		cveData, err := models.QueryIssue(beforeTime, prcnum)
		if err == nil && len(cveData) > 0 {
			logs.Info(cveData)
		} else {
			logs.Info("No cve data can be used, current time: ", common.GetCurTime(), ", err: ", err)
			return err
		}
		for index, issueValue := range cveData {
			logs.Info("Currently processing：", index, ",cve data, cveNum: ", issueValue.CveNum)
			// add mutex
			lockErr := models.LockUpdateIssueStatus(issueValue.CveId, issueValue.CveNum, 15)
			if !lockErr {
				logs.Error("The current cve is processing, continue to process the next data, err: ", lockErr, ",data: ", issueValue)
				continue
			}
			se := models.SpecError{CveNum: issueValue.CveNum, Owner: owner, PackName: issueValue.PackName, Status: 1}
			seError := models.GetIssueSpecErrByColName(&se, "CveNum", "Owner", "PackName", "Status")
			if seError == nil && se.Id > 0 {
				models.UpdateIssueStatus(issueValue, 5)
				logs.Info("The current issue does not need to be processed, it has been processed, cveData: ", issueValue)
				continue
			}
			// Determine whether the issue has been processed
			goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
			if oks {
				if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
					goi.State == "已完成" || goi.State == "已拒绝" {
					models.UpdateIssueStatus(issueValue, 2)
					logs.Info("The cve data has already been submitted to the issue, no need to submit repeatedly, cveData: ", issueValue)
					continue
				}
			}
			// Import cve as data after 2018
			cveNumList := strings.Split(issueValue.CveNum, "-")
			if cveNumList != nil && len(cveNumList) > 1 {
				cveYears, yearErr := strconv.Atoi(cveNumList[1])
				if yearErr == nil {
					if issueValue.DataSource == 1 {
						years = toolYears
					} else if issueValue.DataSource == 3 {
						years = manYears
					}
					if cveYears <= years {
						icr := models.IssueCreateRecord{}
						models.UpdateIssueStatus(issueValue, 4)
						logs.Info("cve: ", issueValue.CveNum, ",Need to be greater than： ",
							years, ",Otherwise, there is no need to submit an issue on git, cveData: ", issueValue)
						sc, err := models.QueryIssueScore(issueValue.CveId)
						if err != nil || sc.Id == 0 {
							logs.Error("Failed to get Score, err: ", err, "cveId: ", issueValue.CveId)
							continue
						}
						GenIssueRecordData(&icr, issueValue, sc, 2)
						issueRecordId, issReErr := models.CreateIssueRecord(&icr)
						if issReErr == nil && issueRecordId > 0 {
							logs.Info("Issue record data created successfully, id:", issueRecordId)
						} else {
							logs.Error("Failed to create issue record data, err: ", issReErr)
						}
						continue
					}
				}
			}
			// Determine whether cve has been processed
			issueExist := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
			if issueExist {
				models.UpdateIssueStatus(issueValue, 2)
				logs.Info("The cve data has been displayed on the official website, " +
					"no need to submit an issue on git, cveData: ", issueValue)
				continue
			}
			// Process each piece of cve data
			if issueValue.Status == 0 {
				issueValue.Status = 2
				mutex.Lock()
				err := ProcIssue(issueValue, accessToken, owner, path)
				mutex.Unlock()
				if err != nil {
					logs.Error("Failed to create issue, cvenum: ", issueValue.CveNum, "err,err: ", err)
					continue
				}
			} else {
				issueValue.Status = 2
				mutex.Lock()
				err := ProcUpdateIssue(issueValue, accessToken, owner, path)
				mutex.Unlock()
				if err != nil {
					logs.Error("Failed to update issue, cvenum: ", issueValue.CveNum, "err,err: ", err)
					continue
				}
			}
			// Collect issue record data
			icr := models.IssueCreateRecord{}
			sc, err := models.QueryIssueScore(issueValue.CveId)
			if err != nil || sc.Id == 0 {
				logs.Error("Failed to get Score, err: ", err, "cveId: ", issueValue.CveId)
				continue
			}
			GenIssueRecordData(&icr, issueValue, sc, 1)
			issueRecordId, issReErr := models.CreateIssueRecord(&icr)
			if issReErr == nil && issueRecordId > 0 {
				logs.Info("Issue record data created successfully, id:", issueRecordId)
			} else {
				logs.Error("Failed to create issue record data, err: ", issReErr)
			}
		}
	}
}

func addLimitedIssue(beforeTime string, prcnum int, years, toolYears, manYears int) error {
	accessToken := os.Getenv("GITEE_TOKEN")
	if accessToken == "" || len(accessToken) < 1 {
		logs.Error("issue token 获取失败, 当前时间: ", common.GetCurTime())
		return errors.New("Failed to get token in environment variable")
	}
	owner := beego.AppConfig.String("gitee::owner")
	path := beego.AppConfig.String("gitee::path")
	issueWhiteData, issueErr := models.QueryIssueWhitelist(0)
	if issueErr == nil && len(issueWhiteData) > 0 {
		for _, issues := range issueWhiteData {
			if issues.Status == 2 {
				logs.Error("Removed from whitelist, repo: ", issues.PackageName)
				continue
			}
			for ; ; {
				cveData, err := models.QueryIssueByPackName(issues.PackageName, beforeTime, prcnum)
				if err == nil && len(cveData) > 0 {
					logs.Info(cveData)
				} else {
					logs.Info("无cve数据可以使用, 当前时间: ", common.GetCurTime(), ", err: ", err)
					break
				}
				for index, issueValue := range cveData {
					logs.Info("当前正在处理第：", index, "条cve数据, cveNum: ", issueValue.CveNum)
					// add mutex
					lockErr := models.LockUpdateIssueStatus(issueValue.CveId, issueValue.CveNum, 15)
					if !lockErr {
						logs.Error("The current cve is processing, continue to process the next data, err: ", lockErr, ",data: ", issueValue)
						continue
					}
					se := models.SpecError{CveNum: issueValue.CveNum, Owner: owner, PackName: issueValue.PackName, Status: 1}
					seError := models.GetIssueSpecErrByColName(&se, "CveNum", "Owner", "PackName", "Status")
					if seError == nil && se.Id > 0 {
						models.UpdateIssueStatus(issueValue, 5)
						logs.Info("The current issue does not need to be processed, it has been processed, cveData: ", issueValue)
						continue
					}
					// Determine whether the issue has been processed
					goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
					if oks {
						if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
							goi.State == "已完成" || goi.State == "已拒绝" {
							models.UpdateIssueStatus(issueValue, 2)
							logs.Info("cve数据已经已经提交过issue,不需要重复提交, cveData: ", issueValue)
							continue
						}
					}
					// Import cve as data after 2018
					cveNumList := strings.Split(issueValue.CveNum, "-")
					if cveNumList != nil && len(cveNumList) > 1 {
						cveYears, yearErr := strconv.Atoi(cveNumList[1])
						if yearErr == nil {
							if issueValue.DataSource == 1 {
								years = toolYears
							} else if issueValue.DataSource == 3 {
								years = manYears
							}
							if cveYears <= years {
								icr := models.IssueCreateRecord{}
								models.UpdateIssueStatus(issueValue, 4)
								logs.Info("cve: ", issueValue.CveNum, ",需要大于： ",
									years, ",否则不需要在git上提交issue, cveData: ", issueValue)
								sc, err := models.QueryIssueScore(issueValue.CveId)
								if err != nil || sc.Id == 0 {
									logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
									continue
								}
								GenIssueRecordData(&icr, issueValue, sc, 2)
								issueRecordId, issReErr := models.CreateIssueRecord(&icr)
								if issReErr == nil && issueRecordId > 0 {
									logs.Info("Issue record data created successfully, id:", issueRecordId)
								} else {
									logs.Error("Failed to create issue record data, err: ", issReErr)
								}
								continue
							}
						}
					}
					// Determine whether cve has been processed
					issueExist := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
					if issueExist {
						models.UpdateIssueStatus(issueValue, 2)
						logs.Info("cve数据已经在官网上展示过,不需要在git上提交issue, cveData: ", issueValue)
						continue
					}
					// Process each piece of cve data
					if issueValue.Status == 0 {
						mutex.Lock()
						err := ProcIssue(issueValue, accessToken, owner, path)
						mutex.Unlock()
						if err != nil {
							logs.Error("创建issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
							continue
						}
					} else {
						mutex.Lock()
						err := ProcUpdateIssue(issueValue, accessToken, owner, path)
						mutex.Unlock()
						if err != nil {
							logs.Error("修改issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
							continue
						}
					}
					// Collect issue record data
					icr := models.IssueCreateRecord{}
					sc, err := models.QueryIssueScore(issueValue.CveId)
					if err != nil || sc.Id == 0 {
						logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
						continue
					}
					GenIssueRecordData(&icr, issueValue, sc, 1)
					issueRecordId, issReErr := models.CreateIssueRecord(&icr)
					if issReErr == nil && issueRecordId > 0 {
						logs.Info("Issue record data created successfully, id:", issueRecordId)
					} else {
						logs.Error("Failed to create issue record data, err: ", issReErr)
					}
				}
			}
		}
	} else {
		logs.Error(issueErr)
		return issueErr
	}
	return nil
}

//CreateIssue Create issue
func CreateIssue() error {
	defer common.Catchs()
	logs.Info("执行创建issue task start")
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	days, ok := BConfig.Int("crontab::days")
	if ok != nil {
		logs.Error("config crontab::days error:", ok)
		return ok
	}
	years, ok := BConfig.Int("cve::cve_number")
	if ok != nil {
		logs.Error("config cve::years error:", ok)
		return ok
	}
	manYears, ok := BConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("config cve::manYears error:", ok)
		return ok
	}
	toolYears, ok := BConfig.Int("cve::cve_number_t")
	if ok != nil {
		logs.Error("config cve::toolYears error:", ok)
		return ok
	}
	prcnum, ok := BConfig.Int("crontab::prcnum")
	if ok != nil {
		logs.Error("config crontab::prcnum error:", ok)
		return ok
	}
	issueWhitelist, ok := BConfig.Int("cve::issue_whitelist")
	if ok != nil {
		logs.Error("config cve::issue_whitelist error: ", ok)
		return ok
	}
	beforeTime := common.GetBeforeTime(days)
	if issueWhitelist == 1 {
		limitErr := addLimitedIssue(beforeTime, prcnum, years, toolYears, manYears)
		logs.Info("addLimitedIssue, err: ", limitErr)
		logs.Info("执行创建issue task end")
		return limitErr
	} else {
		unlimitErr := addUnlimitedIssue(beforeTime, prcnum, years, toolYears, manYears)
		logs.Info("addUnlimitedIssue, err: ", unlimitErr)
		logs.Info("执行创建issue task end")
		return unlimitErr
	}
}

//ProcUpdateIssue Update issue
func ProcUpdateIssue(issueValue models.VulnCenter, accessToken, owner, path string) error {
	// Query and modify score
	sr, err := models.QueryIssueScoreRecord(issueValue.CveId, 0)
	if err != nil {
		logs.Error("查询 评分记录失败, cveId: ", issueValue.CveId, "err: ", err)
		return err
	}
	// Query issue template
	var it models.IssueTemplate
	it.CveId = issueValue.CveId
	templateErr := models.GetIssueTemplateByColName(&it, "cve_id")
	if templateErr == nil && it.TemplateId > 0 {
		it.NVDScore = sr.NVDScore
		it.NVDVector = sr.NvectorVule
		it.CveBrief = issueValue.Description
		it.CveLevel = issueValue.CveLevel
		if it.Assignee == "" || len(it.Assignee) < 2 {
			repoMainTainer, ok := models.QueryRepoMaintainer(issueValue.PackName)
			if !ok || repoMainTainer == "" || len(repoMainTainer) < 1 {
				assignee, assErr := taskhandler.GetCollaboratorInfo(accessToken, owner, path)
				if assignee != "" && len(assignee) > 1 {
					it.Assignee = assignee
					//return err
				} else {
					logs.Error("获取仓库： owner:", owner, "path:", path, "分析人失败", "assErr:", assErr,
						", cveid: ", issueValue.CveId, ",创建无maintainer的issue")
				}
			} else {
				it.Assignee = repoMainTainer
			}
		}
		path = it.Repo
		_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path,
			issueValue, it)
		if err != nil {
			logs.Error("更新issue 模板失败， cveId: ", issueValue.CveId, "err: ", err)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 3)
			return err
		}
		// Update issue status
		models.UpdateIssueStatus(issueValue, 2)
		// Update score status
		models.UpdateIssueScore(issueValue, 2)
		templetID, err := models.CreateIssueTemplate(&it)
		if err != nil {
			logs.Error("修改issue模板失败, cveId: ", issueValue.CveId, "err: ", err)
			return err
		}
		models.UpdateIssueScoreRe(issueValue, 1)
		logs.Info("更新issue模板成功，cveId: ", issueValue.CveId, "templetID: ", templetID)
	}
	return nil
}

//ProcIssue Deal with issue
func ProcIssue(issueValue models.VulnCenter, accessToken, owner, path string) error {
	assignee := ""
	brandArry := []string{}
	sn, err := models.QueryIssueSecurity(issueValue.CveId)
	if err == nil && len(sn.CveNum) > 0 {
		path = issueValue.PackName
		logs.Info("查询安全信息：sn: ", sn)
		// Get issue handler
		repoMainTainer, ok := models.QueryRepoMaintainer(issueValue.PackName)
		if !ok || repoMainTainer == "" || len(repoMainTainer) < 1 {
			assignee, err = taskhandler.GetCollaboratorInfo(accessToken, owner, path)
			if assignee == "" {
				logs.Error("获取仓库： owner:", owner, "path:", path, "分析人失败", "err:", err,
					"cveid: ", issueValue.CveId, ",创建无maintainer的issue")
				//return err
			}
		} else {
			assignee = repoMainTainer
		}
	} else {
		logs.Error("获取security 失败, err: ", err, "cveId: ", issueValue.CveId)
		return err
	}
	sc, err := models.QueryIssueScore(issueValue.CveId)
	if err != nil {
		logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
		return err
	}
	branchList := []string{}
	errBrands := errors.New("")
	// Get branch information
	branchList, errBrands = taskhandler.GetBranchesInfo(accessToken, owner, path)
	if branchList == nil || len(branchList) == 0 {
		logs.Error("获取分支信息失败,CveNum: ", issueValue.CveNum, "path: ", path, ", err: ", errBrands)
	}
	if len(branchList) > 0 {
		brandArry = []string{}
		for _, branch := range branchList {
			brandArry = append(brandArry, branch)
		}
	}
	resp, err := taskhandler.CreateIssueToGit(accessToken, owner, path, assignee, issueValue, sc, brandArry)
	if err != nil {
		logs.Error("创建issue失败, err: ", err, "resp: ", resp, "cveId: ", issueValue.CveId)
		// Update issue status
		models.UpdateIssueStatus(issueValue, 3)
		return err
	}
	return nil
}
