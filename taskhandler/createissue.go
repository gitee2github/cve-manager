package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
)

func CreateIssueData(issueTemp *models.IssueTemplate, cve models.VulnCenter, sc models.Score, resp map[string]interface{},
	path, assignee, issueType, labels, owner string) *models.IssueTemplate {
	issueTemp.CveId = cve.CveId
	issueTemp.CveNum = cve.CveNum
	issueTemp.OwnedComponent = path
	issueTemp.OwnedVersion = cve.CveVersion
	issueTemp.NVDScore = sc.NVDScore
	issueTemp.NVDVector = sc.NvectorVule
	issueTemp.CveBrief = cve.Description
	issueTemp.CveLevel = cve.CveLevel
	issueTemp.IssueId = int64(resp["id"].(float64))
	issueTemp.IssueNum = resp["number"].(string)
	issueTemp.Assignee = assignee
	issueTemp.StatusName = resp["state"].(string)
	if resp["state"].(string) == "Open" {
		issueTemp.Status = 1
	} else if resp["state"].(string) == "Started" {
		issueTemp.Status = 2
	} else if resp["state"].(string) == "Closed" {
		issueTemp.Status = 3
	} else {
		issueTemp.Status = 4
	}
	issueTemp.IssueStatus = 1
	issueTemp.IssueLabel = labels
	issueTemp.Owner = owner
	issueTemp.Repo = path
	issueTemp.Title = cve.CveNum
	issueTemp.IssueType = issueType
	issueTemp.Collaborators = ""
	issueTemp.Milestone = ""
	issueTemp.Program = ""
	issueTemp.SecurityHole = 0
	logs.Info("组装issue,模板数据存入db: ", issueTemp)
	return issueTemp
}

func CreateIssueToGit(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score) (string, error) {
	defer common.Catchs()
	var it models.IssueTemplate
	it.CveId = cve.CveId
	its, err := models.GetIssueTemplet(&it)
	if err && its.IssueNum != "" && len(its.IssueNum) > 0 {
		if its.Assignee == "" || len(its.Assignee) == 0 {
			its.Assignee = assignee
		}
		issueType := its.IssueType
		labels := its.IssueLabel
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + its.IssueNum
			score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
			OpenEulerScore := strconv.FormatFloat(its.OpenEulerScore, 'f', 1, 64)
			requestBody := CreateIssueBody(accessToken, owner, path, its.Assignee,
				cve, sc, OpenEulerScore, score, labels, its, 1, its.IssueType, "")
			logs.Info("isssue_body: ", requestBody)
			resp, err := util.HttpPatch(url, requestBody)
			if err != nil {
				logs.Error("创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建issue 失败, err: ", ok, "url: ", url)
				return "", errors.New("创建issue失败")
			}
			logs.Info("issue 创建成功，cveNum: ", cve.CveNum, "issueNum: ", resp["number"].(string))
			// 构建数据
			var issueTemp models.IssueTemplate
			CreateIssueData(&issueTemp, cve, sc, resp, path, its.Assignee, issueType, labels, owner)
			// 存储issue数据
			issTempId, err := models.CreateIssueTemplet(&issueTemp)
			if err != nil {
				logs.Error("创建issue 模板的数据失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cve.CveNum)
			}
			// 构建回调
			//err = CreateIssueHooks(accessToken, owner, path, cve, resp)
			//if err != nil {
			//	logs.Error("创建hooks 失败, cveNum: ", cve.CveNum, "err: ", err)
			//	return "", err
			//} else {
			//	logs.Info("创建hooks 成功, cveNum: ", cve.CveNum)
			//}
			//CreateIssueLabel(accessToken, owner, path, resp["number"].(string))
			// 更新issue状态
			models.UpdateIssueStatus(cve, 2)
			// 更新分数状态
			models.UpdateIssueScore(cve, 2)
			// 更新分数记录状态
			models.UpdateIssueScoreRe(cve, 1)
		}
	} else {
		issueType := "CVE和安全问题"
		//labels := "CVE/Bug,CVE/Undisclosed,CVE/Disclosed"
		labels := "CVE/Undisclosed"
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/issues"
			score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
			requestBody := CreateIssueBody(accessToken, owner, path, assignee,
				cve, sc, "", score, labels, its, 2, issueType, "")
			logs.Info("isssue_body: ", requestBody)
			resp, err := util.HttpPost(url, requestBody)
			if err != nil {
				logs.Error("创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建issue 失败, err: ", ok, "url: ", url)
				return "", errors.New("创建issue失败")
			}
			// 构建数据
			var issueTemp models.IssueTemplate
			CreateIssueData(&issueTemp, cve, sc, resp, path, assignee, issueType, labels, owner)
			// 存储issue数据
			issTempId, err := models.CreateIssueTemplet(&issueTemp)
			if err != nil {
				logs.Error("创建issue 模板的数据失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建issue 模板的数据成功, issTempId: ", issTempId, "cveNum: ", cve.CveNum)
			}
			// 创建issue评论
			errx := CreateIssueComment(accessToken, owner, path, assignee, cve, resp)
			logs.Info("issue评论创建结果, err: ", errx)
			// 构建回调
			err = CreateDepositHooks(accessToken, owner, path, cve, resp)
			if err != nil {
				logs.Error("创建hooks 失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			} else {
				logs.Info("创建hooks 成功, cveNum: ", cve.CveNum)
			}
			// 创建issue标签
			//CreateIssueLabel(accessToken, owner, path, resp["number"].(string))
			// 更新issue状态
			models.UpdateIssueStatus(cve, 2)
			// 更新分数状态
			models.UpdateIssueScore(cve, 2)
			// 更新分数记录状态
			models.UpdateIssueScoreRe(cve, 1)
		}
	}
	return "", nil
}

func UpdateIssueToGit(accessToken string, owner string, path string,
	cve models.VulnCenter, its models.IssueTemplate) (string, error) {
	//issueType := its.IssueType
	labels := its.IssueLabel
	pkgList, err := models.QueryPackageByCveId(its.CveId)
	pkgLink := ""
	if err == nil && len(pkgList) > 0 {
		for _, p := range pkgList {
			pkgLink = pkgLink + fmt.Sprintf(`[%v](%v)\r\n`, p.PackName, p.PackUrl)
		}
	}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + its.IssueNum
		score := strconv.FormatFloat(its.NVDScore, 'f', 1, 64)
		OpenEulerScore := strconv.FormatFloat(its.OpenEulerScore, 'f', 1, 64)
		var sc models.Score
		requestBody := CreateIssueBody(accessToken, owner, path, its.Assignee,
			cve, sc, OpenEulerScore, score, labels, its, 3, its.IssueType, pkgLink)
		logs.Info("isssue_body: ", requestBody)
		resp, err := util.HttpPatch(url, requestBody)
		if err != nil {
			logs.Error("更新issue失败, cveNum: ", cve.CveNum, "err: ", err)
			return "", err
		}
		if _, ok := resp["id"]; !ok {
			logs.Error("创建issue 失败, err: ", ok, "url: ", url)
			return "", errors.New("创建issue失败")
		}
	}
	return "", nil
}

func CreateIssueHookData(issHook *models.IssueHooks, cve models.VulnCenter, resp map[string]interface{},
	path, owner string, issresp map[string]interface{}) *models.IssueHooks {
	issHook.CveId = cve.CveId
	issHook.IssueId = int64(issresp["id"].(float64))
	issHook.IssueNum = issresp["number"].(string)
	issHook.HookId = int64(resp["id"].(float64))
	issHook.Owner = owner
	issHook.Repo = path
	issHook.HookUrl = resp["url"].(string)
	if resp["push_events"].(bool) == true {
		issHook.PushEvent = 1
	} else {
		issHook.PushEvent = 0
	}
	if resp["tag_push_events"].(bool) == true {
		issHook.TagPushEvent = 1
	} else {
		issHook.TagPushEvent = 0
	}
	if resp["issues_events"].(bool) == true {
		issHook.IssueEvent = 1
	} else {
		issHook.IssueEvent = 0
	}
	if resp["note_events"].(bool) == true {
		issHook.NoteEvent = 1
	} else {
		issHook.NoteEvent = 0
	}
	if resp["merge_requests_events"].(bool) == true {
		issHook.MergeRequestEvent = 1
	} else {
		issHook.MergeRequestEvent = 0
	}
	return issHook
}

func CreateDepositHooks(accessToken string, owner string, path string,
	cve models.VulnCenter, issResp map[string]interface{}) error {
	var ih models.IssueHooks
	ih.CveId = cve.CveId
	ih.IssueNum = issResp["number"].(string)
	ihs, err := models.GetIssueHook(&ih)
	if err {
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks/" + strconv.Itoa(int(ihs.HookId))
			BConfig, err := config.NewConfig("ini", "conf/app.conf")
			if err != nil {
				logs.Error("config init error:", err)
				return err
			}
			pwd := os.Getenv("hookpwd")
			hookurl := BConfig.String("hook::hookurl")
			push_events := "true"
			tag_push_events := "true"
			issues_events := "true"
			note_events := "true"
			merge_requests_events := "true"
			requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
			logs.Info("hook_body: ", requestBody)
			resp, err := util.HttpPatch(url, requestBody)
			if err != nil {
				logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
				return err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建仓库 hook失败, err: ", ok, "url: ", url)
				return errors.New("创建仓库 hook失败")
			}
			// 构建数据
			if resp["password"].(string) == pwd {
				var issHook models.IssueHooks
				CreateIssueHookData(&issHook, cve, resp,
					path, owner, issResp)
				// 存储issue数据
				hookId, err := models.CreateDepositHooks(&issHook)
				if err != nil {
					logs.Error("创建仓库 hook数据失败, cveNum: ", cve.CveNum, "err: ", err)
					return err
				} else {
					logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
				}
			}
		}
	} else {
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks"
			BConfig, err := config.NewConfig("ini", "conf/app.conf")
			if err != nil {
				logs.Error("config init error:", err)
				return err
			}
			pwd := BConfig.String("hook::pwd")
			hookurl := BConfig.String("hook::hookurl")
			push_events := "true"
			tag_push_events := "true"
			issues_events := "true"
			note_events := "true"
			merge_requests_events := "true"
			requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
			logs.Info("hook_body: ", requestBody)
			resp, err := util.HttpPost(url, requestBody)
			if err != nil {
				logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
				return err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建仓库hook失败, err: ", ok, "url: ", url)
				return errors.New("创建仓库hook失败")
			}
			// 构建数据
			if resp["password"].(string) == pwd {
				var issHook models.IssueHooks
				CreateIssueHookData(&issHook, cve, resp,
					path, owner, issResp)
				// 存储issue数据
				hookId, err := models.CreateDepositHooks(&issHook)
				if err != nil {
					logs.Error("创建仓库hook失败, cveNum: ", cve.CveNum, "err: ", err)
					return err
				} else {
					logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
				}
			}
		}
	}
	return nil
}

func CreateIssueComment(accessToken, owner, path, Assignee string,
	cve models.VulnCenter, issResp map[string]interface{}) error {
	issueNum := issResp["number"].(string)
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issueNum + "/comments"
		BConfig, err := config.NewConfig("ini", "conf/app.conf")
		if err != nil {
			logs.Error("config init error:", err)
			return err
		}
		commentCmd := BConfig.String("reflink::comment_cmd")
		commentBody := "Hey @" + Assignee + " , Please complete the content of the issue template in the issue comment. Please refer to the format:" +
			commentCmd
		requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"body": "%s"
			}`, accessToken, commentBody)
		logs.Info("create issue comment body: ", requestBody)
		resp, err := util.HttpPost(url, requestBody)
		if err != nil {
			logs.Error("创建issue评论失败, url: ", url, "cveId", cve.CveId, ",issueNum: ", issueNum, ",err: ", err)
			return err
		}
		if _, ok := resp["id"]; !ok {
			logs.Error("创建issue评论失败, err: ", ok, "url: ", url)
			return errors.New("创建issue评论失败")
		}
		commentId := int64(resp["id"].(float64))
		models.UpdateIssueCommentId(issueNum, cve.CveNum, commentId)
	}
	return nil
}

func CreateSecNoticeData(sec *models.SecurityNotice, iss models.VulnCenter, path, branchs string) {
	sec.CveId = iss.CveId
	sec.CveNum = iss.CveNum
	sec.Introduction = "An update for " + path + " is now available for " + branchs
	sec.Summary = "An update for " + path + " is now available for " + branchs
	sec.Theme = sec.Introduction + ";\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of medium. A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = branchs
}

func CreateIssueLabel(accessToken string, owner string, path string,
	issNum string) error {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issNum + "/labels"
		//label := []string{"CVE/Undisclosed","CVE/Disclosed"}
		//reqs ,err:= json.Marshal(&requestBody)
		//if err != nil {
		//	return err
		//}
		//requestBody := fmt.Sprintf(`{
		//	"access_token": "%s",
		//	"body": ["CVE/Undisclosed","CVE/Disclosed"]
		//	}`, accessToken)
		body := make(map[string]interface{})
		body["access_token"] = accessToken
		body["body"] = "[\"CVE/Undisclosed\",\"CVE/Disclosed\"]"
		requestBody, _ := json.Marshal(body)
		logs.Info("create issue label: ", string(requestBody))
		resp, err := util.HttpPost1(url, string(requestBody))
		if err != nil {
			logs.Error("cve标签创建失败, url: ", url, "requestBody: ", requestBody, "err: ", err)
			return err
		}
		for _, value := range resp {
			if _, ok := value["id"]; !ok {
				logs.Error("创建issue 标签失败, err: ", ok, "url: ", url)
				return errors.New("创建issue标签失败")
			}
		}
		logs.Info("issue 标签创建成功, resp: ", resp)
	}
	return nil
}
