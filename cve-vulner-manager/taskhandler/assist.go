package taskhandler

import (
	"cvevulner/common"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"os"
	"sort"
	"strings"
)

func GetOautToken(gt GiteeToken) {
	url := "https://gitee.com/oauth/token"
	var req util.RequestInfo
	req.URL = url
	req.Data = make(map[string]string)
	req.Data["grant_type"] = gt.GrantType
	req.Data["username"] = gt.UserName
	req.Data["password"] = gt.Password
	req.Data["client_id"] = gt.ClientID
	req.Data["client_secret"] = gt.ClientSecret
	req.Data["scope"] = gt.Scope
	resp, err := util.PostURLEncoded(req)
	if err != nil {
		logs.Error("Failed to obtain token,url: ", url,
			",Request parameter: ", gt, ", err:", err)
		return
	}
	var respDict map[string]interface{}
	err = json.Unmarshal(resp, &respDict)
	if err != nil {
		logs.Error(err)
		return
	}
	if _, ok := respDict["access_token"]; !ok {
		logs.Error("Failed to obtain token, err: ", ok, ", url: ", url)
		return
	}
	GitToken := respDict["access_token"].(string)
	os.Setenv("GITEE_TOKEN", GitToken)
}

func GetCollaboratorInfo(accessToken string, owner string, path string) (string, error) {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/collaborators?access_token=" + accessToken
		collabor, err := util.HTTPGet(url)
		if err == nil && collabor != nil {
			for _, value := range collabor {
				if _, ok := value["id"]; !ok {
					logs.Error("collaborators, err: ", ok, "url: ", url)
					continue
				}
				assignee := ""
				for mapKey, mapValue := range value {
					if mapKey == "login" {
						assignee = mapValue.(string)
					}
				}
				if assignee != "" {
					return assignee, nil
				}
			}
		} else {
			logs.Error("Failed to obtain repo owner, owner:", owner, ",path:", path, ",err: ", err)
			return "", err
		}
	}
	return "", errors.New("参数错误")
}

func GetBranchesInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	BrandVerSlice := make([]string, 0)
	if organizationID == 4 {
		openlookengVersion := beego.AppConfig.String("openlookeng::openlookeng_version")
		if len(openlookengVersion) > 0 {
			BrandVerSlice = strings.Split(openlookengVersion, ",")
		}
	} else if organizationID == 3 {
		mindsporeVersion := beego.AppConfig.String("mindspore::mindspore_version")
		if len(mindsporeVersion) > 0 {
			BrandVerSlice = strings.Split(mindsporeVersion, ",")
		}
	} else if organizationID == 2 {
		gaussVersion := beego.AppConfig.String("opengauss::gauss_version")
		if len(gaussVersion) > 0 {
			BrandVerSlice = strings.Split(gaussVersion, ",")
		}
		path = beego.AppConfig.String("opengauss::openGauss-server")
	} else {
		eulerVersion := beego.AppConfig.String("cve::affected_branchs")
		if len(eulerVersion) > 0 {
			BrandVerSlice = strings.Split(eulerVersion, ",")
		}
	}
	branchNameList := []string{}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/branches?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("branches, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					if organizationID == 2 {
						if !common.IsContainsLetters(mapValue) {
							branchNameList = append(branchNameList, mapValue)
						}
					} else if organizationID == 3 {
						if common.IsContainSpecialChar(mapValue, 1) {
							branchNameList = append(branchNameList, mapValue)
						}
					} else if organizationID == 4 {
						if !common.IsContainsLetters(mapValue) {
							branchNameList = append(branchNameList, mapValue)
						}
					} else {
						for _, gv := range BrandVerSlice {
							if gv == mapValue {
								branchNameList = append(branchNameList, mapValue)
							}
						}
					}
				}
			}
		} else {
			logs.Error("Failed to get branch name, "+
				"err: ", err, ",owner: ", owner, ",path: ", path)
			if organizationID != 1 {
				logs.Info("1.Obtained branch information: ", BrandVerSlice)
				return BrandVerSlice, err
			}
			logs.Info("2.Obtained branch information: ", branchNameList)
			return branchNameList, err
		}
	}
	if len(branchNameList) > 0 {
		sort.Strings(branchNameList)
	}
	if organizationID == 2 {
		if len(branchNameList) > 2 {
			branchNameList = branchNameList[len(branchNameList)-2:]
		}
	} else if organizationID == 3 {
		if len(branchNameList) > 4 {
			branchNameList = branchNameList[len(branchNameList)-4:]
		}
	} else if organizationID == 4 {
		if len(branchNameList) > 1 {
			branchNameList = branchNameList[len(branchNameList)-1:]
		}
	}
	if len(BrandVerSlice) > 0 {
		branchNameList = append(branchNameList, BrandVerSlice...)
	}
	branchNameList = common.RemoveDupString(branchNameList)
	logs.Info("3.Obtained branch information: ", branchNameList)
	return branchNameList, nil
}

func GetTagsInfo(accessToken, owner, path string, organizationID int8) ([]string, error) {
	tagsList := []string{}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/tags?access_token=" + accessToken
		branch, err := util.HTTPGet(url)
		if err == nil && branch != nil {
			for _, value := range branch {
				if _, ok := value["name"]; !ok {
					logs.Error("tagsInfo, err: ", ok, "url: ", url)
					continue
				}
				mapValue := value["name"].(string)
				if mapValue != "" && len(mapValue) > 1 {
					if organizationID == 4 {
						if !common.IsContainsLetters(mapValue) {
							tagsList = append(tagsList, mapValue)
						}
					} else {
						if common.IsContainSpecialChar(mapValue, 2) {
							tagsList = append(tagsList, mapValue)
						}
					}
				}
			}
		} else {
			logs.Error("Failed to get tags name, "+
				"err: ", err, ",owner: ", owner, ",path: ", path)
			return tagsList, err
		}
	}
	if len(tagsList) > 0 {
		sort.Strings(tagsList)
	}
	if organizationID == 3 {
		if len(tagsList) > 4 {
			tagsList = tagsList[len(tagsList)-4:]
		}
	} else if organizationID == 4 {
		if len(tagsList) > 1 {
			tagsList = tagsList[len(tagsList)-1:]
		}
	}
	logs.Info("GetTagsInfo, tagsList:", tagsList)
	return tagsList, nil
}
