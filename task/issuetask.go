package task

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"errors"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"os"
	"strconv"
	"strings"
)

//GetGiteeToken Get Code Cloud API TOKEN
func GetGiteeToken() error {
	defer common.Catchs()
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	clientID := BConfig.String("gitee::client_id")
	if clientID == "" {
		logs.Error("config gitee::clientID error: invalid value is ", clientID)
		return errors.New("value is nil")
	}
	clientSecret := beego.AppConfig.String("gitee::client_secret")
	if clientSecret == "" {
		logs.Error("config gitee::clientSecret error: invalid value is ", clientSecret)
		return errors.New("value is nil")
	}
	Email := BConfig.String("gitee::email")
	if Email == "" {
		logs.Error("config gitee::email error: value is nil")
		return errors.New("value is nil")
	}
	password := BConfig.String("gitee::password")
	if password == "" {
		logs.Error("config gitee::password error: value is nil")
		return errors.New("value is nil")
	}
	Scope := BConfig.String("gitee::scope")
	if Scope == "" {
		logs.Error("config gitee::scope error: value is nil")
		return errors.New("value is nil")
	}
	logs.Info(clientID, clientSecret, password)
	var gt taskhandler.GiteeToken
	gt.GrantType = "password"
	gt.UserName = Email
	gt.Password = password
	gt.ClientID = clientID
	gt.ClientSecret = clientSecret
	gt.Scope = Scope
	taskhandler.GetOautToken(gt)
	return nil
}

// Assemble issue record data
func GenIssueRecordData(icr *models.IssueCreateRecord, issueValue models.VulnCenter, sc models.Score, status int8) {
	icr.CveId = issueValue.CveId
	icr.CveNum = issueValue.CveNum
	icr.Description = issueValue.Description
	icr.CveLevel = issueValue.CveLevel
	icr.Status = status
	icr.CveVersion = issueValue.CveVersion
	icr.RepairTime = issueValue.RepairTime
	icr.PackName = issueValue.PackName
	icr.NVDScore = sc.NVDScore
	icr.NvectorVule = sc.NvectorVule
	icr.CreateTime = common.GetCurTime()
}

//CreateIssue Create issue
func CreateIssue() error {
	defer common.Catchs()
	// Query the cve to be processed, 1: add; 2: modify
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	days, ok := BConfig.Int("crontab::days")
	if ok != nil {
		logs.Error("config crontab::days error:", ok)
		return ok
	}
	years, ok := BConfig.Int("cve::cve_number")
	if ok != nil {
		logs.Error("config cve::years error:", ok)
		return ok
	}
	manYears, ok := BConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("config cve::manYears error:", ok)
		return ok
	}
	toolYears, ok := BConfig.Int("cve::cve_number_t")
	if ok != nil {
		logs.Error("config cve::toolYears error:", ok)
		return ok
	}
	prcnum, ok := BConfig.Int("crontab::prcnum")
	if ok != nil {
		logs.Error("config crontab::prcnum error:", ok)
		return ok
	}
	issueWhitelist, ok := BConfig.Int("cve::issue_whitelist")
	if ok != nil {
		logs.Error("config cve::issue_whitelist error: ", ok)
		return ok
	}
	beforeTime := common.GetBeforeTime(days)
	if issueWhitelist == 1 {
		issueWhiteData, issueErr := models.QueryIssueWhitelist(1)
		if issueErr == nil && len(issueWhiteData) > 0 {
			for _, issues := range issueWhiteData {
				for ; ; {
					cveData, err := models.QueryIssueByPackName(issues.PackageName, beforeTime, prcnum)
					if err == nil && len(cveData) > 0 {
						logs.Info(cveData)
					} else {
						logs.Info("无cve数据可以使用, 当前时间: ", common.GetCurTime(), ", err: ", err)
						break
					}
					accessToken := os.Getenv("GITEE_TOKEN")
					if accessToken == "" || len(accessToken) < 1 {
						logs.Error("issue token 获取失败, 当前时间: ", common.GetCurTime(), ",err: ", err)
						break
					}
					owner := BConfig.String("gitee::owner")
					path := BConfig.String("gitee::path")
					for index, issueValue := range cveData {
						logs.Info("当前正在处理第：", index, "条cve数据, cveNum: ", issueValue.CveNum)
						// Determine whether the issue has been processed
						goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
						if oks {
							if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
								goi.State == "已完成" || goi.State == "已拒绝" {
								models.UpdateIssueStatus(issueValue, 2)
								logs.Info("cve数据已经已经提交过issue,不需要重复提交, cveData: ", issueValue)
								continue
							}
						}
						// Import cve as data after 2018
						cveNumList := strings.Split(issueValue.CveNum, "-")
						if cveNumList != nil && len(cveNumList) > 1 {
							cveYears, yearErr := strconv.Atoi(cveNumList[1])
							if yearErr == nil {
								if issueValue.DataSource == 1 {
									years = toolYears
								} else if issueValue.DataSource == 3 {
									years = manYears
								}
								if cveYears <= years {
									icr := models.IssueCreateRecord{}
									models.UpdateIssueStatus(issueValue, 4)
									logs.Info("cve: ", issueValue.CveNum, ",需要大于： ",
										years, ",否则不需要在git上提交issue, cveData: ", issueValue)
									sc, err := models.QueryIssueScore(issueValue.CveId)
									if err != nil || sc.Id == 0 {
										logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
										continue
									}
									GenIssueRecordData(&icr, issueValue, sc, 2)
									issueRecordId, issReErr := models.CreateIssueRecord(&icr)
									if issReErr == nil && issueRecordId > 0 {
										logs.Info("Issue record data created successfully, id:", issueRecordId)
									} else {
										logs.Error("Failed to create issue record data, err: ", issReErr)
									}
									continue
								}
							}
						}
						// Determine whether cve has been processed
						issueExist := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
						if issueExist {
							models.UpdateIssueStatus(issueValue, 2)
							logs.Info("cve数据已经在官网上展示过,不需要在git上提交issue, cveData: ", issueValue)
							continue
						}
						// Process each piece of cve data
						if issueValue.Status == 0 {
							err := ProcIssue(issueValue, accessToken, owner, path)
							if err != nil {
								logs.Error("创建issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
								continue
							}
						} else {
							err := ProcUpdateIssue(issueValue, accessToken, owner, path)
							if err != nil {
								logs.Error("修改issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
								continue
							}
						}
						// Collect issue record data
						icr := models.IssueCreateRecord{}
						sc, err := models.QueryIssueScore(issueValue.CveId)
						if err != nil || sc.Id == 0 {
							logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
							continue
						}
						GenIssueRecordData(&icr, issueValue, sc, 1)
						issueRecordId, issReErr := models.CreateIssueRecord(&icr)
						if issReErr == nil && issueRecordId > 0 {
							logs.Info("Issue record data created successfully, id:", issueRecordId)
						} else {
							logs.Error("Failed to create issue record data, err: ", issReErr)
						}
					}
				}
			}
		}
	} else {
		for ; ; {
			cveData, err := models.QueryIssue(beforeTime, prcnum)
			if err == nil && len(cveData) > 0 {
				logs.Info(cveData)
			} else {
				logs.Info("无cve数据可以使用, 当前时间: ", common.GetCurTime(), ", err: ", err)
				return err
			}
			accessToken := os.Getenv("GITEE_TOKEN")
			if accessToken == "" || len(accessToken) < 1 {
				logs.Error("issue token 获取失败, 当前时间: ", common.GetCurTime())
				return err
			}
			owner := BConfig.String("gitee::owner")
			path := BConfig.String("gitee::path")
			for index, issueValue := range cveData {
				logs.Info("当前正在处理第：", index, "条cve数据, cveNum: ", issueValue.CveNum)
				// Determine whether the issue has been processed
				goi, oks := models.QueryIssueCveByNum(issueValue.CveNum, issueValue.PackName)
				if oks {
					if strings.ToLower(goi.State) == "closed" || strings.ToLower(goi.State) == "rejected" ||
						goi.State == "已完成" || goi.State == "已拒绝" {
						models.UpdateIssueStatus(issueValue, 2)
						logs.Info("cve数据已经已经提交过issue,不需要重复提交, cveData: ", issueValue)
						continue
					}
				}
				// Import cve as data after 2018
				cveNumList := strings.Split(issueValue.CveNum, "-")
				if cveNumList != nil && len(cveNumList) > 1 {
					cveYears, yearErr := strconv.Atoi(cveNumList[1])
					if yearErr == nil {
						if issueValue.DataSource == 1 {
							years = toolYears
						} else if issueValue.DataSource == 3 {
							years = manYears
						}
						if cveYears <= years {
							icr := models.IssueCreateRecord{}
							models.UpdateIssueStatus(issueValue, 4)
							logs.Info("cve: ", issueValue.CveNum, ",需要大于： ",
								years, ",否则不需要在git上提交issue, cveData: ", issueValue)
							sc, err := models.QueryIssueScore(issueValue.CveId)
							if err != nil || sc.Id == 0 {
								logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
								continue
							}
							GenIssueRecordData(&icr, issueValue, sc, 2)
							issueRecordId, issReErr := models.CreateIssueRecord(&icr)
							if issReErr == nil && issueRecordId > 0 {
								logs.Info("Issue record data created successfully, id:", issueRecordId)
							} else {
								logs.Error("Failed to create issue record data, err: ", issReErr)
							}
							continue
						}
					}
				}
				// Determine whether cve has been processed
				issueExist := taskhandler.GetCveSecurityNotice(issueValue.CveNum)
				if issueExist {
					models.UpdateIssueStatus(issueValue, 2)
					logs.Info("cve数据已经在官网上展示过,不需要在git上提交issue, cveData: ", issueValue)
					continue
				}
				// Process each piece of cve data
				if issueValue.Status == 0 {
					err := ProcIssue(issueValue, accessToken, owner, path)
					if err != nil {
						logs.Error("创建issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
						continue
					}
				} else {
					err := ProcUpdateIssue(issueValue, accessToken, owner, path)
					if err != nil {
						logs.Error("修改issue失败, cvenum: ", issueValue.CveNum, "err,err: ", err)
						continue
					}
				}
				// Collect issue record data
				icr := models.IssueCreateRecord{}
				sc, err := models.QueryIssueScore(issueValue.CveId)
				if err != nil || sc.Id == 0 {
					logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
					continue
				}
				GenIssueRecordData(&icr, issueValue, sc, 1)
				issueRecordId, issReErr := models.CreateIssueRecord(&icr)
				if issReErr == nil && issueRecordId > 0 {
					logs.Info("Issue record data created successfully, id:", issueRecordId)
				} else {
					logs.Error("Failed to create issue record data, err: ", issReErr)
				}
			}
		}
	}
	return nil
}

//ProcUpdateIssue Update issue
func ProcUpdateIssue(issueValue models.VulnCenter, accessToken, owner, path string) error {
	// Query and modify score
	sr, err := models.QueryIssueScoreRecord(issueValue.CveId, 0)
	if err != nil {
		logs.Error("查询 评分记录失败, cveId: ", issueValue.CveId, "err: ", err)
		return err
	}
	// Query issue template
	var it models.IssueTemplate
	it.CveId = issueValue.CveId
	_, bools := models.GetIssueTemplet(&it)
	if bools && it.TemplateId > 0 {
		it.NVDScore = sr.NVDScore
		it.NVDVector = sr.NvectorVule
		it.CveBrief = issueValue.Description
		it.CveLevel = issueValue.CveLevel
		if it.Assignee == "" || len(it.Assignee) < 2 {
			gitYaml, ok := models.QueryCveOpeneulerdata(issueValue.PackName, issueValue.CveVersion)
			if !ok || gitYaml.MainTainer == "" || len(gitYaml.MainTainer) < 1 {
				assignee, assErr := taskhandler.GetCollaboratorInfo(accessToken, owner, path)
				if assignee != "" && len(assignee) > 1 {
					it.Assignee = assignee
					//return err
				} else {
					logs.Error("获取仓库： owner:", owner, "path:", path, "分析人失败", "assErr:", assErr,
						", cveid: ", issueValue.CveId, ",创建无maintainer的issue")
				}
			} else {
				it.Assignee = gitYaml.MainTainer
			}
		}
		path = it.Repo
		_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path,
			issueValue, it)
		if err != nil {
			logs.Error("更新issue 模板失败， cveId: ", issueValue.CveId, "err: ", err)
			// Update issue status
			models.UpdateIssueStatus(issueValue, 3)
			return err
		}
		// Update issue status
		models.UpdateIssueStatus(issueValue, 2)
		// Update score status
		models.UpdateIssueScore(issueValue, 2)
		templetID, err := models.CreateIssueTemplate(&it)
		if err != nil {
			logs.Error("修改issue模板失败, cveId: ", issueValue.CveId, "err: ", err)
			return err
		}
		models.UpdateIssueScoreRe(issueValue, 1)
		logs.Info("更新issue模板成功，cveId: ", issueValue.CveId, "templetID: ", templetID)
	}
	return nil
}

//ProcIssue Deal with issue
func ProcIssue(issueValue models.VulnCenter, accessToken, owner, path string) error {
	assignee := ""
	brandArry := []string{}
	sn, err := models.QueryIssueSecurity(issueValue.CveId)
	if err == nil && len(sn.CveNum) > 0 {
		path = issueValue.PackName
		logs.Info("查询安全信息：sn: ", sn)
		// Get issue handler
		gitYaml, ok := models.QueryCveOpeneulerdata(issueValue.PackName, issueValue.CveVersion)
		if !ok || gitYaml.MainTainer == "" || len(gitYaml.MainTainer) < 1 {
			assignee, err = taskhandler.GetCollaboratorInfo(accessToken, owner, path)
			if assignee == "" {
				logs.Error("获取仓库： owner:", owner, "path:", path, "分析人失败", "err:", err,
					"cveid: ", issueValue.CveId, ",创建无maintainer的issue")
				//return err
			}
		} else {
			assignee = gitYaml.MainTainer
			// Query the affected branch information
			gt, errgt := models.QueryCveBrands(gitYaml.GitId)
			if errgt == nil {
				for _, t := range gt {
					if t.Brands != "" && t.Brands != "master" && len(t.Brands) > 1 {
						brandArry = append(brandArry, t.Brands)
					}
				}
			}
		}
	} else {
		logs.Error("获取security 失败, err: ", err, "cveId: ", issueValue.CveId)
		return err
	}
	sc, err := models.QueryIssueScore(issueValue.CveId)
	if err != nil {
		logs.Error("获取Score 失败, err: ", err, "cveId: ", issueValue.CveId)
		return err
	}
	branchList := []string{}
	errBrands := errors.New("")
	// Get branch information
	branchList, errBrands = taskhandler.GetBranchesInfo(accessToken, owner, path)
	if branchList == nil || len(branchList) == 0 {
		logs.Error("获取分支信息失败,CveNum: ", issueValue.CveNum, "path: ", path, ", err: ", errBrands)
	}
	if len(branchList) > 0 {
		brandArry = []string{}
		for _, branch := range branchList {
			brandArry = append(brandArry, branch)
		}

	}
	resp, err := taskhandler.CreateIssueToGit(accessToken, owner, path, assignee, issueValue, sc, brandArry)
	if err != nil {
		logs.Error("创建issue失败, err: ", err, "resp: ", resp, "cveId: ", issueValue.CveId)
		// Update issue status
		models.UpdateIssueStatus(issueValue, 3)
		return err
	}
	return nil
}
