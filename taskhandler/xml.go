package taskhandler

import (
	"encoding/xml"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"os"
)

type Updates struct {
	XMLName xml.Name `xml:"updates,omitempty"`
	Updatex []Update `xml:"update,omitempty"`
}

type Update struct {
	XMLName     xml.Name    `xml:"update,omitempty"`
	From        string      `xml:"from,attr"`
	Type        string      `xml:"type,attr"`
	Status      string      `xml:"status,attr"`
	Id          string      `xml:"id"`
	Title       string      `xml:"title"`
	Severity    string      `xml:"severity"`
	Release     string      `xml:"release"`
	Issued      *Issued     `xml:"issued,omitempty"`
	References  *References `xml:"references,omitempty"`
	Description string      `xml:"description"`
	Pkglist     *Pkglist    `xml:"pkglist,omitempty"`
}

type Issued struct {
	XMLName xml.Name `xml:"issued,omitempty"`
	Date    string   `xml:"date,attr"`
}

type References struct {
	XMLName   xml.Name    `xml:"references,omitempty"`
	Reference []Reference `xml:"reference,omitempty"`
}

type Reference struct {
	XMLName xml.Name `xml:"reference,omitempty"`
	Href    string   `xml:"href,attr"`
	Id      string   `xml:"id,attr"`
	Title   string   `xml:"title,attr"`
	Type    string   `xml:"type,attr"`
}

type Pkglist struct {
	XMLName    xml.Name    `xml:"pkglist,omitempty"`
	Collection *Collection `xml:"collection,omitempty"`
}

type Collection struct {
	XMLName xml.Name  `xml:"collection,omitempty"`
	Name    string    `xml:"name"`
	Package []Package `xml:"package,omitempty"`
}

type Package struct {
	XMLName  xml.Name `xml:"package,omitempty"`
	Arch     string   `xml:"arch,attr"`
	Name     string   `xml:"name,attr"`
	Release  string   `xml:"release,attr"`
	Version  string   `xml:"version,attr"`
	Filename string   `xml:"filename"`
}

// Intermediate information
type SecurityNoticeXml struct {
	CveNum        string
	Title         string
	Type          string
	ReferenceLink string
	Description   string
}

type PackRpm struct {
	PackName string
}

type CveXml struct {
	PublicDate     string
	OpenEulerSANum string
	Introduction   string
	CveLevel       string
	SecurityNotice []SecurityNoticeXml
	PackRpmx       []PackRpm
}

func ReadXml(filePath string, dpdates *Updates) error {
	if filePath == "" || len(filePath) == 0 {
		filePath = "download/updateinfo.xml"
	}
	fd, err := os.Open(filePath)
	if err != nil {
		logs.Error("open file err : ", err, ",filePath: ", filePath)
		return err
	}
	defer fd.Close()
	fileContent, err := ioutil.ReadAll(fd)
	if err != nil {
		logs.Error("read file err : ", err, ", filePath: ", filePath)
		return err
	}
	err = xml.Unmarshal(fileContent, dpdates)
	if err != nil {
		logs.Error("unmarshal err : ", err, ", fileContent: ", fileContent)
		return err
	}
	return nil
}

//func WriteXml(dpdates *Updates, v models.ExcelExport) {
//	pkg, pkgErr := models.GetCvePackageList(v.SecID)
//	if pkgErr != nil {
//		logs.Error(pkgErr)
//	}
//	if v.PublicDate == "" {
//		v.PublicDate = time.Now().Format("2006-01-02")
//	}
//	pkgStr := getPkgStr(pkg)
//	sn := []interface{}{v.OpenEulerSANum, v.CveNum, v.Introduction, v.Summary, v.Theme, v.Description, v.InfluenceComponent,
//		v.AffectProduct, pkgStr, v.ReferenceLink, v.PublicDate}
//	axis, searched := ec.searchValueInSheet(ec.SecNoticeSheetName, v.InfluenceComponent)
//	if !searched {
//		fillErr := ec.fillSecurityNoticeSheet(sn)
//		if fillErr != nil {
//			logs.Error(fillErr)
//		}
//	} else {
//		//merge openEuler SA notice data
//		colReg := regexp.MustCompile(`[A-Z]*`)
//		col := colReg.FindString(axis)
//		row := strings.Trim(axis, col)
//		rCN := "B" + row
//		rRl := "J" + row
//		vcn, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rCN)
//		vcn += ";\n" + v.CveNum
//		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rCN, vcn)
//		vrl, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rRl)
//		vrl += "\n" + v.ReferenceLink
//		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rRl, vrl)
//		rSAN := fmt.Sprintf("A%s", row)
//		vSAN, cellError := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rSAN)
//		if cellError == nil {
//			v.OpenEulerSANum = vSAN
//		}
//		//merger description
//		rd := "F" + row
//		vd, _ := ec.ExcelHandel.GetCellValue(ec.SecNoticeSheetName, rd)
//		dSplit := strings.Split(v.Description, "Security Fix(es):")
//		if len(dSplit) > 1 {
//			if !strings.Contains(vd, dSplit[0]) {
//				vd = dSplit[0] + vd
//			}
//			vd += dSplit[1]
//		}
//		_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, vd)
//		//Get the highest-rated theme
//		rd = "E" + row
//		theme, err := models.GetCanExportTheme(vcn, v.OwnedComponent)
//		if err == nil {
//			_ = ec.ExcelHandel.SetCellValue(ec.SecNoticeSheetName, rd, theme)
//		}
//	}
//	cve := []interface{}{v.CveNum, v.CveBrief, v.NVDScore, v.OpenEulerScore, v.NattackVector, v.OattackVector,
//		v.NattackComplexity, v.OattackComplexity, v.NprivilegeRequired, v.OprivilegeRequired, v.NuserInteraction,
//		v.OuserInteraction, v.Nscope, v.Oscope, v.Nconfidentiality, v.Oconfidentiality, v.Nintegrity, v.Ointegrity,
//		v.Navailability, v.Oavailability, v.ScoreType, v.OpenEulerSANum, v.PublicDate}
//	shErr := ec.fillCveSheetRow(cve)
//	if shErr != nil {
//		logs.Error(shErr)
//	}
//
//	ap := []interface{}{v.CveNum, v.AffectProduct, v.InfluenceComponent, v.AffectStatus}
//	err := ec.fillAffectProductSheet(ap)
//	if err != nil {
//		logs.Error(err)
//	}
//	for _, v := range pkg {
//		pk := []interface{}{v.PackName, v.PackUrl}
//		if _, ok := ec.searchValueInSheet(ec.PackageURLSheetName, v.PackName); !ok {
//			err := ec.fillPackageSheet(pk)
//			if err != nil {
//				logs.Error(err)
//			}
//		}
//	}
//}
