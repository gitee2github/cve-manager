package taskhandler

import (
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"sync"
)

var wgx sync.WaitGroup

type HookData struct {
	Id         int64
	HookUrl    string
	CreateTime string
	Password   string
	ResultCode int
	ProjectId  int64
}

func ProcHookEvent(hookurl, owner, accessToken, pwd, gaussOwner, gitGaussToken string) error {
	deleteHook, ok := beego.AppConfig.Int("hook::delete_hook")
	if ok != nil {
		deleteHook = 1
	}
	hookId := int64(0)
	count := 5
	for ; ; {
		iHook, ihOk := models.GetAllIssueHook(hookId, count, 1)
		if ihOk && len(iHook) > 0 {
			for _, ih := range iHook {
				var hd []HookData
				if ih.Owner == gaussOwner {
					accessToken = gitGaussToken
				}
				GetDepositHooks(accessToken, ih.Owner, ih.Repo, &hd)
				if len(hd) > 0 {
					PrcMutDepositHooks(accessToken, pwd, ih, hd, deleteHook, gaussOwner)
				}
			}
			hookId = iHook[len(iHook)-1].Id
		} else {
			break
		}
	}
	return nil
}

func GetDepositHooks(accessToken, owner, repo string, hd *[]HookData) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/%v/hooks?access_token=%v&page=1&per_page=50", owner, repo, accessToken)
	hookData, err := util.HTTPGet(url)
	if err == nil && hookData != nil {
		for _, value := range hookData {
			if _, ok := value["id"]; !ok {
				logs.Error("hookData, err: ", ok, "url: ", url)
				continue
			}
			var hdl HookData
			hdl.Id = int64(value["id"].(float64))
			hdl.HookUrl = value["url"].(string)
			hdl.CreateTime = value["created_at"].(string)
			hdl.Password = value["password"].(string)
			hdl.ProjectId = int64(value["project_id"].(float64))
			hdl.ResultCode = int(value["result_code"].(float64))
			*hd = append(*hd, hdl)
		}
	}
}

func PrcMutDepositHooks(accessToken, pwd string, ihk models.IssueHooks, hd []HookData, deleteHook int, gaussOwner string) {
	for _, hdk := range hd {
		if ihk.HookUrl == hdk.HookUrl && hdk.Password == pwd {
			if deleteHook == 2 && ihk.Owner != gaussOwner {
				go DeleteDepositHooks(accessToken, ihk.Owner, ihk.Repo, hdk.Id)
			} else {
				if hdk.Id != ihk.HookId && ihk.HookId > 0 {
					go DeleteDepositHooks(accessToken, ihk.Owner, ihk.Repo, hdk.Id)
				}
			}
		}
	}
}

func DeleteDepositHooks(accessToken, owner, repo string, hookId int64) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/%v/hooks/%v", owner, repo, hookId)
	requestBody := fmt.Sprintf(`{
					"access_token": "%s"
					}`, accessToken)
	util.HTTPDelCom(url, requestBody)
}

func AddRepoWebhook(accessToken, owner, path, pwd, hookurl string) error {
	var ih models.IssueHooks
	ih.CveId = int64(1)
	issueId := int64(1)
	ih.IssueNum = "000000"
	ih.Owner = owner
	ih.Status = 1
	ih.Repo = path
	ihs, errh := models.GetIssueHook(&ih)
	if errh {
		hookExist := false
		for _, wh := range ihs {
			if wh.HookUrl == hookurl {
				hookExist = true
				break
			}
		}
		if !hookExist {
			postErr := PostWebHooks(accessToken, owner, path, hookurl, pwd, ih.IssueNum, issueId, ih.CveId)
			if postErr == nil {
				logs.Info("owner: ", owner, ",repo: ", path, ",webhook created successfully")
			} else {
				logs.Error("owner: ", owner, ",repo: ", path, ", postErr: ", postErr)
			}
			return postErr
		}
		return nil
	} else {
		postErr := PostWebHooks(accessToken, owner, path, hookurl, pwd, ih.IssueNum, issueId, ih.CveId)
		if postErr == nil {
			logs.Info("owner: ", owner, ",repo: ", path, ",webhook created successfully")
		} else {
			logs.Error("owner: ", owner, ",repo: ", path, ", postErr: ", postErr)
		}
		return postErr
	}
}

//GetOrgRepos get organization repository
func GetOrgAllRepos(accToken, org, pwd, hookurl string, page int64) {
	wgx.Add(1)
	defer wgx.Done()
	resp, err := http.Get(fmt.Sprintf(GiteOrgReposURL, org, accToken, page, perPage))
	if err != nil {
		logs.Error("Get, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	defer resp.Body.Close()
	var reps []models.HookRepository
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logs.Error("ReadAll, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	err = json.Unmarshal(body, &reps)
	if err != nil {
		logs.Error("Unmarshal, GiteOrgReposURL: ", GiteOrgReposURL, ", org: ", GiteOrgReposURL, ",err: ", err)
		return
	}
	for _, v := range reps {
		AddRepoWebhook(accToken, org, v.Name, pwd, hookurl)
	}
}

func GetAllRepoInfo(accessToken, owner, pwd, hookurl string) error {
	orgInfo, err := GetOrgInfo(accessToken, owner)
	if err != nil {
		logs.Error("GetOrgInfo, org: ", owner, ",err: ", err)
		return err
	}
	reposNum := orgInfo.PublicRepos + orgInfo.PrivateRepos
	if reposNum <= 0 {
		logs.Info(fmt.Sprintf("%v contain %v repository,grab issue finish!", owner, reposNum))
		return errors.New(fmt.Sprintf("%v contain %v repository,grab issue finish!", owner, reposNum))
	}
	pageSize := reposNum / int64(perPage)
	if reposNum%int64(perPage) > 0 {
		pageSize = pageSize + 1
	}
	var i int64
	for i = 1; i <= pageSize; i++ {
		go GetOrgAllRepos(accessToken, owner, pwd, hookurl, i)
	}
	wgx.Wait()
	return nil
}

// Create webhook event function entry
func CreateHookEvent(hookurl, owner, accessToken, pwd, gaussOwner, gitGaussToken string) error {
	repoErr := GetAllRepoInfo(accessToken, owner, pwd, hookurl)
	if repoErr == nil {
		logs.Info("CreateHookEvent, owner: ", owner, ", webhook created successfully, hookurl: ", hookurl)
	} else {
		logs.Error("CreateHookEvent, owner: ", owner, ", hookurl: ", hookurl, ",repoErr: ", repoErr)
	}
	dbRepo := models.QueryOrgAllRepo(owner)
	if len(dbRepo) > 0 {
		for _, v := range dbRepo {
			AddRepoWebhook(accessToken, owner, v.Path, pwd, hookurl)
		}
	}
	return nil
}
