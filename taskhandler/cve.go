package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"errors"
	"github.com/astaxie/beego/logs"
	"strconv"
	"strings"
	"sync"
	"time"
)

func UpdateCveGroups(cveData models.OriginUpstream, cveRef string, openeulernum int, CveRes models.VulnCenter, cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3) (bool, error){
	var OpenEulId int64
	CveRes.Description = cveDesc.EnDescription
	CveRes.CveVersion = cveData.Version
	CveRes.RepairTime = cveData.PublishedDate
	CveRes.PackName = cveData.PackName
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveScV3.CveLevel
	if CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		os, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(os.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList) - 1])
			if err == nil {
				OpenNum += 100
			} else {
				OpenNum = openeulernum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulernum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		OpenEulerId, OpEerr := models.CreateOpenEulerSA(&opensa)
		if OpEerr == nil {
			OpenEulId = OpenEulerId
		} else {
			logs.Error("更新openEulerSa数据表失败")
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes,scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		if scoreRes.NVDScore != cveScV3.BaseScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = cveScV3.BaseScore
			scorecode.NvectorVule = cveScV3.VectorString
			scorecode.Status = 0
			scorecode.CveId = CveRes.CveId
			scoreid, err :=models.CreateScoreRecord(&scorecode)
			if scoreid > 0 && err == nil {
				logs.Info("insert score_record success, id:",scoreid)
			} else {
				return false, errors.New("评分记录数据错误，暂时不处理")
			}
		}
		scoreRes.NVDScore = cveScV3.BaseScore
		scoreRes.NvectorVule = cveScV3.VectorString
		scoreRes.OpenId = OpenEulId
		scoreRes.Nstatus = 1
		scoreRes.NattackVector = cveScV3.AttackVector
		scoreRes.NattackComplexity = cveScV3.AttackComplexity
		scoreRes.NprivilegeRequired = cveScV3.PrivilegesRequired
		scoreRes.NuserInteraction = cveScV3.UserInteraction
		scoreRes.Nscope = cveScV3.Scope
		scoreRes.Nconfidentiality = cveScV3.ConfidentialityImpact
		scoreRes.Nintegrity = cveScV3.IntegrityImpact
		scoreRes.Navailability = cveScV3.AvailabilityImpact

	}else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.NVDScore = cveScV3.BaseScore
		sc.OpenEulerScore = cveScV3.BaseScore
		sc.OpenId = OpenEulId
		sc.NvectorVule = cveScV3.VectorString
		sc.OvectorVule = cveScV3.VectorString
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		sc.ScoreType = "v3"
		sc.NattackVector = cveScV3.AttackVector
		sc.OattackVector = cveScV3.AttackVector
		sc.NattackComplexity = cveScV3.AttackComplexity
		sc.OattackComplexity = cveScV3.AttackComplexity
		sc.NprivilegeRequired = cveScV3.PrivilegesRequired
		sc.OprivilegeRequired = cveScV3.PrivilegesRequired
		sc.NuserInteraction = cveScV3.UserInteraction
		sc.OuserInteraction = cveScV3.UserInteraction
		sc.Nscope = cveScV3.Scope
		sc.Oscope = cveScV3.Scope
		sc.Nconfidentiality = cveScV3.ConfidentialityImpact
		sc.Oconfidentiality = cveScV3.ConfidentialityImpact
		sc.Nintegrity = cveScV3.IntegrityImpact
		sc.Ointegrity = cveScV3.IntegrityImpact
		sc.Navailability = cveScV3.AvailabilityImpact
		sc.Oavailability = cveScV3.AvailabilityImpact

		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("insert cve_score failed cveScV3:", cveScV3)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = cveData.AffectProduct
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = cveData.AffectProduct + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = cveData.AffectProduct
		sec.Status = 0
		sec.AffectStatus = "UnFixed"
		sec.CveId = CveRes.CveId
		sec.Summary = cveData.AffectProduct + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("update (&CveRes, &SecNOtice)failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("update (&CveRes, &scoreRes) failed CveNum:", cveData.CveNum)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveGroups(cveData models.OriginUpstream, cveRef string, openeulernum int, cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveDesc.EnDescription
	vul.Status = 0
	vul.CveVersion = cveData.Version
	vul.RepairTime = cveData.PublishedDate
	vul.PackName = cveData.PackName
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveScV3.CveLevel
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = cveData.AffectProduct
	sec.Status = 0
	sec.AffectStatus = "UnFixed"
	sec.Summary = cveData.AffectProduct + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.NVDScore = cveScV3.BaseScore
	sc.OpenEulerScore = cveScV3.BaseScore
	sc.NvectorVule = cveScV3.VectorString
	sc.OvectorVule = cveScV3.VectorString
	sc.Nstatus = 0
	sc.Ostatus = 0
	sc.ScoreType = "v3"
	sc.NattackVector = cveScV3.AttackVector
	sc.OattackVector = cveScV3.AttackVector
	sc.NattackComplexity = cveScV3.AttackComplexity
	sc.OattackComplexity = cveScV3.AttackComplexity
	sc.NprivilegeRequired = cveScV3.PrivilegesRequired
	sc.OprivilegeRequired = cveScV3.PrivilegesRequired
	sc.NuserInteraction = cveScV3.UserInteraction
	sc.OuserInteraction = cveScV3.UserInteraction
	sc.Nscope = cveScV3.Scope
	sc.Oscope = cveScV3.Scope
	sc.Nconfidentiality = cveScV3.ConfidentialityImpact
	sc.Oconfidentiality = cveScV3.ConfidentialityImpact
	sc.Nintegrity = cveScV3.IntegrityImpact
	sc.Ointegrity = cveScV3.IntegrityImpact
	sc.Navailability = cveScV3.AvailabilityImpact
	sc.Oavailability = cveScV3.AvailabilityImpact
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	os, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(os.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList) - 1])
		if err == nil {
			OpenNum += 100
		} else {
			OpenNum = openeulernum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulernum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveScV3.BaseScore
	scorecode.NvectorVule = cveScV3.VectorString
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNum)
		return false, errors.New("数据插入失败，暂时不处理")
	}
	return true, nil
}

var lockx sync.Mutex

func GenCveVuler(cveData models.OriginUpstream, cveRef string, openeulernum int) (bool, error){
	if cveData.Ids == "" || cveData.CveNum == ""{
		logs.Error("当前数据cveNum 为空暂不处理,data: ", cveData)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveDesc, ok := models.QueryCveDesc(cveData.CveId)
	if !ok {
		logs.Error("当前数据描述为空暂不处理, data: ", cveData)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveImpact, ok := models.QueryCveImpact(cveData.CveId)
	if !ok {
		logs.Error("cveImpact查询失败, data: ", cveData)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveScore, ok := models.QueryCveScore(cveImpact.ImpactId, "v3")
	if !ok {
		logs.Error("cveScore, data: ", cveData, ",cveImpact: ", cveImpact)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveScV3, ok := models.QueryCveCvssV3(cveScore.ScoreId)
	if !ok {
		logs.Error("cveScore, data: ", cveData, ",cveScore: ", cveScore)
		return false, errors.New("数据错误，暂时不处理")
	}
	CveRes, err := models.QueryCveByNum(cveData.CveNum)
	if err {
		lockx.Lock()
		ok, err := UpdateCveGroups(cveData, cveRef, openeulernum, CveRes, cveDesc, cveScV3)
		lockx.Unlock()
		if !ok {
			logs.Error("更新cve数据失败, cveData: ", cveData, ", err: ", err)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		lockx.Lock()
		ok, err := InsertCveGroups(cveData, cveRef, openeulernum, cveDesc, cveScV3)
		lockx.Unlock()
		if !ok {
			logs.Error("插入cve数据失败, cveData: ", cveData, ", err: ", err)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId)
	return true, nil
}

func GetCveOriginData(prcnum, days , openeulernum int, cveRef string) (bool, error) {
	defer common.Catchs()
	//var os []models.OriginUpstream
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		os, num, err := models.QueryOriginCve(beforeTime, prcnum)
		if err != nil || num == 0{
			logs.Info("当前无cve原始数据处理, err: ", err,
				", 处理时间范围: beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("总共有: ", num, "条的数据需要处理, ", os)
		ch := make(chan int, len(os))
		for i, cveData := range os {
			count = count + 1
			logs.Info("当前正常解析第： ", count, "条数据,i:", i, ", cvenum: ", cveData.Ids)
			go func () {
				ok, err := GenCveVuler(cveData, cveRef, openeulernum)
				if !ok {
					logs.Error("cveData: ", cveData, "处理失败, err: ", err)
				}
				ch <- i
			}()
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}
