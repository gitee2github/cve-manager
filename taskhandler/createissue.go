package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"strconv"
	"strings"
	"sync"
)

var updateLock sync.Mutex

func CreateIssueData(issueTemp *models.IssueTemplate, cve models.VulnCenter, sc models.Score, resp map[string]interface{},
	path, assignee, issueType, labels, owner string) *models.IssueTemplate {
	issueTemp.CveId = cve.CveId
	issueTemp.CveNum = cve.CveNum
	issueTemp.OwnedComponent = path
	issueTemp.OwnedVersion = cve.CveVersion
	//err := models.GetIssueTemplateByColName(issueTemp, "cve_id", "cve_num", "owned_component")
	//if err != nil || issueTemp.TemplateId == 0{
	//	logs.Info(err)
	//	issueTemp.MtAuditFlag = 0
	//	issueTemp.SaAuditFlag = 0
	//}
	if issueTemp.TemplateId == 0 {
		issueTemp.MtAuditFlag = 1
		issueTemp.SaAuditFlag = 0
	}
	issueTemp.NVDScore = sc.NVDScore
	issueTemp.NVDVector = sc.NvectorVule
	issueTemp.CveBrief = cve.Description
	issueTemp.CveLevel = cve.CveLevel
	if resp != nil && len(resp) > 0 {
		issueTemp.IssueId = int64(resp["id"].(float64))
		issueTemp.IssueNum = resp["number"].(string)
		issueTemp.StatusName = resp["state"].(string)
		if strings.ToLower(resp["state"].(string)) == "open" ||
			resp["state"].(string) == "待办的" ||
			resp["state"].(string) == "开启的" {
			issueTemp.Status = 1
			issueTemp.StatusName = "open"
			issueTemp.IssueStatus = 1
		} else if strings.ToLower(resp["state"].(string)) == "started" ||
			strings.ToLower(resp["state"].(string)) == "progressing" ||
			strings.ToLower(resp["state"].(string)) == "进行中" {
			issueTemp.Status = 2
			issueTemp.StatusName = "progressing"
			issueTemp.IssueStatus = 3
		} else if strings.ToLower(resp["state"].(string)) == "closed" || resp["state"].(string) == "已完成" {
			issueTemp.Status = 3
			issueTemp.StatusName = "closed"
			issueTemp.IssueStatus = 2
		} else {
			if strings.ToLower(resp["state"].(string)) == "rejected" || resp["state"].(string) == "已拒绝" {
				issueTemp.StatusName = "rejected"
				issueTemp.Status = 4
			}
			if strings.ToLower(resp["state"].(string)) == "suspended" || resp["state"].(string) == "已挂起" {
				issueTemp.StatusName = "suspended"
				issueTemp.Status = 5
			}
			issueTemp.IssueStatus = 6
		}
	} else {
		issueTemp.IssueId = 0
		issueTemp.IssueNum = "nil"
		issueTemp.StatusName = "nil"
		issueTemp.Status = 0
	}

	issueTemp.Assignee = assignee
	issueTemp.IssueLabel = labels
	issueTemp.Owner = owner
	issueTemp.Repo = path
	issueTemp.Title = cve.CveNum
	issueTemp.IssueType = issueType
	issueTemp.Collaborators = ""
	issueTemp.Milestone = ""
	issueTemp.Program = ""
	issueTemp.SecurityHole = 0
	logs.Info("组装issue,模板数据存入db: ", issueTemp)
	return issueTemp
}

func CreateIssueToGit(accessToken string, owner string, path string, assignee string,
	cve models.VulnCenter, sc models.Score, brandArray []string) (string, error) {
	defer common.Catchs()
	var it models.IssueTemplate
	it.CveId = cve.CveId
	_, err := models.GetIssueTemplet(&it)
	sia := models.SpecIssueAssigness{PackageName: cve.PackName, Status: 1}
	specError := models.GetSpecIssueAssignee(&sia, "package_name", "status")
	if specError == nil && sia.Id > 0 {
		it.Assignee = sia.Assignee
		assignee = sia.Assignee
	}
	if err && it.IssueNum != "" && len(it.IssueNum) > 0 {
		if it.Assignee == "" || len(it.Assignee) == 0 {
			it.Assignee = assignee
		}
		issueType := it.IssueType
		labels := ""
		if it.IssueLabel != "" && len(it.IssueLabel) > 1 {
			labels = it.IssueLabel
		} else {
			labels = beego.AppConfig.String("labelUnFix")
		}

		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + it.IssueNum
			score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
			OpenEulerScore := strconv.FormatFloat(it.OpenEulerScore, 'f', 1, 64)
			requestBody := CreateIssueBody(accessToken, owner, path, it.Assignee,
				cve, sc, OpenEulerScore, score, labels, it, 1, it.IssueType, "", brandArray)
			if requestBody != "" && len(requestBody) > 1 {
				logs.Info("isssue_body: ", requestBody)
				resp, err := util.HTTPPatch(url, requestBody)
				if err != nil {
					logs.Error("创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
					return "", err
				}
				if _, ok := resp["id"]; !ok {
					logs.Error("创建issue 失败, err: ", ok, "url: ", url)
					return "", errors.New("创建issue失败")
				}
				logs.Info("issue 创建成功，cveNum: ", cve.CveNum, "issueNum: ", resp["number"].(string))
				// Structure data
				//var issueTemp models.IssueTemplate
				CreateIssueData(&it, cve, sc, resp, path, it.Assignee, issueType, labels, owner)
				if len(brandArray) > 0 {
					var brandArryTmp []string
					for _, brand := range brandArray {
						brandArryTmp = append(brandArryTmp, brand+":")
					}
					brandStr := strings.Join(brandArryTmp, ",")
					it.AffectedVersion = brandStr
				}
				// Store issue data
				issTempID, err := models.CreateIssueTemplate(&it)
				if err != nil {
					logs.Error("创建issue 模板的数据失败, cveNum: ", cve.CveNum, "err: ", err)
					return "", err
				}
				logs.Info("创建issue 模板的数据成功, issTempID: ", issTempID, "cveNum: ", cve.CveNum)
			} else {
				logs.Info("不需要更新issue模板及issue状态, its: ", it)
			}
			// Update issue status
			models.UpdateIssueStatus(cve, 2)
			// Update score status
			models.UpdateIssueScore(cve, 2)
			// Update score record status
			models.UpdateIssueScoreRe(cve, 1)
		}
	} else {
		issueType := "CVE和安全问题"
		labels := beego.AppConfig.String("labelUnFix")
		if accessToken != "" && owner != "" && path != "" {
			var issueTemp models.IssueTemplate
			CreateIssueData(&issueTemp, cve, sc, nil, path, assignee, issueType, labels, owner)
			// Store issue data
			issTempID, templateErr := models.InsertIssueTemplate(&issueTemp)
			if templateErr == nil && issTempID > 0 {
				url := "https://gitee.com/api/v5/repos/" + owner + "/issues"
				score := strconv.FormatFloat(sc.NVDScore, 'f', 1, 64)
				requestBody := CreateIssueBody(accessToken, owner, path, assignee,
					cve, sc, "", score, labels, it, 2, issueType, "", brandArray)
				logs.Info("isssue_body: ", requestBody)
				if requestBody != "" && len(requestBody) > 1 {
					resp, err := util.HTTPPost(url, requestBody)
					if err != nil {
						logs.Error("url: ", url, "创建issue失败, cveNum: ", cve.CveNum, "err: ", err)
						models.DeleteIssueTemplate(issTempID)
						return "", err
					}
					if _, ok := resp["id"]; !ok {
						logs.Error("创建issue 失败, err: ", ok, "url: ", url)
						models.DeleteIssueTemplate(issTempID)
						return "", errors.New("创建issue失败")
					}
					//var issueTemps models.IssueTemplate
					issueTemp.TemplateId = issTempID
					CreateIssueData(&issueTemp, cve, sc, resp, path, assignee, issueType, labels, owner)
					if len(brandArray) > 0 {
						var brandArrayTmp []string
						for _, brand := range brandArray {
							brandArrayTmp = append(brandArrayTmp, brand+":")
						}
						brandStr := strings.Join(brandArrayTmp, ",")
						issueTemp.AffectedVersion = brandStr
						issueTemp.SaAuditFlag = 0
					} else {
						issueTemp.SaAuditFlag = 1
					}
					// Store issue data
					issTempIDx, idxErr := models.UpdateIssueTemplateAll(&issueTemp)
					if idxErr != nil {
						logs.Error("创建issue 模板的数据失败, cveNum: ", cve, ",err: ", err)
						//models.DeleteIssueTemplate(issTempID)
						return "", err
					}
					logs.Info("创建issue 模板的数据成功, issTempID: ", issTempIDx, "cveNum: ", cve.CveNum)
					// Create issue comment
					affectedVersion := ""
					if len(brandArray) > 0 {
						for i, brand := range brandArray {
							if brand == "" || len(brand) < 2 {
								continue
							}
							affectedVersion = affectedVersion + strconv.Itoa(i+1) + "." + brand + ":\n"
						}
					} else {
						affectedVersion = affectedVersion + "\n"
					}
					errx := CreateIssueComment(accessToken, owner, path, assignee, cve, resp, affectedVersion)
					logs.Info("issue评论创建结果, err: ", errx)
					// Send gitee private message
					content := fmt.Sprintf("%v 仓库有新的CVE和安全问题的ISSUE被 cve-manager 创建,CVE编号: %v, 请及时处理.", path, cve.CveNum)
					SendPrivateLetters(accessToken, content, assignee)
					issueNum := resp["number"].(string)
					issueID := int64(resp["id"].(float64))
					err = CreateDepositHooks(accessToken, owner, path, cve, issueNum, issueID)
					if err != nil {
						logs.Error("创建hooks 失败, cveNum: ", cve.CveNum, "err: ", err)
						return "", err
					}
					logs.Info("创建hooks 成功, cveNum: ", cve.CveNum)
					// Update issue status
					models.UpdateIssueStatus(cve, 2)
					// Update score status
					models.UpdateIssueScore(cve, 2)
					// Update score record status
					models.UpdateIssueScoreRe(cve, 1)
				} else {
					models.DeleteIssueTemplate(issTempID)
				}
			} else {
				logs.Error("重复创建issue, cve: ", cve, ", templateErr: ", templateErr)
				return "", nil
			}
		}
	}
	branchs := ""
	if len(brandArray) > 0 {
		for _, b := range brandArray {
			if b != "" && len(b) > 1 {
				branchs = branchs + b + "/"
			}
		}
		if branchs != "" && len(branchs) > 1 {
			branchs = branchs[:len(branchs)-1]
		}
	}
	// Store security bulletin related information
	var sec models.SecurityNotice
	CreateSecNoticeData(&sec, cve, path, branchs, sc.NVDScore)
	secID, noticeErr := models.UpdateSecNotice(&sec)
	if noticeErr != nil {
		logs.Error("更新安全信息失败,CveNum: ", cve.CveNum, "path: ", path, "err: ", noticeErr)
		return "", nil
	}
	logs.Info("更新安全信息成功, secID: ", secID, "cveNum: ", cve.CveNum)
	return "", nil
}

func UpdateIssueToGit(accessToken string, owner string, path string,
	cve models.VulnCenter, its models.IssueTemplate) (string, error) {
	logs.Info("更新模板请求参数: cve: ", cve, ",its: ", its, ", owner: ", owner, ",path: ", path)
	//labels := its.IssueLabel
	sia := models.SpecIssueAssigness{PackageName: cve.PackName, Status: 1}
	specError := models.GetSpecIssueAssignee(&sia, "package_name", "status")
	if specError == nil && sia.Id > 0 {
		its.Assignee = sia.Assignee
	}
	labels := ""
	if its.IssueLabel != "" && len(its.IssueLabel) > 1 {
		labels = its.IssueLabel
	} else {
		labels = beego.AppConfig.String("labelUnFix")
	}
	pkgList, err := models.QueryPackageByCveId(its.CveId)
	pkgLink := ""
	var brandArray []string
	if err == nil && len(pkgList) > 0 {
		for _, p := range pkgList {
			pkgLink = pkgLink + fmt.Sprintf(`[%v](%v)\r\n`, p.PackName, p.PackUrl)
		}
	}
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/issues/" + its.IssueNum
		score := strconv.FormatFloat(its.NVDScore, 'f', 1, 64)
		OpenEulerScore := strconv.FormatFloat(its.OpenEulerScore, 'f', 1, 64)
		var sc models.Score
		sc, scok := models.QueryScoreByCveId(cve.CveId)
		if !scok {
			logs.Error("评分不存在, cve: ", cve)
		}
		requestBody := CreateIssueBody(accessToken, owner, path, its.Assignee,
			cve, sc, OpenEulerScore, score, labels, its, 3, its.IssueType, pkgLink, brandArray)
		logs.Info("isssue_body: ", requestBody)
		if requestBody != "" && len(requestBody) > 1 {
			updateLock.Lock()
			resp, err := util.HTTPPatch(url, requestBody)
			updateLock.Unlock()
			if err != nil {
				logs.Error("更新issue失败, cveNum: ", cve.CveNum, "err: ", err)
				return "", err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建issue 失败, err: ", ok, "url: ", url)
				return "", errors.New("创建issue失败")
			}
			// Store security bulletin related information
			var sec models.SecurityNotice
			CreateSecNoticeData(&sec, cve, path, its.AffectedVersion, its.OpenEulerScore)
			secId, err := models.UpdateSecNotice(&sec)
			if err != nil {
				logs.Error("更新安全信息失败,CveNum: ", cve.CveNum, ",path: ", path, ",err: ", err)
				return "", err
			} else {
				logs.Info("更新安全信息成功, secId: ", secId, ",cveNum: ", cve.CveNum)
			}
		}
	}
	return "", nil
}

func CreateIssueHookData(issHook *models.IssueHooks, cve models.VulnCenter, resp map[string]interface{},
	path, owner string, issueNum string, issueId int64) *models.IssueHooks {
	issHook.CveId = cve.CveId
	issHook.IssueId = issueId
	issHook.IssueNum = issueNum
	issHook.HookId = int64(resp["id"].(float64))
	issHook.Owner = owner
	issHook.Repo = path
	issHook.CreateTime = common.GetCurTime()
	issHook.UpdateTime = common.GetCurTime()
	issHook.Status = 1
	issHook.HookUrl = resp["url"].(string)
	if resp["push_events"].(bool) == true {
		issHook.PushEvent = 1
	} else {
		issHook.PushEvent = 0
	}
	if resp["tag_push_events"].(bool) == true {
		issHook.TagPushEvent = 1
	} else {
		issHook.TagPushEvent = 0
	}
	if resp["issues_events"].(bool) == true {
		issHook.IssueEvent = 1
	} else {
		issHook.IssueEvent = 0
	}
	if resp["note_events"].(bool) == true {
		issHook.NoteEvent = 1
	} else {
		issHook.NoteEvent = 0
	}
	if resp["merge_requests_events"].(bool) == true {
		issHook.MergeRequestEvent = 1
	} else {
		issHook.MergeRequestEvent = 0
	}
	return issHook
}

func CreateDepositHooks(accessToken string, owner string, path string,
	cve models.VulnCenter, issueNum string, issueId int64) error {
	var ih models.IssueHooks
	ih.CveId = cve.CveId
	ih.IssueNum = issueNum
	ih.Owner = owner
	ih.Status = 1
	ih.Repo = path
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error:", err)
		return err
	}
	pwd := BConfig.String("hook::hookpwd")
	hookurl := BConfig.String("hook::hookurl")
	ihs, errh := models.GetIssueHook(&ih)
	if errh {
		var hookExist = false
		for _, wh := range ihs {
			if wh.HookUrl == hookurl {
				hookExist = true
				if accessToken != "" && owner != "" && path != "" {
					url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks/" + strconv.Itoa(int(wh.HookId))
					push_events := "true"
					tag_push_events := "true"
					issues_events := "true"
					note_events := "true"
					merge_requests_events := "true"
					requestBody := fmt.Sprintf(`{
					"access_token": "%s",
					"url": "%s", 
					"password": "%s",
					"push_events": "%s",
					"tag_push_events": "%s",
					"issues_events": "%s",
					"note_events": "%s",
					"merge_requests_events": "%s"
					}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
					logs.Info("hook_body: ", requestBody)
					resp, err := util.HTTPPatch(url, requestBody)
					if err != nil {
						logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
						return err
					}
					if _, ok := resp["id"]; !ok {
						logs.Error("创建仓库 hook失败, err: ", ok, "url: ", url)
						return errors.New("创建仓库 hook失败")
					}
					if resp["password"].(string) == pwd {
						var issHook models.IssueHooks
						CreateIssueHookData(&issHook, cve, resp,
							path, owner, issueNum, issueId)
						hookId, err := models.CreateDepositHooks(&issHook)
						if err != nil {
							logs.Error("创建仓库 hook数据失败, cveNum: ", cve.CveNum, "err: ", err)
							return nil
						} else {
							logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
						}
					}
				}
			}
		}
		if !hookExist {
			if accessToken != "" && owner != "" && path != "" {
				url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks"
				push_events := "true"
				tag_push_events := "true"
				issues_events := "true"
				note_events := "true"
				merge_requests_events := "true"
				requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
				logs.Info("hook_body: ", requestBody)
				resp, err := util.HTTPPost(url, requestBody)
				if err != nil {
					logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
					return err
				}
				if _, ok := resp["id"]; !ok {
					logs.Error("创建仓库hook失败, err: ", ok, "url: ", url)
					return errors.New("创建仓库hook失败")
				}
				if resp["password"].(string) == pwd {
					var issHook models.IssueHooks
					CreateIssueHookData(&issHook, cve, resp,
						path, owner, issueNum, issueId)
					// Store issue data
					hookId, err := models.CreateDepositHooks(&issHook)
					if err != nil {
						logs.Error("创建仓库hook失败, cveNum: ", cve.CveNum, "err: ", err)
						return err
					} else {
						logs.Info("创建仓库 hook数据成功, hookId: ", hookId, "cveNum: ", cve.CveNum)
					}
				}
			}
		}
	} else {
		if accessToken != "" && owner != "" && path != "" {
			url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/hooks"
			push_events := "true"
			tag_push_events := "true"
			issues_events := "true"
			note_events := "true"
			merge_requests_events := "true"
			requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"url": "%s", 
			"password": "%s",
			"push_events": "%s",
			"tag_push_events": "%s",
			"issues_events": "%s",
			"note_events": "%s",
			"merge_requests_events": "%s"
			}`, accessToken, hookurl, pwd, push_events, tag_push_events, issues_events, note_events, merge_requests_events)
			logs.Info("hook_body: ", requestBody)
			resp, err := util.HTTPPost(url, requestBody)
			if err != nil {
				logs.Error("创建钩子失败, url: ", url, "cveId", cve.CveId, "err: ", err)
				return err
			}
			if _, ok := resp["id"]; !ok {
				logs.Error("创建仓库hook失败, err: ", ok, "url: ", url)
				return errors.New("创建仓库hook失败")
			}
			if resp["password"].(string) == pwd {
				var issHook models.IssueHooks
				CreateIssueHookData(&issHook, cve, resp,
					path, owner, issueNum, issueId)
				// Store issue data
				hookID, err := models.CreateDepositHooks(&issHook)
				if err != nil {
					logs.Error("创建仓库hook失败, cveNum: ", cve.CveNum, "err: ", err)
					return err
				}
				logs.Info("创建仓库 hook数据成功, hookID: ", hookID, "cveNum: ", cve.CveNum)
			}
		}
	}
	return nil
}

func CreateIssueComment(accessToken, owner, path, assignee string,
	cve models.VulnCenter, issResp map[string]interface{}, affectedVersion string) error {
	issueNum := issResp["number"].(string)
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issueNum + "/comments"
		BConfig, err := config.NewConfig("ini", "conf/app.conf")
		if err != nil {
			logs.Error("config init error:", err)
			return err
		}
		commentCmd := BConfig.String("reflink::comment_cmd")
		commentBody := CommentTemplate(assignee, commentCmd, affectedVersion, path)
		requestBody := fmt.Sprintf(`{
			"access_token": "%s",
			"body": "%s"
			}`, accessToken, commentBody)
		logs.Info("create issue comment body: ", requestBody)
		resp, err := util.HTTPPost(url, requestBody)
		if err != nil {
			logs.Error("创建issue评论失败, url: ", url, "cveId", cve.CveId, ",issueNum: ", issueNum, ",err: ", err)
			return err
		}
		if _, ok := resp["id"]; !ok {
			logs.Error("创建issue评论失败, err: ", ok, "url: ", url)
			return errors.New("创建issue评论失败")
		}
		commentID := int64(resp["id"].(float64))
		models.UpdateIssueCommentId(issueNum, cve.CveNum, commentID)
	}
	return nil
}

func AddAffectBrands(branchVersion string) string {
	branchs := ""
	if branchVersion != "" && len(branchVersion) > 1 {
		brandsGroup := strings.Split(branchVersion, ",")
		if len(brandsGroup) > 0 {
			for _, brand := range brandsGroup {
				if brand == "" || len(brand) < 2 {
					continue
				}
				brandList := strings.Split(brand, ":")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" {
						branchs += brandList[0] + "/"
					}
				} else {
					brandList := strings.Split(brand, "：")
					if len(brandList) > 1 {
						prams := strings.Replace(brandList[1], " ", "", -1)
						if prams == "受影响" {
							branchs += brandList[0] + "/"
						}
					}
				}
			}
		}
	}
	if branchs != "" && len(branchs) > 1 {
		branchs = branchs[:len(branchs)-1]
	}
	return branchs
}

func CreateSecNoticeData(sec *models.SecurityNotice, iss models.VulnCenter,
	path, branchVersion string, opScore float64) {
	branchs := AddAffectBrands(branchVersion)
	sec.CveId = iss.CveId
	sec.CveNum = iss.CveNum
	opScoreLeve := openEulerScoreProc(opScore)
	sec.Introduction = "An update for " + path + " is now available for " + branchs + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ";\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + opScoreLeve + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = branchs
}

func CreateIssueLabel(accessToken string, owner string, path string,
	issNum string) error {
	if accessToken != "" && owner != "" && path != "" {
		url := "https://gitee.com/api/v5/repos/" + owner + "/" + path + "/issues/" + issNum + "/labels"
		body := make(map[string]interface{})
		body["access_token"] = accessToken
		body["body"] = fmt.Sprintf(`[%s,%s]`, beego.AppConfig.String("labelUnFix"), beego.AppConfig.String("labelUnFix"))
		requestBody, _ := json.Marshal(body)
		logs.Info("create issue label: ", string(requestBody))
		resp, err := util.HTTPPost1(url, string(requestBody))
		if err != nil {
			logs.Error("cve标签创建失败, url: ", url, "requestBody: ", requestBody, "err: ", err)
			return err
		}
		for _, value := range resp {
			if _, ok := value["id"]; !ok {
				logs.Error("创建issue 标签失败, err: ", ok, "url: ", url)
				return errors.New("创建issue标签失败")
			}
		}
		logs.Info("issue 标签创建成功, resp: ", resp)
	}
	return nil
}
