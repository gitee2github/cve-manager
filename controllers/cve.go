package controllers

import (
	"cvevulner/common"
	"cvevulner/errcode"
	"cvevulner/models"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"time"
)

type CveIssueInfoController struct {
	beego.Controller
}

func (c *CveIssueInfoController) RetData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type CveIssueInfoData struct {
	IssueNum       string  `json:"issue_id"`
	CveNum         string  `json:"CVE_num"`
	OpeneulerScore float64 `json:"openeuler_score"`
	NvdScore       float64 `json:"NVD_score"`
	Branch         string  `json:"milestone"`
}

// @Title Get cveissueinfo
// @Description get cve
// @Param	status	int	true (0,1,2)
// @Success 200 {object} CveIssueInfoData
// @Failure 403 :status is err
// @router / [get]
func (u *CveIssueInfoController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		", Header: ", req.Header, ", body: ", req.Body)
	resp := make(map[string]interface{})
	var ird []CveIssueInfoData
	resp["code"] = errcode.RecodeNodata
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
	resp["body"] = []CveIssueInfoData{}
	resp["total"] = 0
	defer u.RetData(resp)
	milestone := u.GetString("milestone", "")
	count := models.QueryIssueCount(milestone)
	if count > 0 {
		resp["total"] = count
		resp["code"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		currentPage, err := u.GetInt("currentPage", 1)
		if err != nil {
			logs.Error("err: ", err, ", currentPage: ", currentPage)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			return
		}
		pageSize, err := u.GetInt("pageSize", 100)
		if err != nil {
			logs.Error("err: ", err, ", pageSize: ", pageSize)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			return
		}
		issueData, issueErr := models.QueryCveIssueByBranch(currentPage, pageSize, milestone)
		if issueErr == nil && len(issueData) > 0 {
			for _, issues := range issueData {
				var irda CveIssueInfoData
				irda.CveNum = issues.CveNum
				irda.IssueNum = issues.IssueNum
				irda.OpeneulerScore = issues.OpeneulerScore
				irda.NvdScore = issues.NvdScore
				irda.Branch = issues.AffectProduct
				ird = append(ird, irda)
			}
			resp["body"] = ird
			resp["code"] = errcode.RecodeOk
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		} else {
			resp["code"] = errcode.RecodeNodata
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
			return
		}
	}
}

type CveAllIssueController struct {
	beego.Controller
}

func (c *CveAllIssueController) RetCveData(resp map[string]interface{}) {
	c.Data["json"] = resp
	c.ServeJSON()
}

type CveAllIssueoData struct {
	IssueNum       string  `json:"issue_id"`
	CveNum         string  `json:"CVE_num"`
	OpeneulerScore float64 `json:"openeuler_score"`
	NvdScore       float64 `json:"NVD_score"`
	Branch         string  `json:"milestone"`
	CveLevel       string  `json:"CVE_level"`
	PlanClosedTime string  `json:"plan_closed_time"`
	CvePublicTime  string  `json:"CVE_public_time"`
	RpmPublicTime  string  `json:"rpm_public_time"`
	SaPublicTime   string  `json:"SA_public_time"`
}

// @Title Obtain all cve data and provide operation kanban for use
// @Description get issue
// @Param	pageSize 1,currentPage 10, updatetime nil
// @Success 200 {object} CveAllIssueoData
// @Failure 403 :status is err
// @router / [get]
func (u *CveAllIssueController) Get() {
	req := u.Ctx.Request
	addr := req.RemoteAddr
	logs.Info("Method: ", req.Method, "Client request ip address: ", addr,
		", Header: ", req.Header, ", body: ", req.Body)
	resp := make(map[string]interface{})
	var cid []CveAllIssueoData
	resp["code"] = errcode.RecodeNodata
	resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
	resp["body"] = []CveAllIssueoData{}
	resp["total"] = 0
	defer u.RetCveData(resp)
	communityFlag, flagErr := u.GetInt("communityFlag", 0)
	if flagErr != nil {
		communityFlag = 0
	}
	startTime := u.GetString("startTime", "")
	count := models.QueryCveAllIssueCount(communityFlag, startTime)
	if count > 0 {
		resp["total"] = count
		resp["code"] = errcode.RecodeOk
		resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		currentPage, err := u.GetInt("currentPage", 1)
		if err != nil {
			logs.Error("err: ", err, ", currentPage: ", currentPage)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			return
		}
		pageSize, err := u.GetInt("pageSize", 100)
		if err != nil {
			logs.Error("err: ", err, ", pageSize: ", pageSize)
			resp["errno"] = errcode.RecodeParamErr
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeParamErr)
			return
		}
		issueData, issueErr := models.QueryCveAllIssueData(currentPage, pageSize, communityFlag, startTime)
		if issueErr == nil && len(issueData) > 0 {
			for _, issues := range issueData {
				var irda CveAllIssueoData
				irda.CveNum = issues.CveNum
				irda.IssueNum = issues.IssueNum
				irda.OpeneulerScore = issues.OpeneulerScore
				irda.NvdScore = issues.NvdScore
				irda.Branch = issues.AffectedVersion
				irda.CveLevel = issues.CveLevel
				irda.PlanClosedTime = CvePlanCloseTime(issues.CreateTime, issues.CveLevel)
				if len(issues.CpublicTime) > 10 {
					irda.CvePublicTime = issues.CpublicTime[:10]
				} else {
					irda.CvePublicTime = issues.CpublicTime
				}
				if len(issues.RpmReleaseTime) > 2 {
					irda.RpmPublicTime = issues.RpmReleaseTime
				} else {
					irda.RpmPublicTime = issues.SaReleaseTime
				}
				irda.SaPublicTime = issues.SaReleaseTime
				cid = append(cid, irda)
			}
			resp["body"] = cid
			resp["code"] = errcode.RecodeOk
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeOk)
		} else {
			resp["code"] = errcode.RecodeNodata
			resp["errmsg"] = errcode.RecodeText(errcode.RecodeNodata)
			return
		}
	}
}

func CvePlanCloseTime(startTime time.Time, cveLevel string) string {
	endLocal := ""
	switch cveLevel {
	case "Critical":
		endLocal = common.GetSpecifiedTime(startTime, 7, false)
	case "High":
		endLocal = common.GetSpecifiedTime(startTime, 14, false)
	case "Medium", "Low":
		endLocal = common.GetSpecifiedTime(startTime, 30, false)
	default:
		endLocal = common.GetSpecifiedTime(startTime, 60, false)
	}
	return endLocal
}
