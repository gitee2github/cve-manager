package controllers

import (
	"bytes"
	"cvevulner/models"
	"cvevulner/taskhandler"
	"cvevulner/util"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"net/http"
	"os"
	"strconv"
	"strings"
)

var (
	//GiteeUserAgent gitee hook request flag
	GiteeUserAgent = "git-oschina-hook"
	//XGiteeToken password or sign
	XGiteeToken = "X-Gitee-Token"
	//XGIteeEventType webhook event type
	XGIteeEventType = "X-Gitee-Event"
	//NoteHookType type of comment
	NoteHookType = "Note Hook"
	//PullReqHookType type of pull request
	PullReqHookType = "merge_request_hooks"
	//PushTagHookType type of push or tag
	PushTagHookType = "push_hooks/tag_push_hooks"
	//IssueHookType type of issue
	IssueHookType = "Issue Hook"
)

const (
	//CommentAnalysisCplTpl complete comment analysis reply template
	CommentAnalysisCplTpl = "@%v %v"
	//ReviewPrivateLettersTpl send private review letters template
	ReviewPrivateLettersTpl = `%s(%s)analysis is over,CVEScore:%v;OpenEulerScore:%v。Please review!`
	//ReviewRejectScore reply the review reject template
	ReviewRejectScore = `@%v you submit issue score audit failed(reject by %v)，Please re-analyze and submit!`
	//ReviewApproveScore replay the review approve template
	ReviewApproveScore = `@%v you submit issue score audit success(approved by %v)，You can proceed to the next step!`
	//CommentReviewTpl comment review template
	CommentReviewTpl = `%v The CVE score needs to be reviewed (the review instruction /approve&/reject means agreement and rejection)。`
	//IssueRejectState issue state rejected
	IssueRejectState = "rejected"
	//IssueCloseState issue state closed
	IssueCloseState = "closed"
	//IssueProgressState issue  state progressing
	IssueProgressState = "progressing"
	//IssueOpenState issue state open
	IssueOpenState = "open"
	//AnalysisComplete issue analysis complete comment
	AnalysisComplete = "@%v 经过 cve-manager 解析， 您分析的内容如下表所示:\n"
)

//HookEventControllers gitee hook callback
type HookEventControllers struct {
	beego.Controller
}

//Post handle gitee webhook
// @router / [post]
func (c *HookEventControllers) Post() {
	if ok := c.isLegitimateHookEvent(); !ok {
		return
	}
	eventType := c.Ctx.Request.Header.Get(XGIteeEventType)
	switch eventType {
	case NoteHookType: //handle comment hook data
		c.handleNoteDate()
	case PullReqHookType:
		c.handlePullReq()
	case IssueHookType:
		c.handleIssue()
	case PushTagHookType:
		c.handlePushTag()
	default:
		logs.Info(eventType)
	}
}

//isLegitimateHookEvent according to gitee doc judge
func (c *HookEventControllers) isLegitimateHookEvent() (ok bool) {
	ok = true
	//judge user agent
	uAgent := c.Ctx.Request.Header.Get("User-Agent")
	if uAgent != GiteeUserAgent {
		ok = false
	}
	ctType := c.Ctx.Request.Header.Get("Content-Type")
	if "application/json" != ctType {
		ok = false
	}
	//judge hook password
	xToken := c.Ctx.Request.Header.Get(XGiteeToken)
	logs.Info(xToken)
	return
}

func (c *HookEventControllers) handleNoteDate() {
	//logs.Info(string(c.Ctx.Input.RequestBody))
	var hookNote models.CommentPayload
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &hookNote)
	if err != nil {
		logs.Error(err)
		return
	}
	if hookNote.Action == "comment" && hookNote.NoteableType == "Issue" {
		//handle issue comment
		go handleIssueComment(hookNote)
	}
}

func (c *HookEventControllers) handlePullReq() {

}

func (c *HookEventControllers) handlePushTag() {

}

func (c *HookEventControllers) handleIssue() {
	logs.Info(string(c.Ctx.Input.RequestBody))
	issueHook := models.IssuePayload{}
	err := json.Unmarshal(c.Ctx.Input.RequestBody, &issueHook)
	if err != nil {
		logs.Error(err)
		return
	}
	if issueHook.Action == "assign" {
		//Update the person in charge of the issue template
		issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
		}
		issueTmp.Assignee = issueHook.Assignee.Login
		err = models.UpdateIssueTemplate(&issueTmp, "issue_assignee")
		if err != nil {
			logs.Error(err)
		}
	}
	if issueHook.Action == "state_change" {
		//handle issue state change
		err = handleIssueStateChange(&issueHook)
		if err != nil {
			logs.Error(err)
		}
	}

}

func handleIssueStateChange(issueHook *models.IssuePayload) error {
	unFix := beego.AppConfig.String("labelUnFix")
	fixed := beego.AppConfig.String("labelFixed")
	issueTmp := models.IssueTemplate{IssueNum: issueHook.Iid}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		return err
	}
	cveCenter := models.VulnCenter{CveId: issueTmp.CveId}
	err = models.GetVulnCenterByCid(&cveCenter, "cve_id")
	if err != nil {
		return err
	}
	switch issueHook.State {
	case IssueOpenState:
		issueTmp.Status = 1
		cveCenter.IsExport = 0
		_, _, ok := checkIssueAnalysisComplete(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
		//issueTmp.IssueStatus = 1
	case IssueProgressState:
		issueTmp.Status = 2
		cveCenter.IsExport = 0
		_, _, ok := checkIssueAnalysisComplete(&issueTmp)
		if ok {
			issueTmp.IssueStatus = 3
		} else {
			issueTmp.IssueStatus = 1
		}
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
	case IssueCloseState:
		issueTmp.Status = 3
		if isNormalCloseIssue(issueTmp.CveId, issueTmp.IssueStatus) {
			issueTmp.IssueStatus = 2
			cveCenter.IsExport = 3
			issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(unFix, fixed)
		} else {
			issueTmp.IssueStatus = 6
			cveCenter.IsExport = 2
			issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
		}
	case IssueRejectState:
		issueTmp.Status = 4
		issueTmp.IssueStatus = 6
		cveCenter.IsExport = 2
		issueTmp.IssueLabel = issueHook.Issue.ReplaceLabelToStr(fixed, unFix)
	}
	issueTmp.StatusName = issueHook.Issue.StateName
	appearErr := 0
	err = models.UpdateIssueTemplate(&issueTmp, "status", "issue_status", "status_name", "issue_label")
	if err != nil {
		logs.Error(err)
		appearErr += 1
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
		appearErr += 1
	}
	token := beego.AppConfig.String("gitee::git_token")
	owner := beego.AppConfig.String("gitee::owner")
	update = ChangeIssueLabel(token, issueTmp.Repo, issueHook.Issue.Number, owner, issueTmp.IssueLabel)
	if !update {
		logs.Error("update gitee issue label  fail ")
		appearErr++
	}
	sn := models.SecurityNotice{CveId: issueTmp.CveId}
	err = sn.Read("cve_id")
	if err != nil {
		return err
	}
	switch issueTmp.IssueStatus {
	case 2:
		sn.AffectStatus = "Fixed"
	case 6:
		sn.AffectStatus = "UnAffected"
	default:
		sn.AffectStatus = "UnFixed"
	}
	err = sn.Update("affect_status")
	if err != nil {
		appearErr++
		logs.Error(err)
	}
	if appearErr > 0 {
		return errors.New("handle issue state hook appear error maybe some step fail")
	}
	return nil
}

func isNormalCloseIssue(cveID int64, issueState int8) bool {
	if issueState == 1 {
		return false
	}
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		logs.Error(err)
		return false
	}
	if score.Ostatus != 3 {
		return false
	}
	return true
}

func handleIssueComment(payload models.CommentPayload) {
	if payload.Issue == nil || payload.Comment == nil {
		return
	}
	if payload.Comment.User == nil {
		return
	}
	issueNum := payload.Issue.Number           //issue number
	cBody := payload.Comment.Body              //Comment subject
	cuAccount := payload.Comment.User.UserName //gitee domain address
	cmdRej := beego.AppConfig.DefaultString("rejectCmd", "/reject")
	cmdApe := beego.AppConfig.DefaultString("approveCmd", "/approve")
	cmdClose := beego.AppConfig.DefaultString("closeCmd", "/close")
	if issueNum == "" || cuAccount == "" || cBody == "" {
		return
	}
	if strings.HasPrefix(cBody, cmdRej) {
		//Review rejected Add comment @Analyst
		if !isReviewer(cuAccount) {
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 2)
		if err != nil {
			logs.Error(err)
		}
		accessToken := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		//path := beego.AppConfig.String("gitee::path")
		path := issueTmp.Repo
		taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewRejectScore, issueTmp.Assignee, cuAccount), issueTmp.IssueNum, owner, path, accessToken)
	} else if strings.HasPrefix(cBody, cmdApe) {
		//Approved to modify the rating status
		if !isReviewer(cuAccount) {
			return
		}
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		err = changeOpenEulerScoreStatus(issueTmp.CveId, 3)
		if err != nil {
			logs.Error(err)
		} else {
			accessToken := os.Getenv("GITEE_TOKEN")
			owner := beego.AppConfig.String("gitee::owner")
			//path := beego.AppConfig.String("gitee::path")
			path := issueTmp.Repo
			taskhandler.AddCommentToIssue(fmt.Sprintf(ReviewApproveScore, issueTmp.Assignee, cuAccount), issueTmp.IssueNum, owner, path, accessToken)
		}

	} else if strings.HasPrefix(cBody, cmdClose) {
		//close issue
		issueTmp := models.IssueTemplate{IssueNum: issueNum}
		err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
		if err != nil {
			logs.Error(err)
			return
		}
		if cuAccount == issueTmp.Assignee {
			//call the gitee api to change issue status
			c := strings.Trim(cBody, cmdClose)
			issueTmp.ErrorDescription = c
			token := beego.AppConfig.String("gitee::git_token")
			owner := beego.AppConfig.String("gitee::owner")
			success := CloseIssue(token, issueTmp.Repo, issueNum, owner)
			if success {
				//update issue tpl
				err = models.UpdateIssueTemplate(&issueTmp, "error_description")
				if err != nil {
					logs.Error(err)
					return
				}
			}
		}
	} else {
		cBody = strings.ReplaceAll(cBody, "：", ":")
		analysisComment(issueNum, cuAccount, cBody, &payload)
	}

}

func isReviewer(path string) bool {
	sr := models.SecurityReviewer{NameSpace: path}
	return sr.Read("name_space")
}

func analysisComment(issueNum string, cuAccount string, cBody string, payload *models.CommentPayload) {
	issueTmp := models.IssueTemplate{IssueNum: issueNum}
	err := models.GetIssueTemplateByColName(&issueTmp, "issue_num")
	if err != nil {
		logs.Error(err)
		return
	}
	canVerfy := false
	if cuAccount == issueTmp.Assignee {
		//is Analyst comment and content start with '/analysis'
		vMap := util.ExtractCommentAnalysisAllValue(cBody)
		if len(vMap) > 0 {
			canVerfy = true
			cols := make([]string, 0)
			for k, v := range vMap {
				switch k {
				case "cve_analysis":
					issueTmp.CveAnalysis = v
					cols = append(cols, k)
				case "principle_analysis":
					issueTmp.PrincipleAnalysis = v
					cols = append(cols, k)
				case "openeuler_score":
					fv, err := strconv.ParseFloat(v, 64)
					if err == nil {
						issueTmp.OpenEulerScore = fv
						cols = append(cols, k)
					}
				case "openeuler_vector":
					issueTmp.OpenEulerVector = v
					cols = append(cols, k)
				case "affected_version":
					if v != "" && len(v) > 1 {
						issueTmp.AffectedVersion = v
					}
					cols = append(cols, k)
				case "solution":
					issueTmp.Solution = v
					cols = append(cols, k)
				}
			}
			if len(cols) > 0 {
				err := models.UpdateIssueTemplate(&issueTmp, cols...)
				if err != nil {
					logs.Error(err)
				} else {
					if _, ok := vMap["openeuler_vector"]; ok {
						err := saveVectorData(vMap["openeuler_vector"], issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						}
					}
					if _, ok := vMap["openeuler_score"]; ok {
						//更新分数到 score
						score, err := models.QueryIssueScore(issueTmp.CveId)
						if err != nil {
							logs.Error(err)
						} else {
							score.OpenEulerScore = issueTmp.OpenEulerScore
							score.Ostatus = 1
							err := models.UpdateScore(&score, "openeuler_score", "o_score_status")
							if err != nil {
								logs.Error(err)
							}
						}
					}
				}
			}
			if _, ok := vMap["issue_package"]; ok {
				// handle comment package
				err := handleCommentPackage(vMap["issue_package"], issueTmp.CveId)
				if err != nil {
					logs.Error(err)
				}
			}
			// update gitee issue
			commentUpdateIssue(issueTmp)
		}

	}
	if cuAccount == issueTmp.Assignee && canVerfy {
		//Check whether the data is legal
		accessToken := os.Getenv("GITEE_TOKEN")
		owner := beego.AppConfig.String("gitee::owner")
		path := issueTmp.Repo
		if msg, tb, ok := checkIssueAnalysisComplete(&issueTmp); !ok {
			//send comment to issue
			issueTmp.IssueStatus = 1
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			msg = fmt.Sprintf(CommentAnalysisCplTpl, issueTmp.Assignee, msg)
			taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)
		} else {
			//1. change issue status
			issueTmp.IssueStatus = 3
			err := models.UpdateIssueTemplate(&issueTmp, "issue_status")
			if err != nil {
				logs.Error(err)
			}
			//2. Are the cvsScore and openEuler score  equal .If not equal, notify the auditor to review .
			var na string
			if issueTmp.OpenEulerScore != issueTmp.NVDScore {
				na = "\n**因OpenEulerScore与NvdScore不一致，分析内容需审核，请等待审核！**"
				//Notify the responsible person for review
				notifyAuditorReview(payload, issueTmp)
			} else {
				na = "\n**请确认分析内容的准确性，确认无误后，您可以进行后续步骤，否则您可以继续分析。**"
				// change score status
				err := changeOpenEulerScoreStatus(issueTmp.CveId, 3)
				if err != nil {
					logs.Error(err)
				}
			}
			cc := fmt.Sprintf(AnalysisComplete, issueTmp.Assignee) + tb + na
			taskhandler.AddCommentToIssue(cc, issueTmp.IssueNum, owner, path, accessToken)
		}
	}
}

func notifyAuditorReview(payload *models.CommentPayload, issueTmp models.IssueTemplate) {
	//Notify the responsible person for review
	list, err := models.GetSecurityReviewerList()
	if err != nil {
		logs.Error(err)
		return
	}
	if len(list) == 0 {
		return
	}
	accessToken := os.Getenv("GITEE_TOKEN")
	content := fmt.Sprintf(ReviewPrivateLettersTpl,
		payload.Issue.Title, payload.Issue.HtmlUrl, issueTmp.NVDScore, issueTmp.OpenEulerScore)
	owner := beego.AppConfig.String("gitee::owner")
	//path := beego.AppConfig.String("gitee::path")
	path := issueTmp.Repo
	ns := make([]string, len(list))
	for k, v := range list {
		ns[k] = "@" + v.NameSpace + " "
		taskhandler.SendPrivateLetters(accessToken, content, v.NameSpace)
		//add @comment
	}
	msg := fmt.Sprintf(CommentReviewTpl, strings.Join(ns, ","))
	taskhandler.AddCommentToIssue(msg, issueTmp.IssueNum, owner, path, accessToken)

}

func changeOpenEulerScoreStatus(cveID int64, status int8) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	score.Ostatus = status
	err = models.UpdateScore(&score, "o_score_status")
	return err
}

func checkIssueAnalysisComplete(i *models.IssueTemplate) (msg, tbStr string, ok bool) {
	tb :=
		`| 状态  | 需分析             | 内容      |
|-----|-----------------|---------|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
|%v|%v|%v|
`

	if i == nil {
		logs.Error("issue template is nil")
		return msg, "", false
	}
	ok = true
	tbContent := make([]interface{}, 12)
	if i.OpenEulerScore == 0.0 {
		msg = fmt.Sprintf("openEulerScore没有填写或正确填写(0-10)")
		ok = false
		return
	}
	tbContent[0] = "已分析"
	tbContent[1] = "openEulerScore"
	tbContent[2] = i.OpenEulerScore

	if util.TrimString(i.CveAnalysis) == "" {
		msg = fmt.Sprintf("影响性分析说明没有填写:%v", i.CveAnalysis)
		ok = false
		return
	}
	tbContent[3] = "已分析"
	tbContent[4] = "影响性分析说明"
	tbContent[5] = util.TrimStringNR(i.CveAnalysis)
	if i.OpenEulerVector == "" {
		msg = fmt.Sprintf("openEulerVector没有填写:%v", i.OpenEulerVector)
		ok = false
		return
	}
	tbContent[6] = "已分析"
	tbContent[7] = "openEulerVector"
	tbContent[8] = util.TrimStringNR(i.OpenEulerVector)
	if i.AffectedVersion != "" {
		versionfFlag := true
		affectedVersionArry := strings.Split(i.AffectedVersion, ",")
		if len(affectedVersionArry) > 0 {
			for _, affect := range affectedVersionArry {
				versionArry := strings.Split(affect, ":")
				if len(versionArry) > 1 {
					if versionArry[1] == "受影响" || versionArry[1] == "不受影响" {
						continue
					} else {
						versionfFlag = false
						break
					}
				} else {
					versionfFlag = false
					break
				}
			}
		}
		if !versionfFlag {
			msg = fmt.Sprintf("受影响版本排查 没有分析或未按正确格式填写:%v", i.AffectedVersion)
			ok = false
			return
		}
		if versionfFlag {
			tbContent[9] = "已分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		} else {
			tbContent[9] = "待分析"
			tbContent[10] = "受影响版本排查"
			tbContent[11] = util.TrimStringNR(i.AffectedVersion)
		}
	} else {
		tbContent[9] = "已分析"
		tbContent[10] = "受影响版本排查"
		tbContent[11] = ""
	}
	tbStr = fmt.Sprintf(tb, tbContent...)
	return
}

func commentUpdateIssue(issueTmp models.IssueTemplate) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := beego.AppConfig.String("gitee::owner")
	path := issueTmp.Repo
	if accessToken != "" && owner != "" && path != "" {
		cvlnCenter := models.VulnCenter{}
		err := models.GetVulnCenterByCVEID(&cvlnCenter, issueTmp.CveId)
		if err != nil {
			logs.Error(err)
		} else {
			_, err := taskhandler.UpdateIssueToGit(accessToken, owner, path, cvlnCenter, issueTmp)
			if err != nil {
				logs.Error(err)
			}
		}
	}
}

func saveVectorData(vct string, cveID int64) error {
	score, err := models.QueryIssueScore(cveID)
	if err != nil {
		return err
	}
	if vct == "" {
		return errors.New("vct value is empty")
	}
	upFields := make([]string, 0)
	score.OvectorVule = vct
	upFields = append(upFields, "o_vector_value")
	vMap, ok := util.VctToMap(vct)
	if !ok {
		return errors.New("vector value illegal")
	}
	if util.RegexpVectorV2.Match([]byte(vct)) {
		//update v2 vector
		avv := util.ReadVMValueV2(vMap["AV"])
		if avv != "" {
			score.OaccessVector = avv
			upFields = append(upFields, "o_access_vector")
		}
		acv := util.ReadVMValueV2(vMap["AC"])
		if acv != "" {
			score.OaccessComplexity = acv
			upFields = append(upFields, "o_access_complexity")
		}
		au := util.ReadVMValueV2(vMap["Au"])
		if au != "" {
			score.Oauthentication = au
			upFields = append(upFields, "o_authentication")
		}
		cv := util.ReadVMValueV2(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValueV2(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValueV2(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	} else {
		//update v3 vector
		avv := util.ReadVMValue(vMap["AV"])
		if avv != "" {
			score.OattackVector = avv
			upFields = append(upFields, "o_attack_vector")
		}
		acv := util.ReadVMValue(vMap["AC"])
		if acv != "" {
			score.OattackComplexity = acv
			upFields = append(upFields, "o_attack_complexity")
		}
		prv := util.ReadVMValue(vMap["PR"])
		if prv != "" {
			score.OprivilegeRequired = prv
			upFields = append(upFields, "o_privilege_required")
		}
		uiv := util.ReadVMValue(vMap["UI"])
		if uiv != "" {
			score.OuserInteraction = uiv
			upFields = append(upFields, "o_user_interaction")
		}
		sv := util.ReadVMValue(vMap["S"])
		if sv != "" {
			score.Oscope = sv
			upFields = append(upFields, "o_scope")
		}
		cv := util.ReadVMValue(vMap["C"])
		if cv != "" {
			score.Oconfidentiality = cv
			upFields = append(upFields, "o_confidentiality")
		}
		iv := util.ReadVMValue(vMap["I"])
		if iv != "" {
			score.Ointegrity = iv
			upFields = append(upFields, "o_integrity")
		}
		av := util.ReadVMValue(vMap["A"])
		if av != "" {
			score.Oavailability = av
			upFields = append(upFields, "o_availability")
		}
	}
	if len(upFields) > 0 {
		//Perform update
		err = models.UpdateScore(&score, upFields...)
		if err != nil {
			return err
		}
	}
	return nil
}

func handleCommentPackage(packageStr string, cveID int64) error {
	packageStr = util.TrimString(packageStr)
	err := models.UpdatePackageByCveId(packageStr, cveID)
	if err != nil {
		return err
	}
	return nil
}

//CloseIssue close gitee issue
func CloseIssue(token, repo, issueNum, owner string) bool {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/issues/%s", owner, issueNum)
	param := struct {
		AccessToken string `json:"access_token"`
		Repo        string `json:"repo"`
		State       string `json:"state"`
	}{token, repo, "closed"}
	pj, err := json.Marshal(&param)
	if err != nil {
		logs.Error(err)
		return false
	}
	return UpdateGiteIssue(url, pj)
}

//ChangeIssueLabel update  issue label
func ChangeIssueLabel(token, repo, issueNum, owner, label string) bool {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/issues/%s", owner, issueNum)
	param := struct {
		AccessToken string `json:"access_token"`
		Repo        string `json:"repo"`
		Label       string `json:"labels"`
	}{token, repo, label}
	pj, err := json.Marshal(&param)
	if err != nil {
		logs.Error(err)
		return false
	}
	return UpdateGiteIssue(url, pj)
}

//UpdateGiteIssue update gitee issue
func UpdateGiteIssue(url string, param []byte) bool {
	read := bytes.NewReader(param)
	req, err := http.NewRequest(http.MethodPatch, url, read)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer req.Body.Close()
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logs.Error(err)
		return false
	}
	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		return true
	}
	return false
}
